{"version":3,"sources":["../../src/index.ts","../../../../node_modules/@noble/curves/node_modules/@noble/hashes/src/_assert.ts","../../../../node_modules/@noble/curves/node_modules/@noble/hashes/src/cryptoNode.ts","../../../../node_modules/@noble/curves/node_modules/@noble/hashes/src/utils.ts","../../../../node_modules/@noble/curves/node_modules/@noble/hashes/src/_md.ts","../../../../node_modules/@noble/curves/node_modules/@noble/hashes/src/_u64.ts","../../../../node_modules/@noble/curves/node_modules/@noble/hashes/src/sha512.ts","../../../../node_modules/@noble/curves/src/abstract/utils.ts","../../../../node_modules/@noble/curves/src/abstract/modular.ts","../../../../node_modules/@noble/curves/src/abstract/curve.ts","../../../../node_modules/@noble/curves/src/abstract/edwards.ts","../../../../node_modules/@noble/curves/src/ed25519.ts","../../../../node_modules/@noble/hashes/src/_assert.ts","../../../../node_modules/@noble/hashes/src/utils.ts","../../../../node_modules/@noble/hashes/src/_md.ts","../../../../node_modules/@noble/hashes/src/sha256.ts","../../../../node_modules/base58-js/base58_chars.mjs","../../../../node_modules/base58-js/base58_to_binary.mjs","../../../../node_modules/base58-js/create_base58_map.mjs","../../../../node_modules/base58-js/binary_to_base58.mjs","../../../../node_modules/big.js/big.mjs","../../../../node_modules/js-base64/base64.mjs","../../src/misc.ts","../../src/crypto.ts","../../../../node_modules/borsh/lib/esm/types.js","../../../../node_modules/borsh/lib/esm/buffer.js","../../../../node_modules/borsh/lib/esm/utils.js","../../../../node_modules/borsh/lib/esm/serialize.js","../../../../node_modules/borsh/lib/esm/deserialize.js","../../../../node_modules/borsh/lib/esm/index.js","../../../borsh-schema/src/index.ts","../../src/transaction.ts"],"sourcesContent":["export * from \"./crypto.js\";\nexport * from \"./transaction.js\";\nexport * from \"./misc.js\";\n\nexport * as reExportBorshSchema from \"@fastnear/borsh-schema\";\n","function anumber(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction ahash(h: Hash) {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\nfunction aexists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out: any, instance: any) {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };\n\nconst assert = {\n  number: anumber,\n  bytes: abytes,\n  hash: ahash,\n  exists: aexists,\n  output: aoutput,\n};\nexport default assert;\n","// We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n// Falls back to Node.js built-in crypto for Node.js <=v14\n// See utils.ts for details.\n// @ts-ignore\nimport * as nc from 'node:crypto';\nexport const crypto =\n  nc && typeof nc === 'object' && 'webcrypto' in nc\n    ? (nc.webcrypto as any)\n    : nc && typeof nc === 'object' && 'randomBytes' in nc\n      ? nc\n      : undefined;\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word: number, shift: number) =>\n  (word << shift) | ((word >>> (32 - shift)) >>> 0);\n\nexport const isLE = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n: number) => n : (n: number) => byteSwap(n);\n\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr: Uint32Array) {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","import { aexists, aoutput } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// BigUint64Array is too slow as per 2024, so we implement it using Uint32Array.\n// TODO: re-check https://issues.chromium.org/issues/42212588\n\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","import { HashMD } from './_md.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n  // Also looks cleaner and easier to verify with spec.\n  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x6a09e667 | 0;\n  Al = 0xf3bcc908 | 0;\n  Bh = 0xbb67ae85 | 0;\n  Bl = 0x84caa73b | 0;\n  Ch = 0x3c6ef372 | 0;\n  Cl = 0xfe94f82b | 0;\n  Dh = 0xa54ff53a | 0;\n  Dl = 0x5f1d36f1 | 0;\n  Eh = 0x510e527f | 0;\n  El = 0xade682d1 | 0;\n  Fh = 0x9b05688c | 0;\n  Fl = 0x2b3e6c1f | 0;\n  Gh = 0x1f83d9ab | 0;\n  Gl = 0xfb41bd6b | 0;\n  Hh = 0x5be0cd19 | 0;\n  Hl = 0x137e2179 | 0;\n\n  constructor() {\n    super(128, 64, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ) {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number) {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean() {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA512_224 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x8c3d37c8 | 0;\n  Al = 0x19544da2 | 0;\n  Bh = 0x73e19966 | 0;\n  Bl = 0x89dcd4d6 | 0;\n  Ch = 0x1dfab7ae | 0;\n  Cl = 0x32ff9c82 | 0;\n  Dh = 0x679dd514 | 0;\n  Dl = 0x582f9fcf | 0;\n  Eh = 0x0f6d2b69 | 0;\n  El = 0x7bd44da8 | 0;\n  Fh = 0x77e36f73 | 0;\n  Fl = 0x04c48942 | 0;\n  Gh = 0x3f9d85a8 | 0;\n  Gl = 0x6a1d36c8 | 0;\n  Hh = 0x1112e6ad | 0;\n  Hl = 0x91d692a1 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x22312194 | 0;\n  Al = 0xfc2bf72c | 0;\n  Bh = 0x9f555fa3 | 0;\n  Bl = 0xc84c64c2 | 0;\n  Ch = 0x2393b86b | 0;\n  Cl = 0x6f53b151 | 0;\n  Dh = 0x96387719 | 0;\n  Dl = 0x5940eabd | 0;\n  Eh = 0x96283ee2 | 0;\n  El = 0xa88effe3 | 0;\n  Fh = 0xbe5e1e25 | 0;\n  Fl = 0x53863992 | 0;\n  Gh = 0x2b0199fc | 0;\n  Gl = 0x2c85b8aa | 0;\n  Hh = 0x0eb72ddc | 0;\n  Hl = 0x81c52ca2 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 32;\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0xcbbb9d5d | 0;\n  Al = 0xc1059ed8 | 0;\n  Bh = 0x629a292a | 0;\n  Bl = 0x367cd507 | 0;\n  Ch = 0x9159015a | 0;\n  Cl = 0x3070dd17 | 0;\n  Dh = 0x152fecd8 | 0;\n  Dl = 0xf70e5939 | 0;\n  Eh = 0x67332667 | 0;\n  El = 0xffc00b31 | 0;\n  Fh = 0x8eb44a87 | 0;\n  Fl = 0x68581511 | 0;\n  Gh = 0xdb0c2e0d | 0;\n  Gl = 0x64f98fa7 | 0;\n  Hh = 0x47b5481d | 0;\n  Hl = 0xbefa4fa4 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 48;\n  }\n}\n\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nexport function abytes(item: unknown): void {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint) {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint) {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean) {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  stringOrUint8Array: (val: any) => typeof val === 'string' || isBytes(val),\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(fn: (arg: T, ...args: O) => R) {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport {\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n  validateObject,\n} from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n =/* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (modulo <= _0n) throw new Error('invalid modulus');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n// Inverses number over modulo\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) ≡ 1    if a is a square (mod p)\n  // (a | p) ≡ -1   if a is not a square (mod p)\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n    // Crash instead of infinity loop, we cannot reasonable count until P.\n    if (Z > 1000) throw new Error('Cannot find square root: likely non-prime P');\n  }\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\nexport function FpSqrt(P: bigint) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\n  // P ≡ 3 (mod 4)\n  // √n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P ≡ 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\n\n// Field is not always over prime: for example, Fp2 has ORDER(q)=p^m\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\nexport function FpLegendre(order: bigint) {\n  // (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n  // (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n  return <T>(f: IField<T>, x: T): T => f.pow(x, legendreConst);\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>) {\n  const legendre = FpLegendre(f.ORDER);\n  return (x: T): boolean => {\n    const p = legendre(f, x);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * NOTE: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      redef.sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { IField, validateField, nLength } from './modular.js';\nimport { validateObject, bitLen } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\nfunction constTimeNegate<T extends Group<T>>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\nfunction calcWOpts(W: number, bits: number) {\n  validateW(W, bits);\n  const windows = Math.ceil(bits / W) + 1; // +1, because\n  const windowSize = 2 ** (W - 1); // -1 because we skip zero\n  return { windows, windowSize };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>(); // This allows use make points immutable (nothing changes inside)\n\nfunction getW(P: any): number {\n  return pointWindowSizes.get(P) || 1;\n}\n\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\n  return {\n    constTimeNegate,\n\n    hasPrecomputes(elm: T) {\n      return getW(elm) !== 1;\n    },\n\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint, p = c.ZERO) {\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param elm Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = calcWOpts(W, bits);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc: T = c.ZERO): T {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        if (n === _0n) break; // No need to go over empty scalar\n        // Extract W bits.\n        let wbits = Number(n & mask);\n        // Shift number by W bits.\n        n >>= shiftBy;\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        if (wbits === 0) continue;\n        let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n        if (wbits < 0) curr = curr.negate();\n        // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n        acc = acc.add(curr);\n      }\n      return acc;\n    },\n\n    getPrecomputes(W: number, P: T, transform: Mapper<T>): T[] {\n      // Calculate precomputes on a first run, reuse them after\n      let comp = pointPrecomputes.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) pointPrecomputes.set(P, transform(comp));\n      }\n      return comp;\n    },\n\n    wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      const W = getW(P);\n      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n    },\n\n    wNAFCachedUnsafe(P: T, n: bigint, transform: Mapper<T>, prev?: T): T {\n      const W = getW(P);\n      if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n    },\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n\n    setWindowSize(P: T, W: number) {\n      validateW(W, bits);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    },\n  };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  scalars: bigint[]\n): T {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  if (points.length !== scalars.length)\n    throw new Error('arrays of points and scalars must have equal length');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(points.length));\n  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n  const MASK = (1 << windowSize) - 1;\n  const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < scalars.length; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as T;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  windowSize: number\n) {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar × 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 × 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = BigInt((1 << windowSize) - 1);\n  const tables = points.map((p: T) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): T => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n// Though generator can be different (Fp2 / Fp6 for BLS).\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²\nimport {\n  AffinePoint,\n  BasicCurve,\n  Group,\n  GroupConstructor,\n  validateBasic,\n  wNAF,\n  pippenger,\n} from './curve.js';\nimport { mod, Field } from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes, FHash, Hex, memoized, abool } from './utils.js';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n// Edwards curves must declare params a & d.\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n// Instance of Extended Point with coordinates in X, Y, Z, T\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods of Extended Point with coordinates in X, Y, Z, T\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n  msm(points: ExtPointType[], scalars: bigint[]): ExtPointType;\n}\n\n/**\n * Edwards Curve interface.\n * Main methods: `getPublicKey(priv)`, `sign(msg, priv)`, `verify(sig, msg, pub)`.\n */\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n};\n\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool('phflag', phflag);\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  // 0 <= n < MASK\n  // Coordinates larger than Fp.ORDER are allowed for zip215\n  function aCoordinate(title: string, n: bigint) {\n    ut.aInRange('coordinate ' + title, n, _0n, MASK);\n  }\n\n  function assertPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { ex: x, ey: y, ez: z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const { ex: X, ey: Y, ez: Z, et: T } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n\n    constructor(\n      readonly ex: bigint,\n      readonly ey: bigint,\n      readonly ez: bigint,\n      readonly et: bigint\n    ) {\n      aCoordinate('x', ex);\n      aCoordinate('y', ey);\n      aCoordinate('z', ez);\n      aCoordinate('t', et);\n      Object.freeze(this);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      aCoordinate('x', x);\n      aCoordinate('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.ez));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      assertPoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      assertPoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      // Faster algo for adding 2 Extended Points when curve's a=-1.\n      // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n      // Cost: 8M + 8add + 2*2.\n      // Note: It does not check whether the `other` point is valid.\n      if (a === BigInt(-1)) {\n        const A = modP((Y1 - X1) * (Y2 + X2));\n        const B = modP((Y1 + X1) * (Y2 - X2));\n        const F = modP(B - A);\n        if (F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing\n        const C = modP(Z1 * _2n * T2);\n        const D = modP(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = modP(E * F);\n        const Y3 = modP(G * H);\n        const T3 = modP(E * H);\n        const Z3 = modP(F * G);\n        return new Point(X3, Y3, Z3, T3);\n      }\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const n = scalar;\n      ut.aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const { p, f } = this.wNAF(n);\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      const n = scalar;\n      ut.aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return I;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, iz);\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = ut.bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      ut.aInRange('pointHex.y', y, _0n, max);\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex) {\n      return getExtendedPublicKey(privKey).point;\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(ut.bytesToNumberLE(hash));\n  }\n\n  /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n  function getExtendedPublicKey(key: Hex) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = new Uint8Array(), ...msgs: Uint8Array[]) {\n    const msg = ut.concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    ut.aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point: ExtPointType = Point.BASE): ExtPointType {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha512';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { AffinePoint, Group } from './abstract/curve.js';\nimport { CurveFn, ExtPointType, twistedEdwards } from './abstract/edwards.js';\nimport { createHasher, expand_message_xmd, htfBasicOpts } from './abstract/hash-to-curve.js';\nimport { Field, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.js';\nimport { montgomery } from './abstract/montgomery.js';\nimport {\n  bytesToHex,\n  bytesToNumberLE,\n  ensureBytes,\n  equalBytes,\n  Hex,\n  numberToBytesLE,\n} from './abstract/utils.js';\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\n\nconst ED25519_P = BigInt(\n  '57896044618658097711785492504343953926634992332820282019728792003956564819949'\n);\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ED25519_P;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ED25519_P;\n  const v3 = mod(v * v * v, P); // v³\n  const v7 = mod(v3 * v3 * v, P); // v⁷\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx²\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\n// Just in case\nexport const ED25519_TORSION_SUBGROUP = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\nconst Fp = /* @__PURE__ */ (() => Field(ED25519_P, undefined, true))();\n\nconst ed25519Defaults = /* @__PURE__ */ (() =>\n  ({\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: _8n,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/√v\n    uvRatio,\n  }) as const)();\n\n/**\n * ed25519 curve with EdDSA signatures.\n */\nexport const ed25519: CurveFn = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nexport const ed25519ctx = /* @__PURE__ */ (() =>\n  twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n  }))();\nexport const ed25519ph = /* @__PURE__ */ (() =>\n  twistedEdwards(\n    Object.assign({}, ed25519Defaults, {\n      domain: ed25519_domain,\n      prehash: sha512,\n    })\n  ))();\n\nexport const x25519 = /* @__PURE__ */ (() =>\n  montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x: bigint): bigint => {\n      const P = ED25519_P;\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n  }))();\n\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n  const _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n\n  const inv = Fp.invertBatch([xd, yd]); // batch division\n  return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\n\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.ExtendedPoint,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n\nfunction assertRstPoint(other: unknown) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/√(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = ExtPointType;\n\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint implements Group<RistPoint> {\n  static BASE: RistPoint;\n  static ZERO: RistPoint;\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  constructor(private readonly ep: ExtendedPoint) {}\n\n  static fromAffine(ap: AffinePoint<bigint>) {\n    return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n  }\n\n  /**\n   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n   * The hash-to-group operation applies Elligator twice and adds the results.\n   * **Note:** this is one-way map, there is no conversion from point to hash.\n   * https://ristretto.group/formulas/elligator.html\n   * @param hex 64-byte output of a hash function\n   */\n  static hashToCurve(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHash', hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new RistPoint(R1.add(R2));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * https://ristretto.group/formulas/decoding.html\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHex', hex, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error(emsg);\n    return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * https://ristretto.group/formulas/encoding.html\n   */\n  toRawBytes(): Uint8Array {\n    let { ex: x, ey: y, ez: z, et: t } = this.ep;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const u1 = mod(mod(z + y) * mod(z - y)); // 1\n    const u2 = mod(x * y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * t); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(t * zInv, P)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(x * zInv, P)) y = mod(-y); // 9\n    let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  // Compare one point to another.\n  equals(other: RistPoint): boolean {\n    assertRstPoint(other);\n    const { ex: X1, ey: Y1 } = this.ep;\n    const { ex: X2, ey: Y2 } = other.ep;\n    const mod = ed25519.CURVE.Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  add(other: RistPoint): RistPoint {\n    assertRstPoint(other);\n    return new RistPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other: RistPoint): RistPoint {\n    assertRstPoint(other);\n    return new RistPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): RistPoint {\n    return new RistPoint(this.ep.double());\n  }\n\n  negate(): RistPoint {\n    return new RistPoint(this.ep.negate());\n  }\n}\nexport const RistrettoPoint = /* @__PURE__ */ (() => {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n  return RistPoint;\n})();\n\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nexport const hashToRistretto255 = (msg: Uint8Array, options: htfBasicOpts) => {\n  const d = options.DST;\n  const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n  const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n  const P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\nexport const hash_to_ristretto255 = hashToRistretto255; // legacy\n","function anumber(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction ahash(h: Hash) {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\nfunction aexists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out: any, instance: any) {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };\n\nconst assert = {\n  number: anumber,\n  bytes: abytes,\n  hash: ahash,\n  exists: aexists,\n  output: aoutput,\n};\nexport default assert;\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word: number, shift: number) =>\n  (word << shift) | ((word >>> (32 - shift)) >>> 0);\n\nexport const isLE = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n: number) => n : (n: number) => byteSwap(n);\n\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr: Uint32Array) {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","import { aexists, aoutput } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = SHA256_IV[0] | 0;\n  B = SHA256_IV[1] | 0;\n  C = SHA256_IV[2] | 0;\n  D = SHA256_IV[3] | 0;\n  E = SHA256_IV[4] | 0;\n  F = SHA256_IV[5] | 0;\n  G = SHA256_IV[6] | 0;\n  H = SHA256_IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","// @ts-check\n\n/**\n * Base58 characters include numbers 123456789, uppercase ABCDEFGHJKLMNPQRSTUVWXYZ and lowercase abcdefghijkmnopqrstuvwxyz.\n * @typedef {String} base58_chars Base58 characters include numbers 123456789, uppercase ABCDEFGHJKLMNPQRSTUVWXYZ and lowercase abcdefghijkmnopqrstuvwxyz.\n */\nconst base58_chars =\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\nexport default base58_chars;\n","// @ts-check\n\nimport base58_chars from \"./base58_chars.mjs\";\n\n/**\n * Converts a base58 string to the corresponding binary representation.\n * @param { import(\"./base58_chars.mjs\").base58_chars } base58String base58 encoded string.\n * @returns {Uint8Array} Binary representation for the base58 string.\n * @example\n * ```js\n * const bin = base58_to_binary(\"6MRy\")\n * console.log(bin)\n * ```\n * Logged output will be Uint8Array(3) [15, 239, 64].\n */\nfunction base58_to_binary(base58String) {\n  if (!base58String || typeof base58String !== \"string\")\n    throw new Error(`Expected base58 string but got “${base58String}”`);\n  if (base58String.match(/[IOl0]/gmu))\n    throw new Error(\n      `Invalid base58 character “${base58String.match(/[IOl0]/gmu)}”`\n    );\n  const lz = base58String.match(/^1+/gmu);\n  const psz = lz ? lz[0].length : 0;\n  const size =\n    ((base58String.length - psz) * (Math.log(58) / Math.log(256)) + 1) >>> 0;\n\n  return new Uint8Array([\n    ...new Uint8Array(psz),\n    ...base58String\n      .match(/.{1}/gmu)\n      .map((i) => base58_chars.indexOf(i))\n      .reduce((acc, i) => {\n        acc = acc.map((j) => {\n          const x = j * 58 + i;\n          i = x >> 8;\n          return x;\n        });\n        return acc;\n      }, new Uint8Array(size))\n      .reverse()\n      .filter(\n        (\n          (lastValue) => (value) =>\n            // @ts-ignore\n            (lastValue = lastValue || value)\n        )(false)\n      ),\n  ]);\n}\n\nexport default base58_to_binary;\n","// @ts-check\n\nimport base58_chars from \"./base58_chars.mjs\";\n\n/**\n * Generates a mapping between base58 and ascii.\n * @returns {Array<Number>} mapping between ascii and base58.\n */\nconst create_base58_map = () => {\n  const base58M = Array(256).fill(-1);\n  for (let i = 0; i < base58_chars.length; ++i)\n    base58M[base58_chars.charCodeAt(i)] = i;\n\n  return base58M;\n};\n\nexport default create_base58_map;\n","// @ts-check\n\nimport base58_chars from \"./base58_chars.mjs\";\nimport create_base58_map from \"./create_base58_map.mjs\";\n\nconst base58Map = create_base58_map();\n\n/** @typedef {import(\"./base58_chars.mjs\").base58_chars} base58_chars */\n\n/**\n * Converts a Uint8Array into a base58 string.\n * @param {Uint8Array} uint8array Unsigned integer array.\n * @returns { import(\"./base58_chars.mjs\").base58_chars } base58 string representation of the binary array.\n * @example <caption>Usage.</caption>\n * ```js\n * const str = binary_to_base58([15, 239, 64])\n * console.log(str)\n * ```\n * Logged output will be 6MRy.\n */\nfunction binary_to_base58(uint8array) {\n  const result = [];\n\n  for (const byte of uint8array) {\n    let carry = byte;\n    for (let j = 0; j < result.length; ++j) {\n      // @ts-ignore\n      const x = (base58Map[result[j]] << 8) + carry;\n      result[j] = base58_chars.charCodeAt(x % 58);\n      carry = (x / 58) | 0;\n    }\n    while (carry) {\n      result.push(base58_chars.charCodeAt(carry % 58));\n      carry = (carry / 58) | 0;\n    }\n  }\n\n  for (const byte of uint8array)\n    if (byte) break;\n    else result.push(\"1\".charCodeAt(0));\n\n  result.reverse();\n\n  return String.fromCharCode(...result);\n}\n\nexport default binary_to_base58;\n","/*\r\n *  big.js v6.2.2\r\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n *  Copyright (c) 2024 Michael Mclaughlin\r\n *  https://github.com/MikeMcl/big.js/LICENCE.md\r\n */\r\n\r\n\r\n/************************************** EDITABLE DEFAULTS *****************************************/\r\n\r\n\r\n  // The default values below must be integers within the stated ranges.\r\n\r\n  /*\r\n   * The maximum number of decimal places (DP) of the results of operations involving division:\r\n   * div and sqrt, and pow with negative exponents.\r\n   */\r\nvar DP = 20,          // 0 to MAX_DP\r\n\r\n  /*\r\n   * The rounding mode (RM) used when rounding to the above decimal places.\r\n   *\r\n   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n   *  3  Away from zero.                                  (ROUND_UP)\r\n   */\r\n  RM = 1,             // 0, 1, 2 or 3\r\n\r\n  // The maximum value of DP and Big.DP.\r\n  MAX_DP = 1E6,       // 0 to 1000000\r\n\r\n  // The maximum magnitude of the exponent argument to the pow method.\r\n  MAX_POWER = 1E6,    // 1 to 1000000\r\n\r\n  /*\r\n   * The negative exponent (NE) at and beneath which toString returns exponential notation.\r\n   * (JavaScript numbers: -7)\r\n   * -1000000 is the minimum recommended exponent value of a Big.\r\n   */\r\n  NE = -7,            // 0 to -1000000\r\n\r\n  /*\r\n   * The positive exponent (PE) at and above which toString returns exponential notation.\r\n   * (JavaScript numbers: 21)\r\n   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\r\n   */\r\n  PE = 21,            // 0 to 1000000\r\n\r\n  /*\r\n   * When true, an error will be thrown if a primitive number is passed to the Big constructor,\r\n   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\r\n   * primitive number without a loss of precision.\r\n   */\r\n  STRICT = false,     // true or false\r\n\r\n\r\n/**************************************************************************************************/\r\n\r\n\r\n  // Error messages.\r\n  NAME = '[big.js] ',\r\n  INVALID = NAME + 'Invalid ',\r\n  INVALID_DP = INVALID + 'decimal places',\r\n  INVALID_RM = INVALID + 'rounding mode',\r\n  DIV_BY_ZERO = NAME + 'Division by zero',\r\n\r\n  // The shared prototype object.\r\n  P = {},\r\n  UNDEFINED = void 0,\r\n  NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\r\n\r\n\r\n/*\r\n * Create and return a Big constructor.\r\n */\r\nfunction _Big_() {\r\n\r\n  /*\r\n   * The Big constructor and exported function.\r\n   * Create and return a new instance of a Big number object.\r\n   *\r\n   * n {number|string|Big} A numeric value.\r\n   */\r\n  function Big(n) {\r\n    var x = this;\r\n\r\n    // Enable constructor usage without new.\r\n    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\r\n\r\n    // Duplicate.\r\n    if (n instanceof Big) {\r\n      x.s = n.s;\r\n      x.e = n.e;\r\n      x.c = n.c.slice();\r\n    } else {\r\n      if (typeof n !== 'string') {\r\n        if (Big.strict === true && typeof n !== 'bigint') {\r\n          throw TypeError(INVALID + 'value');\r\n        }\r\n\r\n        // Minus zero?\r\n        n = n === 0 && 1 / n < 0 ? '-0' : String(n);\r\n      }\r\n\r\n      parse(x, n);\r\n    }\r\n\r\n    // Retain a reference to this Big constructor.\r\n    // Shadow Big.prototype.constructor which points to Object.\r\n    x.constructor = Big;\r\n  }\r\n\r\n  Big.prototype = P;\r\n  Big.DP = DP;\r\n  Big.RM = RM;\r\n  Big.NE = NE;\r\n  Big.PE = PE;\r\n  Big.strict = STRICT;\r\n  Big.roundDown = 0;\r\n  Big.roundHalfUp = 1;\r\n  Big.roundHalfEven = 2;\r\n  Big.roundUp = 3;\r\n\r\n  return Big;\r\n}\r\n\r\n\r\n/*\r\n * Parse the number or string value passed to a Big constructor.\r\n *\r\n * x {Big} A Big number instance.\r\n * n {number|string} A numeric value.\r\n */\r\nfunction parse(x, n) {\r\n  var e, i, nl;\r\n\r\n  if (!NUMERIC.test(n)) {\r\n    throw Error(INVALID + 'number');\r\n  }\r\n\r\n  // Determine sign.\r\n  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\r\n\r\n  // Decimal point?\r\n  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');\r\n\r\n  // Exponential form?\r\n  if ((i = n.search(/e/i)) > 0) {\r\n\r\n    // Determine exponent.\r\n    if (e < 0) e = i;\r\n    e += +n.slice(i + 1);\r\n    n = n.substring(0, i);\r\n  } else if (e < 0) {\r\n\r\n    // Integer.\r\n    e = n.length;\r\n  }\r\n\r\n  nl = n.length;\r\n\r\n  // Determine leading zeros.\r\n  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\r\n\r\n  if (i == nl) {\r\n\r\n    // Zero.\r\n    x.c = [x.e = 0];\r\n  } else {\r\n\r\n    // Determine trailing zeros.\r\n    for (; nl > 0 && n.charAt(--nl) == '0';);\r\n    x.e = e - i - 1;\r\n    x.c = [];\r\n\r\n    // Convert string to array of digits without leading/trailing zeros.\r\n    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Round Big x to a maximum of sd significant digits using rounding mode rm.\r\n *\r\n * x {Big} The Big to round.\r\n * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\r\n * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n * [more] {boolean} Whether the result of division was truncated.\r\n */\r\nfunction round(x, sd, rm, more) {\r\n  var xc = x.c;\r\n\r\n  if (rm === UNDEFINED) rm = x.constructor.RM;\r\n  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\r\n    throw Error(INVALID_RM);\r\n  }\r\n\r\n  if (sd < 1) {\r\n    more =\r\n      rm === 3 && (more || !!xc[0]) || sd === 0 && (\r\n      rm === 1 && xc[0] >= 5 ||\r\n      rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))\r\n    );\r\n\r\n    xc.length = 1;\r\n\r\n    if (more) {\r\n\r\n      // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n      x.e = x.e - sd + 1;\r\n      xc[0] = 1;\r\n    } else {\r\n\r\n      // Zero.\r\n      xc[0] = x.e = 0;\r\n    }\r\n  } else if (sd < xc.length) {\r\n\r\n    // xc[sd] is the digit after the digit that may be rounded up.\r\n    more =\r\n      rm === 1 && xc[sd] >= 5 ||\r\n      rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&\r\n        (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||\r\n      rm === 3 && (more || !!xc[0]);\r\n\r\n    // Remove any digits after the required precision.\r\n    xc.length = sd;\r\n\r\n    // Round up?\r\n    if (more) {\r\n\r\n      // Rounding up may mean the previous digit has to be rounded up.\r\n      for (; ++xc[--sd] > 9;) {\r\n        xc[sd] = 0;\r\n        if (sd === 0) {\r\n          ++x.e;\r\n          xc.unshift(1);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (sd = xc.length; !xc[--sd];) xc.pop();\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Return a string representing the value of Big x in normal or exponential notation.\r\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\r\n */\r\nfunction stringify(x, doExponential, isNonzero) {\r\n  var e = x.e,\r\n    s = x.c.join(''),\r\n    n = s.length;\r\n\r\n  // Exponential notation?\r\n  if (doExponential) {\r\n    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;\r\n\r\n  // Normal notation.\r\n  } else if (e < 0) {\r\n    for (; ++e;) s = '0' + s;\r\n    s = '0.' + s;\r\n  } else if (e > 0) {\r\n    if (++e > n) {\r\n      for (e -= n; e--;) s += '0';\r\n    } else if (e < n) {\r\n      s = s.slice(0, e) + '.' + s.slice(e);\r\n    }\r\n  } else if (n > 1) {\r\n    s = s.charAt(0) + '.' + s.slice(1);\r\n  }\r\n\r\n  return x.s < 0 && isNonzero ? '-' + s : s;\r\n}\r\n\r\n\r\n// Prototype/instance methods\r\n\r\n\r\n/*\r\n * Return a new Big whose value is the absolute value of this Big.\r\n */\r\nP.abs = function () {\r\n  var x = new this.constructor(this);\r\n  x.s = 1;\r\n  return x;\r\n};\r\n\r\n\r\n/*\r\n * Return 1 if the value of this Big is greater than the value of Big y,\r\n *       -1 if the value of this Big is less than the value of Big y, or\r\n *        0 if they have the same value.\r\n */\r\nP.cmp = function (y) {\r\n  var isneg,\r\n    x = this,\r\n    xc = x.c,\r\n    yc = (y = new x.constructor(y)).c,\r\n    i = x.s,\r\n    j = y.s,\r\n    k = x.e,\r\n    l = y.e;\r\n\r\n  // Either zero?\r\n  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\r\n\r\n  // Signs differ?\r\n  if (i != j) return i;\r\n\r\n  isneg = i < 0;\r\n\r\n  // Compare exponents.\r\n  if (k != l) return k > l ^ isneg ? 1 : -1;\r\n\r\n  j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n  // Compare digit by digit.\r\n  for (i = -1; ++i < j;) {\r\n    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\r\n  }\r\n\r\n  // Compare lengths.\r\n  return k == l ? 0 : k > l ^ isneg ? 1 : -1;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\r\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */\r\nP.div = function (y) {\r\n  var x = this,\r\n    Big = x.constructor,\r\n    a = x.c,                  // dividend\r\n    b = (y = new Big(y)).c,   // divisor\r\n    k = x.s == y.s ? 1 : -1,\r\n    dp = Big.DP;\r\n\r\n  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n    throw Error(INVALID_DP);\r\n  }\r\n\r\n  // Divisor is zero?\r\n  if (!b[0]) {\r\n    throw Error(DIV_BY_ZERO);\r\n  }\r\n\r\n  // Dividend is 0? Return +-0.\r\n  if (!a[0]) {\r\n    y.s = k;\r\n    y.c = [y.e = 0];\r\n    return y;\r\n  }\r\n\r\n  var bl, bt, n, cmp, ri,\r\n    bz = b.slice(),\r\n    ai = bl = b.length,\r\n    al = a.length,\r\n    r = a.slice(0, bl),   // remainder\r\n    rl = r.length,\r\n    q = y,                // quotient\r\n    qc = q.c = [],\r\n    qi = 0,\r\n    p = dp + (q.e = x.e - y.e) + 1;    // precision of the result\r\n\r\n  q.s = k;\r\n  k = p < 0 ? 0 : p;\r\n\r\n  // Create version of divisor with leading zero.\r\n  bz.unshift(0);\r\n\r\n  // Add zeros to make remainder as long as divisor.\r\n  for (; rl++ < bl;) r.push(0);\r\n\r\n  do {\r\n\r\n    // n is how many times the divisor goes into current remainder.\r\n    for (n = 0; n < 10; n++) {\r\n\r\n      // Compare divisor and remainder.\r\n      if (bl != (rl = r.length)) {\r\n        cmp = bl > rl ? 1 : -1;\r\n      } else {\r\n        for (ri = -1, cmp = 0; ++ri < bl;) {\r\n          if (b[ri] != r[ri]) {\r\n            cmp = b[ri] > r[ri] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // If divisor < remainder, subtract divisor from remainder.\r\n      if (cmp < 0) {\r\n\r\n        // Remainder can't be more than 1 digit longer than divisor.\r\n        // Equalise lengths using divisor with extra leading zero?\r\n        for (bt = rl == bl ? b : bz; rl;) {\r\n          if (r[--rl] < bt[rl]) {\r\n            ri = rl;\r\n            for (; ri && !r[--ri];) r[ri] = 9;\r\n            --r[ri];\r\n            r[rl] += 10;\r\n          }\r\n          r[rl] -= bt[rl];\r\n        }\r\n\r\n        for (; !r[0];) r.shift();\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Add the digit n to the result array.\r\n    qc[qi++] = cmp ? n : ++n;\r\n\r\n    // Update the remainder.\r\n    if (r[0] && cmp) r[rl] = a[ai] || 0;\r\n    else r = [a[ai]];\r\n\r\n  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);\r\n\r\n  // Leading zero? Do not remove if result is simply zero (qi == 1).\r\n  if (!qc[0] && qi != 1) {\r\n\r\n    // There can't be more than one zero.\r\n    qc.shift();\r\n    q.e--;\r\n    p--;\r\n  }\r\n\r\n  // Round?\r\n  if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\r\n\r\n  return q;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\r\n */\r\nP.eq = function (y) {\r\n  return this.cmp(y) === 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\r\n * false.\r\n */\r\nP.gt = function (y) {\r\n  return this.cmp(y) > 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\r\n * return false.\r\n */\r\nP.gte = function (y) {\r\n  return this.cmp(y) > -1;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\r\n */\r\nP.lt = function (y) {\r\n  return this.cmp(y) < 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\r\n * return false.\r\n */\r\nP.lte = function (y) {\r\n  return this.cmp(y) < 1;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Big whose value is the value of this Big minus the value of Big y.\r\n */\r\nP.minus = P.sub = function (y) {\r\n  var i, j, t, xlty,\r\n    x = this,\r\n    Big = x.constructor,\r\n    a = x.s,\r\n    b = (y = new Big(y)).s;\r\n\r\n  // Signs differ?\r\n  if (a != b) {\r\n    y.s = -b;\r\n    return x.plus(y);\r\n  }\r\n\r\n  var xc = x.c.slice(),\r\n    xe = x.e,\r\n    yc = y.c,\r\n    ye = y.e;\r\n\r\n  // Either zero?\r\n  if (!xc[0] || !yc[0]) {\r\n    if (yc[0]) {\r\n      y.s = -b;\r\n    } else if (xc[0]) {\r\n      y = new Big(x);\r\n    } else {\r\n      y.s = 1;\r\n    }\r\n    return y;\r\n  }\r\n\r\n  // Determine which is the bigger number. Prepend zeros to equalise exponents.\r\n  if (a = xe - ye) {\r\n\r\n    if (xlty = a < 0) {\r\n      a = -a;\r\n      t = xc;\r\n    } else {\r\n      ye = xe;\r\n      t = yc;\r\n    }\r\n\r\n    t.reverse();\r\n    for (b = a; b--;) t.push(0);\r\n    t.reverse();\r\n  } else {\r\n\r\n    // Exponents equal. Check digit by digit.\r\n    j = ((xlty = xc.length < yc.length) ? xc : yc).length;\r\n\r\n    for (a = b = 0; b < j; b++) {\r\n      if (xc[b] != yc[b]) {\r\n        xlty = xc[b] < yc[b];\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // x < y? Point xc to the array of the bigger number.\r\n  if (xlty) {\r\n    t = xc;\r\n    xc = yc;\r\n    yc = t;\r\n    y.s = -y.s;\r\n  }\r\n\r\n  /*\r\n   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\r\n   * needs to start at yc.length.\r\n   */\r\n  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;\r\n\r\n  // Subtract yc from xc.\r\n  for (b = i; j > a;) {\r\n    if (xc[--j] < yc[j]) {\r\n      for (i = j; i && !xc[--i];) xc[i] = 9;\r\n      --xc[i];\r\n      xc[j] += 10;\r\n    }\r\n\r\n    xc[j] -= yc[j];\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  for (; xc[--b] === 0;) xc.pop();\r\n\r\n  // Remove leading zeros and adjust exponent accordingly.\r\n  for (; xc[0] === 0;) {\r\n    xc.shift();\r\n    --ye;\r\n  }\r\n\r\n  if (!xc[0]) {\r\n\r\n    // n - n = +0\r\n    y.s = 1;\r\n\r\n    // Result must be zero.\r\n    xc = [ye = 0];\r\n  }\r\n\r\n  y.c = xc;\r\n  y.e = ye;\r\n\r\n  return y;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\r\n */\r\nP.mod = function (y) {\r\n  var ygtx,\r\n    x = this,\r\n    Big = x.constructor,\r\n    a = x.s,\r\n    b = (y = new Big(y)).s;\r\n\r\n  if (!y.c[0]) {\r\n    throw Error(DIV_BY_ZERO);\r\n  }\r\n\r\n  x.s = y.s = 1;\r\n  ygtx = y.cmp(x) == 1;\r\n  x.s = a;\r\n  y.s = b;\r\n\r\n  if (ygtx) return new Big(x);\r\n\r\n  a = Big.DP;\r\n  b = Big.RM;\r\n  Big.DP = Big.RM = 0;\r\n  x = x.div(y);\r\n  Big.DP = a;\r\n  Big.RM = b;\r\n\r\n  return this.minus(x.times(y));\r\n};\r\n\r\n\r\n/*\r\n * Return a new Big whose value is the value of this Big negated.\r\n */\r\nP.neg = function () {\r\n  var x = new this.constructor(this);\r\n  x.s = -x.s;\r\n  return x;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Big whose value is the value of this Big plus the value of Big y.\r\n */\r\nP.plus = P.add = function (y) {\r\n  var e, k, t,\r\n    x = this,\r\n    Big = x.constructor;\r\n\r\n  y = new Big(y);\r\n\r\n  // Signs differ?\r\n  if (x.s != y.s) {\r\n    y.s = -y.s;\r\n    return x.minus(y);\r\n  }\r\n\r\n  var xe = x.e,\r\n    xc = x.c,\r\n    ye = y.e,\r\n    yc = y.c;\r\n\r\n  // Either zero?\r\n  if (!xc[0] || !yc[0]) {\r\n    if (!yc[0]) {\r\n      if (xc[0]) {\r\n        y = new Big(x);\r\n      } else {\r\n        y.s = x.s;\r\n      }\r\n    }\r\n    return y;\r\n  }\r\n\r\n  xc = xc.slice();\r\n\r\n  // Prepend zeros to equalise exponents.\r\n  // Note: reverse faster than unshifts.\r\n  if (e = xe - ye) {\r\n    if (e > 0) {\r\n      ye = xe;\r\n      t = yc;\r\n    } else {\r\n      e = -e;\r\n      t = xc;\r\n    }\r\n\r\n    t.reverse();\r\n    for (; e--;) t.push(0);\r\n    t.reverse();\r\n  }\r\n\r\n  // Point xc to the longer array.\r\n  if (xc.length - yc.length < 0) {\r\n    t = yc;\r\n    yc = xc;\r\n    xc = t;\r\n  }\r\n\r\n  e = yc.length;\r\n\r\n  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\r\n  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\r\n\r\n  // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n\r\n  if (k) {\r\n    xc.unshift(k);\r\n    ++ye;\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  for (e = xc.length; xc[--e] === 0;) xc.pop();\r\n\r\n  y.c = xc;\r\n  y.e = ye;\r\n\r\n  return y;\r\n};\r\n\r\n\r\n/*\r\n * Return a Big whose value is the value of this Big raised to the power n.\r\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\r\n * mode Big.RM.\r\n *\r\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n */\r\nP.pow = function (n) {\r\n  var x = this,\r\n    one = new x.constructor('1'),\r\n    y = one,\r\n    isneg = n < 0;\r\n\r\n  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\r\n    throw Error(INVALID + 'exponent');\r\n  }\r\n\r\n  if (isneg) n = -n;\r\n\r\n  for (;;) {\r\n    if (n & 1) y = y.times(x);\r\n    n >>= 1;\r\n    if (!n) break;\r\n    x = x.times(x);\r\n  }\r\n\r\n  return isneg ? one.div(y) : y;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\r\n * significant digits using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */\r\nP.prec = function (sd, rm) {\r\n  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n    throw Error(INVALID + 'precision');\r\n  }\r\n  return round(new this.constructor(this), sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\r\n * using rounding mode rm, or Big.RM if rm is not specified.\r\n * If dp is negative, round to an integer which is a multiple of 10**-dp.\r\n * If dp is not specified, round to 0 decimal places.\r\n *\r\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */\r\nP.round = function (dp, rm) {\r\n  if (dp === UNDEFINED) dp = 0;\r\n  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\r\n    throw Error(INVALID_DP);\r\n  }\r\n  return round(new this.constructor(this), dp + this.e + 1, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\r\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */\r\nP.sqrt = function () {\r\n  var r, c, t,\r\n    x = this,\r\n    Big = x.constructor,\r\n    s = x.s,\r\n    e = x.e,\r\n    half = new Big('0.5');\r\n\r\n  // Zero?\r\n  if (!x.c[0]) return new Big(x);\r\n\r\n  // Negative?\r\n  if (s < 0) {\r\n    throw Error(NAME + 'No square root');\r\n  }\r\n\r\n  // Estimate.\r\n  s = Math.sqrt(+stringify(x, true, true));\r\n\r\n  // Math.sqrt underflow/overflow?\r\n  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\r\n  if (s === 0 || s === 1 / 0) {\r\n    c = x.c.join('');\r\n    if (!(c.length + e & 1)) c += '0';\r\n    s = Math.sqrt(c);\r\n    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\r\n    r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);\r\n  } else {\r\n    r = new Big(s + '');\r\n  }\r\n\r\n  e = r.e + (Big.DP += 4);\r\n\r\n  // Newton-Raphson iteration.\r\n  do {\r\n    t = r;\r\n    r = half.times(t.plus(x.div(t)));\r\n  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));\r\n\r\n  return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Big whose value is the value of this Big times the value of Big y.\r\n */\r\nP.times = P.mul = function (y) {\r\n  var c,\r\n    x = this,\r\n    Big = x.constructor,\r\n    xc = x.c,\r\n    yc = (y = new Big(y)).c,\r\n    a = xc.length,\r\n    b = yc.length,\r\n    i = x.e,\r\n    j = y.e;\r\n\r\n  // Determine sign of result.\r\n  y.s = x.s == y.s ? 1 : -1;\r\n\r\n  // Return signed 0 if either 0.\r\n  if (!xc[0] || !yc[0]) {\r\n    y.c = [y.e = 0];\r\n    return y;\r\n  }\r\n\r\n  // Initialise exponent of result as x.e + y.e.\r\n  y.e = i + j;\r\n\r\n  // If array xc has fewer digits than yc, swap xc and yc, and lengths.\r\n  if (a < b) {\r\n    c = xc;\r\n    xc = yc;\r\n    yc = c;\r\n    j = a;\r\n    a = b;\r\n    b = j;\r\n  }\r\n\r\n  // Initialise coefficient array of result with zeros.\r\n  for (c = new Array(j = a + b); j--;) c[j] = 0;\r\n\r\n  // Multiply.\r\n\r\n  // i is initially xc.length.\r\n  for (i = b; i--;) {\r\n    b = 0;\r\n\r\n    // a is yc.length.\r\n    for (j = a + i; j > i;) {\r\n\r\n      // Current sum of products at this digit position, plus carry.\r\n      b = c[j] + yc[i] * xc[j - i - 1] + b;\r\n      c[j--] = b % 10;\r\n\r\n      // carry\r\n      b = b / 10 | 0;\r\n    }\r\n\r\n    c[j] = b;\r\n  }\r\n\r\n  // Increment result exponent if there is a final carry, otherwise remove leading zero.\r\n  if (b) ++y.e;\r\n  else c.shift();\r\n\r\n  // Remove trailing zeros.\r\n  for (i = c.length; !c[--i];) c.pop();\r\n  y.c = c;\r\n\r\n  return y;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Big in exponential notation rounded to dp fixed\r\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */\r\nP.toExponential = function (dp, rm) {\r\n  var x = this,\r\n    n = x.c[0];\r\n\r\n  if (dp !== UNDEFINED) {\r\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n      throw Error(INVALID_DP);\r\n    }\r\n    x = round(new x.constructor(x), ++dp, rm);\r\n    for (; x.c.length < dp;) x.c.push(0);\r\n  }\r\n\r\n  return stringify(x, true, !!n);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Big in normal notation rounded to dp fixed\r\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n */\r\nP.toFixed = function (dp, rm) {\r\n  var x = this,\r\n    n = x.c[0];\r\n\r\n  if (dp !== UNDEFINED) {\r\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n      throw Error(INVALID_DP);\r\n    }\r\n    x = round(new x.constructor(x), dp + x.e + 1, rm);\r\n\r\n    // x.e may have changed if the value is rounded up.\r\n    for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);\r\n  }\r\n\r\n  return stringify(x, false, !!n);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Omit the sign for negative zero.\r\n */\r\nP[Symbol.for('nodejs.util.inspect.custom')] = P.toJSON = P.toString = function () {\r\n  var x = this,\r\n    Big = x.constructor;\r\n  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\r\n};\r\n\r\n\r\n/*\r\n * Return the value of this Big as a primitve number.\r\n */\r\nP.toNumber = function () {\r\n  var n = +stringify(this, true, true);\r\n  if (this.constructor.strict === true && !this.eq(n.toString())) {\r\n    throw Error(NAME + 'Imprecise conversion');\r\n  }\r\n  return n;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Big rounded to sd significant digits using\r\n * rounding mode rm, or Big.RM if rm is not specified.\r\n * Use exponential notation if sd is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */\r\nP.toPrecision = function (sd, rm) {\r\n  var x = this,\r\n    Big = x.constructor,\r\n    n = x.c[0];\r\n\r\n  if (sd !== UNDEFINED) {\r\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n      throw Error(INVALID + 'precision');\r\n    }\r\n    x = round(new Big(x), sd, rm);\r\n    for (; x.c.length < sd;) x.c.push(0);\r\n  }\r\n\r\n  return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Include the sign for negative zero.\r\n */\r\nP.valueOf = function () {\r\n  var x = this,\r\n    Big = x.constructor;\r\n  if (Big.strict === true) {\r\n    throw Error(NAME + 'valueOf disallowed');\r\n  }\r\n  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\r\n};\r\n\r\n\r\n// Export\r\n\r\n\r\nexport var Big = _Big_();\r\n\r\n/// <reference types=\"https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts\" />\r\nexport default Big;\r\n","/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.7.7';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\nconst b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));\nconst _mkUriSafe = (src) => src\n    .replace(/=/g, '').replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_');\nconst _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)\n            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = typeof btoa === 'function' ? (bin) => btoa(bin)\n    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a) => Buffer.from(u8a).toString('base64')\n    : (u8a) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    }\n    else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s) => _fromUint8Array(_TE.encode(s))\n        : (s) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2)));\n        default:\n            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1)));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\nconst btou = (b) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc))\n        throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, bin = '', r1, r2;\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = typeof atob === 'function' ? (asc) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')\n        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a) => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a) => _TD.decode(_toUint8Array(a))\n        : (a) => btou(_atob(a));\nconst _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src) => {\n    if (typeof src !== 'string')\n        return false;\n    const s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add('fromBase64', function () { return decode(this); });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n    _add('toBase64URI', function () { return encode(this, true); });\n    _add('toBase64URL', function () { return encode(this, true); });\n    _add('toUint8Array', function () { return toUint8Array(this); });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n    _add('toBase64URI', function () { return fromUint8Array(this, true); });\n    _add('toBase64URL', function () { return fromUint8Array(this, true); });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins\n};\n// makecjs:CUT //\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill };\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\n// and finally,\nexport { gBase64 as Base64 };\n","import {\n  binary_to_base58 as toBase58,\n  base58_to_binary as fromBase58,\n} from \"base58-js\";\nimport Big from \"big.js\";\nimport { encode, decode } from 'js-base64';\n\nexport { toBase58, fromBase58 };\n\nconst LsPrefix = \"__fastnear_\";\n\nexport function toBase64(data) {\n  if (typeof data === 'string') {\n    return encode(data);\n  } else {\n    const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);\n    const str = String.fromCharCode(...bytes);\n    return encode(str);\n  }\n}\n\nexport function fromBase64(str) {\n  const binaryString = decode(str);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}\n\nexport function convertUnit(s: string | TemplateStringsArray, ...args: any[]): string {\n  // Reconstruct raw string from template literal\n  if (Array.isArray(s)) {\n    s = s.reduce((acc, part, i) => {\n      return acc + (args[i - 1] ?? \"\") + part;\n    });\n  }\n  // Convert from `100 NEAR` into yoctoNear\n  if (typeof s == \"string\") {\n    const match = s.match(/([0-9.,_]+)\\s*([a-zA-Z]+)?/);\n    if (match) {\n      const amount = match[1].replace(/[_,]/g, \"\");\n      const unitPart = match[2];\n      if (unitPart) {\n        switch (unitPart.toLowerCase()) {\n          case \"near\":\n            return Big(amount).mul(Big(10).pow(24)).toFixed(0);\n          case \"tgas\":\n            return Big(amount).mul(Big(10).pow(12)).toFixed(0);\n          case \"ggas\":\n            return Big(amount).mul(Big(10).pow(9)).toFixed(0);\n          case \"gas\":\n          case \"yoctonear\":\n            return Big(amount).toFixed(0);\n          default:\n            throw new Error(`Unknown unit: ${unitPart}`);\n        }\n      } else {\n        return Big(amount).toFixed(0);\n      }\n    }\n  }\n  return Big(s).toFixed(0);\n}\n\nexport function lsSet(key, value) {\n  if (value === null || value === undefined) {\n    localStorage.removeItem(LsPrefix + key);\n  } else {\n    localStorage.setItem(LsPrefix + key, JSON.stringify(value));\n  }\n}\n\nexport function lsGet(key) {\n  const value = localStorage.getItem(LsPrefix + key);\n  return tryParseJson(value, null);\n}\n\nexport function deepCopy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function tryParseJson(...args) {\n  try {\n    return JSON.parse(args[0]);\n  } catch {\n    if (args.length > 1) {\n      return args[1];\n    }\n    return args[0];\n  }\n}\n\nexport function parseJsonFromBytes(bytes: Uint8Array) {\n  try {\n    const decoder = new TextDecoder();\n    return JSON.parse(\n      decoder.decode(bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes))\n    );\n  } catch (e) {\n    try {\n      return bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);\n    } catch (e) {\n      return bytes;\n    }\n  }\n}\n\nexport function canSignWithLAK(actions) {\n  return (\n    actions.length === 1 &&\n    actions[0].type === \"FunctionCall\" &&\n    Big(actions[0]?.deposit ?? \"0\").eq(0)\n  );\n}\n","import { ed25519 } from \"@noble/curves/ed25519\";\nimport { sha256 } from \"@noble/hashes/sha2\";\nimport { fromBase58, toBase58 } from \"./misc.js\";\n\nexport { sha256 };\n\nexport const keyFromString = (key) =>\n  fromBase58(\n    key.includes(\":\")\n      ? (() => {\n          const [curve, keyPart] = key.split(\":\");\n          if (curve !== \"ed25519\") {\n            throw new Error(`Unsupported curve: ${curve}`);\n          }\n          return keyPart;\n        })()\n      : key,\n  );\n\nexport const keyToString = (key) => `ed25519:${toBase58(key)}`;\n\nexport function publicKeyFromPrivate(privateKey) {\n  privateKey = keyFromString(privateKey).slice(0, 32);\n  const publicKey = ed25519.getPublicKey(privateKey);\n  return keyToString(publicKey);\n}\n\nexport function privateKeyFromRandom() {\n  const privateKey = crypto.getRandomValues(new Uint8Array(64));\n  return keyToString(privateKey);\n}\n\nexport function signHash(hash, privateKey) {\n  privateKey = keyFromString(privateKey).slice(0, 32);\n  const signature = ed25519.sign(fromBase58(hash), privateKey);\n  return toBase58(signature);\n}\n\nexport function signBytes(bytes, privateKey) {\n  const hash = sha256(bytes);\n  return signHash(toBase58(hash), privateKey);\n}\n","export var integers = ['u8', 'u16', 'u32', 'u64', 'u128', 'i8', 'i16', 'i32', 'i64', 'i128', 'f32', 'f64'];\n","var EncodeBuffer = /** @class */ (function () {\n    function EncodeBuffer() {\n        this.offset = 0;\n        this.buffer_size = 256;\n        this.buffer = new ArrayBuffer(this.buffer_size);\n        this.view = new DataView(this.buffer);\n    }\n    EncodeBuffer.prototype.resize_if_necessary = function (needed_space) {\n        if (this.buffer_size - this.offset < needed_space) {\n            this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);\n            var new_buffer = new ArrayBuffer(this.buffer_size);\n            new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));\n            this.buffer = new_buffer;\n            this.view = new DataView(new_buffer);\n        }\n    };\n    EncodeBuffer.prototype.get_used_buffer = function () {\n        return new Uint8Array(this.buffer).slice(0, this.offset);\n    };\n    EncodeBuffer.prototype.store_value = function (value, type) {\n        var bSize = type.substring(1);\n        var size = parseInt(bSize) / 8;\n        this.resize_if_necessary(size);\n        var toCall = type[0] === 'f' ? \"setFloat\".concat(bSize) : type[0] === 'i' ? \"setInt\".concat(bSize) : \"setUint\".concat(bSize);\n        this.view[toCall](this.offset, value, true);\n        this.offset += size;\n    };\n    EncodeBuffer.prototype.store_bytes = function (from) {\n        this.resize_if_necessary(from.length);\n        new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);\n        this.offset += from.length;\n    };\n    return EncodeBuffer;\n}());\nexport { EncodeBuffer };\nvar DecodeBuffer = /** @class */ (function () {\n    function DecodeBuffer(buf) {\n        this.offset = 0;\n        this.buffer_size = buf.length;\n        this.buffer = new ArrayBuffer(buf.length);\n        new Uint8Array(this.buffer).set(buf);\n        this.view = new DataView(this.buffer);\n    }\n    DecodeBuffer.prototype.assert_enough_buffer = function (size) {\n        if (this.offset + size > this.buffer.byteLength) {\n            throw new Error('Error in schema, the buffer is smaller than expected');\n        }\n    };\n    DecodeBuffer.prototype.consume_value = function (type) {\n        var bSize = type.substring(1);\n        var size = parseInt(bSize) / 8;\n        this.assert_enough_buffer(size);\n        var toCall = type[0] === 'f' ? \"getFloat\".concat(bSize) : type[0] === 'i' ? \"getInt\".concat(bSize) : \"getUint\".concat(bSize);\n        var ret = this.view[toCall](this.offset, true);\n        this.offset += size;\n        return ret;\n    };\n    DecodeBuffer.prototype.consume_bytes = function (size) {\n        this.assert_enough_buffer(size);\n        var ret = this.buffer.slice(this.offset, this.offset + size);\n        this.offset += size;\n        return ret;\n    };\n    return DecodeBuffer;\n}());\nexport { DecodeBuffer };\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { integers } from './types.js';\nexport function isArrayLike(value) {\n    // source: https://stackoverflow.com/questions/24048547/checking-if-an-object-is-array-like\n    return (Array.isArray(value) ||\n        (!!value &&\n            typeof value === 'object' &&\n            'length' in value &&\n            typeof (value.length) === 'number' &&\n            (value.length === 0 ||\n                (value.length > 0 &&\n                    (value.length - 1) in value))));\n}\nexport function expect_type(value, type, fieldPath) {\n    if (typeof (value) !== type) {\n        throw new Error(\"Expected \".concat(type, \" not \").concat(typeof (value), \"(\").concat(value, \") at \").concat(fieldPath.join('.')));\n    }\n}\nexport function expect_bigint(value, fieldPath) {\n    var basicType = ['number', 'string', 'bigint', 'boolean'].includes(typeof (value));\n    var strObject = typeof (value) === 'object' && value !== null && 'toString' in value;\n    if (!basicType && !strObject) {\n        throw new Error(\"Expected bigint, number, boolean or string not \".concat(typeof (value), \"(\").concat(value, \") at \").concat(fieldPath.join('.')));\n    }\n}\nexport function expect_same_size(length, expected, fieldPath) {\n    if (length !== expected) {\n        throw new Error(\"Array length \".concat(length, \" does not match schema length \").concat(expected, \" at \").concat(fieldPath.join('.')));\n    }\n}\nexport function expect_enum(value, fieldPath) {\n    if (typeof (value) !== 'object' || value === null) {\n        throw new Error(\"Expected object not \".concat(typeof (value), \"(\").concat(value, \") at \").concat(fieldPath.join('.')));\n    }\n}\n// Validate Schema\nvar VALID_STRING_TYPES = integers.concat(['bool', 'string']);\nvar VALID_OBJECT_KEYS = ['option', 'enum', 'array', 'set', 'map', 'struct'];\nvar ErrorSchema = /** @class */ (function (_super) {\n    __extends(ErrorSchema, _super);\n    function ErrorSchema(schema, expected) {\n        var message = \"Invalid schema: \".concat(JSON.stringify(schema), \" expected \").concat(expected);\n        return _super.call(this, message) || this;\n    }\n    return ErrorSchema;\n}(Error));\nexport { ErrorSchema };\nexport function validate_schema(schema) {\n    if (typeof (schema) === 'string' && VALID_STRING_TYPES.includes(schema)) {\n        return;\n    }\n    if (schema && typeof (schema) === 'object') {\n        var keys = Object.keys(schema);\n        if (keys.length === 1 && VALID_OBJECT_KEYS.includes(keys[0])) {\n            var key = keys[0];\n            if (key === 'option')\n                return validate_schema(schema[key]);\n            if (key === 'enum')\n                return validate_enum_schema(schema[key]);\n            if (key === 'array')\n                return validate_array_schema(schema[key]);\n            if (key === 'set')\n                return validate_schema(schema[key]);\n            if (key === 'map')\n                return validate_map_schema(schema[key]);\n            if (key === 'struct')\n                return validate_struct_schema(schema[key]);\n        }\n    }\n    throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(', ') + ' or ' + VALID_STRING_TYPES.join(', '));\n}\nfunction validate_enum_schema(schema) {\n    if (!Array.isArray(schema))\n        throw new ErrorSchema(schema, 'Array');\n    for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {\n        var sch = schema_1[_i];\n        if (typeof sch !== 'object' || !('struct' in sch)) {\n            throw new Error('Missing \"struct\" key in enum schema');\n        }\n        if (typeof sch.struct !== 'object' || Object.keys(sch.struct).length !== 1) {\n            throw new Error('The \"struct\" in each enum must have a single key');\n        }\n        validate_schema({ struct: sch.struct });\n    }\n}\nfunction validate_array_schema(schema) {\n    if (typeof schema !== 'object')\n        throw new ErrorSchema(schema, '{ type, len? }');\n    if (schema.len && typeof schema.len !== 'number') {\n        throw new Error(\"Invalid schema: \".concat(schema));\n    }\n    if ('type' in schema)\n        return validate_schema(schema.type);\n    throw new ErrorSchema(schema, '{ type, len? }');\n}\nfunction validate_map_schema(schema) {\n    if (typeof schema === 'object' && 'key' in schema && 'value' in schema) {\n        validate_schema(schema.key);\n        validate_schema(schema.value);\n    }\n    else {\n        throw new ErrorSchema(schema, '{ key, value }');\n    }\n}\nfunction validate_struct_schema(schema) {\n    if (typeof schema !== 'object')\n        throw new ErrorSchema(schema, 'object');\n    for (var key in schema) {\n        validate_schema(schema[key]);\n    }\n}\n","import { integers } from './types.js';\nimport { EncodeBuffer } from './buffer.js';\nimport * as utils from './utils.js';\nvar BorshSerializer = /** @class */ (function () {\n    function BorshSerializer(checkTypes) {\n        this.encoded = new EncodeBuffer();\n        this.fieldPath = ['value'];\n        this.checkTypes = checkTypes;\n    }\n    BorshSerializer.prototype.encode = function (value, schema) {\n        this.encode_value(value, schema);\n        return this.encoded.get_used_buffer();\n    };\n    BorshSerializer.prototype.encode_value = function (value, schema) {\n        if (typeof schema === 'string') {\n            if (integers.includes(schema))\n                return this.encode_integer(value, schema);\n            if (schema === 'string')\n                return this.encode_string(value);\n            if (schema === 'bool')\n                return this.encode_boolean(value);\n        }\n        if (typeof schema === 'object') {\n            if ('option' in schema)\n                return this.encode_option(value, schema);\n            if ('enum' in schema)\n                return this.encode_enum(value, schema);\n            if ('array' in schema)\n                return this.encode_array(value, schema);\n            if ('set' in schema)\n                return this.encode_set(value, schema);\n            if ('map' in schema)\n                return this.encode_map(value, schema);\n            if ('struct' in schema)\n                return this.encode_struct(value, schema);\n        }\n    };\n    BorshSerializer.prototype.encode_integer = function (value, schema) {\n        var size = parseInt(schema.substring(1));\n        if (size <= 32 || schema == 'f64') {\n            this.checkTypes && utils.expect_type(value, 'number', this.fieldPath);\n            this.encoded.store_value(value, schema);\n        }\n        else {\n            this.checkTypes && utils.expect_bigint(value, this.fieldPath);\n            this.encode_bigint(BigInt(value), size);\n        }\n    };\n    BorshSerializer.prototype.encode_bigint = function (value, size) {\n        var buffer_len = size / 8;\n        var buffer = new Uint8Array(buffer_len);\n        for (var i = 0; i < buffer_len; i++) {\n            buffer[i] = Number(value & BigInt(0xff));\n            value = value >> BigInt(8);\n        }\n        this.encoded.store_bytes(new Uint8Array(buffer));\n    };\n    BorshSerializer.prototype.encode_string = function (value) {\n        this.checkTypes && utils.expect_type(value, 'string', this.fieldPath);\n        var _value = value;\n        // encode to utf8 bytes without using TextEncoder\n        var utf8Bytes = [];\n        for (var i = 0; i < _value.length; i++) {\n            var charCode = _value.charCodeAt(i);\n            if (charCode < 0x80) {\n                utf8Bytes.push(charCode);\n            }\n            else if (charCode < 0x800) {\n                utf8Bytes.push(0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f));\n            }\n            else if (charCode < 0xd800 || charCode >= 0xe000) {\n                utf8Bytes.push(0xe0 | (charCode >> 12), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));\n            }\n            else {\n                i++;\n                charCode = 0x10000 + (((charCode & 0x3ff) << 10) | (_value.charCodeAt(i) & 0x3ff));\n                utf8Bytes.push(0xf0 | (charCode >> 18), 0x80 | ((charCode >> 12) & 0x3f), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));\n            }\n        }\n        // 4 bytes for length + string bytes\n        this.encoded.store_value(utf8Bytes.length, 'u32');\n        this.encoded.store_bytes(new Uint8Array(utf8Bytes));\n    };\n    BorshSerializer.prototype.encode_boolean = function (value) {\n        this.checkTypes && utils.expect_type(value, 'boolean', this.fieldPath);\n        this.encoded.store_value(value ? 1 : 0, 'u8');\n    };\n    BorshSerializer.prototype.encode_option = function (value, schema) {\n        if (value === null || value === undefined) {\n            this.encoded.store_value(0, 'u8');\n        }\n        else {\n            this.encoded.store_value(1, 'u8');\n            this.encode_value(value, schema.option);\n        }\n    };\n    BorshSerializer.prototype.encode_enum = function (value, schema) {\n        this.checkTypes && utils.expect_enum(value, this.fieldPath);\n        var valueKey = Object.keys(value)[0];\n        for (var i = 0; i < schema[\"enum\"].length; i++) {\n            var valueSchema = schema[\"enum\"][i];\n            if (valueKey === Object.keys(valueSchema.struct)[0]) {\n                this.encoded.store_value(i, 'u8');\n                return this.encode_struct(value, valueSchema);\n            }\n        }\n        throw new Error(\"Enum key (\".concat(valueKey, \") not found in enum schema: \").concat(JSON.stringify(schema), \" at \").concat(this.fieldPath.join('.')));\n    };\n    BorshSerializer.prototype.encode_array = function (value, schema) {\n        if (utils.isArrayLike(value))\n            return this.encode_arraylike(value, schema);\n        if (value instanceof ArrayBuffer)\n            return this.encode_buffer(value, schema);\n        throw new Error(\"Expected Array-like not \".concat(typeof (value), \"(\").concat(value, \") at \").concat(this.fieldPath.join('.')));\n    };\n    BorshSerializer.prototype.encode_arraylike = function (value, schema) {\n        if (schema.array.len) {\n            utils.expect_same_size(value.length, schema.array.len, this.fieldPath);\n        }\n        else {\n            // 4 bytes for length\n            this.encoded.store_value(value.length, 'u32');\n        }\n        // array values\n        for (var i = 0; i < value.length; i++) {\n            this.encode_value(value[i], schema.array.type);\n        }\n    };\n    BorshSerializer.prototype.encode_buffer = function (value, schema) {\n        if (schema.array.len) {\n            utils.expect_same_size(value.byteLength, schema.array.len, this.fieldPath);\n        }\n        else {\n            // 4 bytes for length\n            this.encoded.store_value(value.byteLength, 'u32');\n        }\n        // array values\n        this.encoded.store_bytes(new Uint8Array(value));\n    };\n    BorshSerializer.prototype.encode_set = function (value, schema) {\n        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);\n        var isSet = value instanceof Set;\n        var values = isSet ? Array.from(value.values()) : Object.values(value);\n        // 4 bytes for length\n        this.encoded.store_value(values.length, 'u32');\n        // set values\n        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n            var value_1 = values_1[_i];\n            this.encode_value(value_1, schema.set);\n        }\n    };\n    BorshSerializer.prototype.encode_map = function (value, schema) {\n        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);\n        var isMap = value instanceof Map;\n        var keys = isMap ? Array.from(value.keys()) : Object.keys(value);\n        // 4 bytes for length\n        this.encoded.store_value(keys.length, 'u32');\n        // store key/values\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            this.encode_value(key, schema.map.key);\n            this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);\n        }\n    };\n    BorshSerializer.prototype.encode_struct = function (value, schema) {\n        this.checkTypes && utils.expect_type(value, 'object', this.fieldPath);\n        for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {\n            var key = _a[_i];\n            this.fieldPath.push(key);\n            this.encode_value(value[key], schema.struct[key]);\n            this.fieldPath.pop();\n        }\n    };\n    return BorshSerializer;\n}());\nexport { BorshSerializer };\n","import { integers } from './types.js';\nimport { DecodeBuffer } from './buffer.js';\nvar BorshDeserializer = /** @class */ (function () {\n    function BorshDeserializer(bufferArray) {\n        this.buffer = new DecodeBuffer(bufferArray);\n    }\n    BorshDeserializer.prototype.decode = function (schema) {\n        return this.decode_value(schema);\n    };\n    BorshDeserializer.prototype.decode_value = function (schema) {\n        if (typeof schema === 'string') {\n            if (integers.includes(schema))\n                return this.decode_integer(schema);\n            if (schema === 'string')\n                return this.decode_string();\n            if (schema === 'bool')\n                return this.decode_boolean();\n        }\n        if (typeof schema === 'object') {\n            if ('option' in schema)\n                return this.decode_option(schema);\n            if ('enum' in schema)\n                return this.decode_enum(schema);\n            if ('array' in schema)\n                return this.decode_array(schema);\n            if ('set' in schema)\n                return this.decode_set(schema);\n            if ('map' in schema)\n                return this.decode_map(schema);\n            if ('struct' in schema)\n                return this.decode_struct(schema);\n        }\n        throw new Error(\"Unsupported type: \".concat(schema));\n    };\n    BorshDeserializer.prototype.decode_integer = function (schema) {\n        var size = parseInt(schema.substring(1));\n        if (size <= 32 || schema == 'f64') {\n            return this.buffer.consume_value(schema);\n        }\n        return this.decode_bigint(size, schema.startsWith('i'));\n    };\n    BorshDeserializer.prototype.decode_bigint = function (size, signed) {\n        if (signed === void 0) { signed = false; }\n        var buffer_len = size / 8;\n        var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));\n        var bits = buffer.reduceRight(function (r, x) { return r + x.toString(16).padStart(2, '0'); }, '');\n        if (signed && buffer[buffer_len - 1]) {\n            return BigInt.asIntN(size, BigInt(\"0x\".concat(bits)));\n        }\n        return BigInt(\"0x\".concat(bits));\n    };\n    BorshDeserializer.prototype.decode_string = function () {\n        var len = this.decode_integer('u32');\n        var buffer = new Uint8Array(this.buffer.consume_bytes(len));\n        // decode utf-8 string without using TextDecoder\n        // first get all bytes to single byte code points\n        var codePoints = [];\n        for (var i = 0; i < len; ++i) {\n            var byte = buffer[i];\n            if (byte < 0x80) {\n                codePoints.push(byte);\n            }\n            else if (byte < 0xE0) {\n                codePoints.push(((byte & 0x1F) << 6) | (buffer[++i] & 0x3F));\n            }\n            else if (byte < 0xF0) {\n                codePoints.push(((byte & 0x0F) << 12) | ((buffer[++i] & 0x3F) << 6) | (buffer[++i] & 0x3F));\n            }\n            else {\n                var codePoint = ((byte & 0x07) << 18) | ((buffer[++i] & 0x3F) << 12) | ((buffer[++i] & 0x3F) << 6) | (buffer[++i] & 0x3F);\n                codePoints.push(codePoint);\n            }\n        }\n        // then decode code points to utf-8\n        return String.fromCodePoint.apply(String, codePoints);\n    };\n    BorshDeserializer.prototype.decode_boolean = function () {\n        return this.buffer.consume_value('u8') > 0;\n    };\n    BorshDeserializer.prototype.decode_option = function (schema) {\n        var option = this.buffer.consume_value('u8');\n        if (option === 1) {\n            return this.decode_value(schema.option);\n        }\n        if (option !== 0) {\n            throw new Error(\"Invalid option \".concat(option));\n        }\n        return null;\n    };\n    BorshDeserializer.prototype.decode_enum = function (schema) {\n        var _a;\n        var valueIndex = this.buffer.consume_value('u8');\n        if (valueIndex > schema[\"enum\"].length) {\n            throw new Error(\"Enum option \".concat(valueIndex, \" is not available\"));\n        }\n        var struct = schema[\"enum\"][valueIndex].struct;\n        var key = Object.keys(struct)[0];\n        return _a = {}, _a[key] = this.decode_value(struct[key]), _a;\n    };\n    BorshDeserializer.prototype.decode_array = function (schema) {\n        var result = [];\n        var len = schema.array.len ? schema.array.len : this.decode_integer('u32');\n        for (var i = 0; i < len; ++i) {\n            result.push(this.decode_value(schema.array.type));\n        }\n        return result;\n    };\n    BorshDeserializer.prototype.decode_set = function (schema) {\n        var len = this.decode_integer('u32');\n        var result = new Set();\n        for (var i = 0; i < len; ++i) {\n            result.add(this.decode_value(schema.set));\n        }\n        return result;\n    };\n    BorshDeserializer.prototype.decode_map = function (schema) {\n        var len = this.decode_integer('u32');\n        var result = new Map();\n        for (var i = 0; i < len; ++i) {\n            var key = this.decode_value(schema.map.key);\n            var value = this.decode_value(schema.map.value);\n            result.set(key, value);\n        }\n        return result;\n    };\n    BorshDeserializer.prototype.decode_struct = function (schema) {\n        var result = {};\n        for (var key in schema.struct) {\n            result[key] = this.decode_value(schema.struct[key]);\n        }\n        return result;\n    };\n    return BorshDeserializer;\n}());\nexport { BorshDeserializer };\n","import { BorshSerializer } from './serialize.js';\nimport { BorshDeserializer } from './deserialize.js';\nimport * as utils from './utils.js';\nexport function serialize(schema, value, validate) {\n    if (validate === void 0) { validate = true; }\n    if (validate)\n        utils.validate_schema(schema);\n    var serializer = new BorshSerializer(validate);\n    return serializer.encode(value, schema);\n}\nexport function deserialize(schema, buffer, validate) {\n    if (validate === void 0) { validate = true; }\n    if (validate)\n        utils.validate_schema(schema);\n    var deserializer = new BorshDeserializer(buffer);\n    return deserializer.decode(schema);\n}\n","export const getBorshSchema = (() => {\n  class BorshSchema {\n    Ed25519Signature = {\n      struct: {\n        data: { array: { type: \"u8\", len: 64 } },\n      },\n    };\n    Secp256k1Signature = {\n      struct: {\n        data: { array: { type: \"u8\", len: 65 } },\n      },\n    };\n    Signature = {\n      enum: [\n        { struct: { ed25519Signature: this.Ed25519Signature } },\n        { struct: { secp256k1Signature: this.Secp256k1Signature } },\n      ],\n    };\n    Ed25519Data = {\n      struct: {\n        data: { array: { type: \"u8\", len: 32 } },\n      },\n    };\n    Secp256k1Data = {\n      struct: {\n        data: { array: { type: \"u8\", len: 64 } },\n      },\n    };\n    PublicKey = {\n      enum: [\n        { struct: { ed25519Key: this.Ed25519Data } },\n        { struct: { secp256k1Key: this.Secp256k1Data } },\n      ],\n    };\n    FunctionCallPermission = {\n      struct: {\n        allowance: { option: \"u128\" },\n        receiverId: \"string\",\n        methodNames: { array: { type: \"string\" } },\n      },\n    };\n    FullAccessPermission = {\n      struct: {},\n    };\n    AccessKeyPermission = {\n      enum: [\n        { struct: { functionCall: this.FunctionCallPermission } },\n        { struct: { fullAccess: this.FullAccessPermission } },\n      ],\n    };\n    AccessKey = {\n      struct: {\n        nonce: \"u64\",\n        permission: this.AccessKeyPermission,\n      },\n    };\n    CreateAccount = {\n      struct: {},\n    };\n    DeployContract = {\n      struct: {\n        code: { array: { type: \"u8\" } },\n      },\n    };\n    FunctionCall = {\n      struct: {\n        methodName: \"string\",\n        args: { array: { type: \"u8\" } },\n        gas: \"u64\",\n        deposit: \"u128\",\n      },\n    };\n    Transfer = {\n      struct: {\n        deposit: \"u128\",\n      },\n    };\n    Stake = {\n      struct: {\n        stake: \"u128\",\n        publicKey: this.PublicKey,\n      },\n    };\n    AddKey = {\n      struct: {\n        publicKey: this.PublicKey,\n        accessKey: this.AccessKey,\n      },\n    };\n    DeleteKey = {\n      struct: {\n        publicKey: this.PublicKey,\n      },\n    };\n    DeleteAccount = {\n      struct: {\n        beneficiaryId: \"string\",\n      },\n    };\n    ClassicAction = {\n      enum: [\n        { struct: { createAccount: this.CreateAccount } },\n        { struct: { deployContract: this.DeployContract } },\n        { struct: { functionCall: this.FunctionCall } },\n        { struct: { transfer: this.Transfer } },\n        { struct: { stake: this.Stake } },\n        { struct: { addKey: this.AddKey } },\n        { struct: { deleteKey: this.DeleteKey } },\n        { struct: { deleteAccount: this.DeleteAccount } },\n      ],\n    };\n    DelegateAction = {\n      struct: {\n        senderId: \"string\",\n        receiverId: \"string\",\n        actions: { array: { type: this.ClassicAction } },\n        nonce: \"u64\",\n        maxBlockHeight: \"u64\",\n        publicKey: this.PublicKey,\n      },\n    };\n    SignedDelegate = {\n      struct: {\n        delegateAction: this.DelegateAction,\n        signature: this.Signature,\n      },\n    };\n    Action = {\n      enum: [\n        { struct: { createAccount: this.CreateAccount } },\n        { struct: { deployContract: this.DeployContract } },\n        { struct: { functionCall: this.FunctionCall } },\n        { struct: { transfer: this.Transfer } },\n        { struct: { stake: this.Stake } },\n        { struct: { addKey: this.AddKey } },\n        { struct: { deleteKey: this.DeleteKey } },\n        { struct: { deleteAccount: this.DeleteAccount } },\n        { struct: { signedDelegate: this.SignedDelegate } },\n      ],\n    };\n    Transaction = {\n      struct: {\n        signerId: \"string\",\n        publicKey: this.PublicKey,\n        nonce: \"u64\",\n        receiverId: \"string\",\n        blockHash: { array: { type: \"u8\", len: 32 } },\n        actions: { array: { type: this.Action } },\n      },\n    };\n    SignedTransaction = {\n      struct: {\n        transaction: this.Transaction,\n        signature: this.Signature,\n      },\n    };\n  }\n  return new BorshSchema();\n})();\n","import { serialize as borshSerialize } from \"borsh\";\nimport { keyFromString } from \"./crypto.js\";\nimport { fromBase58, fromBase64 } from \"./misc.js\";\nimport { getBorshSchema } from \"@fastnear/borsh-schema\";\n\nexport function mapTransaction(jsonTransaction) {\n  return {\n    signerId: jsonTransaction.signerId,\n    publicKey: {\n      ed25519Key: {\n        data: keyFromString(jsonTransaction.publicKey),\n      },\n    },\n    nonce: BigInt(jsonTransaction.nonce),\n    receiverId: jsonTransaction.receiverId,\n    blockHash: fromBase58(jsonTransaction.blockHash),\n    actions: jsonTransaction.actions.map(mapAction),\n  };\n}\n\nexport function serializeTransaction(jsonTransaction) {\n  const transaction = mapTransaction(jsonTransaction);\n  return borshSerialize(SCHEMA.Transaction, transaction);\n}\n\nexport function serializeSignedTransaction(jsonTransaction, signature) {\n  const signedTransaction = {\n    transaction: mapTransaction(jsonTransaction),\n    signature: {\n      ed25519Signature: {\n        data: fromBase58(signature),\n      },\n    },\n  };\n  return borshSerialize(SCHEMA.SignedTransaction, signedTransaction);\n}\n\nexport function mapAction(action) {\n  switch (action.type) {\n    case \"CreateAccount\": {\n      return {\n        createAccount: {},\n      };\n    }\n    case \"DeployContract\": {\n      return {\n        deployContract: {\n          code: fromBase64(action.codeBase64),\n        },\n      };\n    }\n    case \"FunctionCall\": {\n      return {\n        functionCall: {\n          methodName: action.methodName,\n          args: action.argsBase64\n            ? fromBase64(action.argsBase64)\n            : new TextEncoder().encode(JSON.stringify(action.args)),\n          gas: BigInt(action.gas),\n          deposit: BigInt(action.deposit),\n        },\n      };\n    }\n    case \"Transfer\": {\n      return {\n        transfer: {\n          deposit: BigInt(action.deposit),\n        },\n      };\n    }\n    case \"Stake\": {\n      return {\n        stake: {\n          stake: BigInt(action.stake),\n          publicKey: {\n            ed25519Key: {\n              data: keyFromString(action.publicKey),\n            },\n          },\n        },\n      };\n    }\n    case \"AddKey\": {\n      return {\n        addKey: {\n          publicKey: {\n            ed25519Key: {\n              data: keyFromString(action.publicKey),\n            },\n          },\n          accessKey: {\n            nonce: BigInt(action.accessKey.nonce),\n            permission:\n              action.accessKey.permission === \"FullAccess\"\n                ? { fullAccess: {} }\n                : {\n                    functionCall: {\n                      allowance: action.accessKey.allowance\n                        ? BigInt(action.accessKey.allowance)\n                        : null,\n                      receiverId: action.accessKey.receiverId,\n                      methodNames: action.accessKey.methodNames,\n                    },\n                  },\n          },\n        },\n      };\n    }\n    case \"DeleteKey\": {\n      return {\n        deleteKey: {\n          publicKey: {\n            ed25519Key: {\n              data: keyFromString(action.publicKey),\n            },\n          },\n        },\n      };\n    }\n    case \"DeleteAccount\": {\n      return {\n        deleteAccount: {\n          beneficiaryId: action.beneficiaryId,\n        },\n      };\n    }\n    case \"SignedDelegate\": {\n      return {\n        signedDelegate: {\n          delegateAction: mapAction(action.delegateAction),\n          signature: {\n            ed25519Signature: fromBase58(action.signature),\n          },\n        },\n      };\n    }\n    default: {\n      throw new Error(\"Not implemented action: \" + action.type);\n    }\n  }\n}\n\nexport const SCHEMA = getBorshSchema;\n"],"mappings":"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","names":["src_exports","crypto","crypto","_32n","isBytes","abytes","abytes","isBytes","abytes","isBytes","_0n","_1n","_2n","P","Fp","bitLen","_0n","_1n","_0n","_1n","P","wbits","_0n","_1n","_2n","_8n","Fp","randomBytes","uvRatio","adjustScalarBytes","G","A","B","F","C","D","E","H","X3","Y3","T3","Z3","cofactor","_0n","_1n","_2n","_3n","_5n","_8n","P","pow","_8n","isBytes","abytes","aexists","aoutput","abytes","createView","utf8ToBytes","toBytes","abytes","Hash","wrapConstructor","toBytes","setBigUint64","_32n","HashMD","Hash","createView","aexists","toBytes","aoutput","HashMD","wrapConstructor","Big","e","EncodeBuffer","DecodeBuffer","d","b","ErrorSchema","BorshSerializer","BorshDeserializer"]}