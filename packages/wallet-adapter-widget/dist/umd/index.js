/* ⋈ 🏃🏻💨 FastNEAR Wallet Adapter Widget - https://github.com/fastnear */
var nearWalletAdapterWidget = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod3) => function __require2() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));
  var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

  // ../../node_modules/@near-js/crypto/lib/commonjs/constants.cjs
  var require_constants = __commonJS({
    "../../node_modules/@near-js/crypto/lib/commonjs/constants.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeySize = exports.KeyType = void 0;
      var KeyType3;
      (function(KeyType4) {
        KeyType4[KeyType4["ED25519"] = 0] = "ED25519";
        KeyType4[KeyType4["SECP256K1"] = 1] = "SECP256K1";
      })(KeyType3 || (exports.KeyType = KeyType3 = {}));
      exports.KeySize = {
        SECRET_KEY: 32,
        ED25519_PUBLIC_KEY: 32,
        SECP256k1_PUBLIC_KEY: 64
      };
    }
  });

  // ../../node_modules/@near-js/crypto/lib/commonjs/key_pair_base.cjs
  var require_key_pair_base = __commonJS({
    "../../node_modules/@near-js/crypto/lib/commonjs/key_pair_base.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyPairBase = void 0;
      var KeyPairBase3 = class {
      };
      exports.KeyPairBase = KeyPairBase3;
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/constants.cjs
  var require_constants2 = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/constants.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DEFAULT_FUNCTION_CALL_GAS = void 0;
      exports.DEFAULT_FUNCTION_CALL_GAS = 30000000000000n;
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/errors/error_messages.json
  var require_error_messages = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/errors/error_messages.json"(exports, module) {
      module.exports = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed",
        ShardCongested: "Shard {{shard_id}} rejected the transaction due to congestion level {{congestion_level}}, try again later",
        ShardStuck: "Shard {{shard_id}} rejected the transaction because it missed {{missed_chunks}} chunks and needs to recover before accepting new transactions, try again later"
      };
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/errors/errors.cjs
  var require_errors = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/errors/errors.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorMessages = void 0;
      var error_messages_json_1 = __importDefault(require_error_messages());
      exports.ErrorMessages = error_messages_json_1.default;
    }
  });

  // ../../node_modules/@near-js/types/lib/commonjs/assignable.cjs
  var require_assignable = __commonJS({
    "../../node_modules/@near-js/types/lib/commonjs/assignable.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Assignable = void 0;
      var Assignable2 = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports.Assignable = Assignable2;
    }
  });

  // ../../node_modules/@near-js/types/lib/commonjs/enum.cjs
  var require_enum = __commonJS({
    "../../node_modules/@near-js/types/lib/commonjs/enum.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Enum = void 0;
      var Enum3 = class {
        constructor(properties) {
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports.Enum = Enum3;
    }
  });

  // ../../node_modules/@near-js/types/lib/commonjs/errors.cjs
  var require_errors2 = __commonJS({
    "../../node_modules/@near-js/types/lib/commonjs/errors.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorContext = exports.TypedError = exports.ArgumentTypeError = exports.PositionalArgsError = void 0;
      var PositionalArgsError2 = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      exports.PositionalArgsError = PositionalArgsError2;
      var ArgumentTypeError2 = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      exports.ArgumentTypeError = ArgumentTypeError2;
      var TypedError3 = class extends Error {
        type;
        context;
        constructor(message, type, context) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context;
        }
      };
      exports.TypedError = TypedError3;
      var ErrorContext2 = class {
        transactionHash;
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
      exports.ErrorContext = ErrorContext2;
    }
  });

  // ../../node_modules/@near-js/types/lib/commonjs/provider/light_client.cjs
  var require_light_client = __commonJS({
    "../../node_modules/@near-js/types/lib/commonjs/provider/light_client.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IdType = void 0;
      var IdType3;
      (function(IdType4) {
        IdType4["Transaction"] = "transaction";
        IdType4["Receipt"] = "receipt";
      })(IdType3 || (exports.IdType = IdType3 = {}));
    }
  });

  // ../../node_modules/@near-js/types/lib/commonjs/provider/response.cjs
  var require_response = __commonJS({
    "../../node_modules/@near-js/types/lib/commonjs/provider/response.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FinalExecutionStatusBasic = exports.ExecutionStatusBasic = void 0;
      var ExecutionStatusBasic3;
      (function(ExecutionStatusBasic4) {
        ExecutionStatusBasic4["Unknown"] = "Unknown";
        ExecutionStatusBasic4["Pending"] = "Pending";
        ExecutionStatusBasic4["Failure"] = "Failure";
      })(ExecutionStatusBasic3 || (exports.ExecutionStatusBasic = ExecutionStatusBasic3 = {}));
      var FinalExecutionStatusBasic3;
      (function(FinalExecutionStatusBasic4) {
        FinalExecutionStatusBasic4["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic4["Started"] = "Started";
        FinalExecutionStatusBasic4["Failure"] = "Failure";
      })(FinalExecutionStatusBasic3 || (exports.FinalExecutionStatusBasic = FinalExecutionStatusBasic3 = {}));
    }
  });

  // ../../node_modules/@near-js/types/lib/commonjs/provider/index.cjs
  var require_provider = __commonJS({
    "../../node_modules/@near-js/types/lib/commonjs/provider/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FinalExecutionStatusBasic = exports.ExecutionStatusBasic = exports.IdType = void 0;
      var light_client_1 = require_light_client();
      Object.defineProperty(exports, "IdType", { enumerable: true, get: function() {
        return light_client_1.IdType;
      } });
      var response_1 = require_response();
      Object.defineProperty(exports, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // ../../node_modules/@near-js/types/lib/commonjs/index.cjs
  var require_commonjs = __commonJS({
    "../../node_modules/@near-js/types/lib/commonjs/index.cjs"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_assignable(), exports);
      __exportStar(require_enum(), exports);
      __exportStar(require_errors2(), exports);
      __exportStar(require_provider(), exports);
    }
  });

  // ../../node_modules/mustache/mustache.js
  var require_mustache = __commonJS({
    "../../node_modules/mustache/mustache.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.Mustache = factory());
      })(exports, function() {
        "use strict";
        var objectToString2 = Object.prototype.toString;
        var isArray2 = Array.isArray || function isArrayPolyfill2(object) {
          return objectToString2.call(object) === "[object Array]";
        };
        function isFunction2(object) {
          return typeof object === "function";
        }
        function typeStr2(obj) {
          return isArray2(obj) ? "array" : typeof obj;
        }
        function escapeRegExp2(string) {
          return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        }
        function hasProperty2(obj, propName) {
          return obj != null && typeof obj === "object" && propName in obj;
        }
        function primitiveHasOwnProperty2(primitive, propName) {
          return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
        }
        var regExpTest2 = RegExp.prototype.test;
        function testRegExp2(re, string) {
          return regExpTest2.call(re, string);
        }
        var nonSpaceRe2 = /\S/;
        function isWhitespace2(string) {
          return !testRegExp2(nonSpaceRe2, string);
        }
        var entityMap2 = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;",
          "/": "&#x2F;",
          "`": "&#x60;",
          "=": "&#x3D;"
        };
        function escapeHtml2(string) {
          return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
            return entityMap2[s];
          });
        }
        var whiteRe2 = /\s*/;
        var spaceRe2 = /\s+/;
        var equalsRe2 = /\s*=/;
        var curlyRe2 = /\s*\}/;
        var tagRe2 = /#|\^|\/|>|\{|&|=|!/;
        function parseTemplate2(template, tags) {
          if (!template)
            return [];
          var lineHasNonSpace = false;
          var sections = [];
          var tokens = [];
          var spaces = [];
          var hasTag = false;
          var nonSpace = false;
          var indentation = "";
          var tagIndex = 0;
          function stripSpace() {
            if (hasTag && !nonSpace) {
              while (spaces.length)
                delete tokens[spaces.pop()];
            } else {
              spaces = [];
            }
            hasTag = false;
            nonSpace = false;
          }
          var openingTagRe, closingTagRe, closingCurlyRe;
          function compileTags(tagsToCompile) {
            if (typeof tagsToCompile === "string")
              tagsToCompile = tagsToCompile.split(spaceRe2, 2);
            if (!isArray2(tagsToCompile) || tagsToCompile.length !== 2)
              throw new Error("Invalid tags: " + tagsToCompile);
            openingTagRe = new RegExp(escapeRegExp2(tagsToCompile[0]) + "\\s*");
            closingTagRe = new RegExp("\\s*" + escapeRegExp2(tagsToCompile[1]));
            closingCurlyRe = new RegExp("\\s*" + escapeRegExp2("}" + tagsToCompile[1]));
          }
          compileTags(tags || mustache2.tags);
          var scanner = new Scanner2(template);
          var start, type, value, chr, token, openSection;
          while (!scanner.eos()) {
            start = scanner.pos;
            value = scanner.scanUntil(openingTagRe);
            if (value) {
              for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
                chr = value.charAt(i);
                if (isWhitespace2(chr)) {
                  spaces.push(tokens.length);
                  indentation += chr;
                } else {
                  nonSpace = true;
                  lineHasNonSpace = true;
                  indentation += " ";
                }
                tokens.push(["text", chr, start, start + 1]);
                start += 1;
                if (chr === "\n") {
                  stripSpace();
                  indentation = "";
                  tagIndex = 0;
                  lineHasNonSpace = false;
                }
              }
            }
            if (!scanner.scan(openingTagRe))
              break;
            hasTag = true;
            type = scanner.scan(tagRe2) || "name";
            scanner.scan(whiteRe2);
            if (type === "=") {
              value = scanner.scanUntil(equalsRe2);
              scanner.scan(equalsRe2);
              scanner.scanUntil(closingTagRe);
            } else if (type === "{") {
              value = scanner.scanUntil(closingCurlyRe);
              scanner.scan(curlyRe2);
              scanner.scanUntil(closingTagRe);
              type = "&";
            } else {
              value = scanner.scanUntil(closingTagRe);
            }
            if (!scanner.scan(closingTagRe))
              throw new Error("Unclosed tag at " + scanner.pos);
            if (type == ">") {
              token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
            } else {
              token = [type, value, start, scanner.pos];
            }
            tagIndex++;
            tokens.push(token);
            if (type === "#" || type === "^") {
              sections.push(token);
            } else if (type === "/") {
              openSection = sections.pop();
              if (!openSection)
                throw new Error('Unopened section "' + value + '" at ' + start);
              if (openSection[1] !== value)
                throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
            } else if (type === "name" || type === "{" || type === "&") {
              nonSpace = true;
            } else if (type === "=") {
              compileTags(value);
            }
          }
          stripSpace();
          openSection = sections.pop();
          if (openSection)
            throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
          return nestTokens2(squashTokens2(tokens));
        }
        function squashTokens2(tokens) {
          var squashedTokens = [];
          var token, lastToken;
          for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            token = tokens[i];
            if (token) {
              if (token[0] === "text" && lastToken && lastToken[0] === "text") {
                lastToken[1] += token[1];
                lastToken[3] = token[3];
              } else {
                squashedTokens.push(token);
                lastToken = token;
              }
            }
          }
          return squashedTokens;
        }
        function nestTokens2(tokens) {
          var nestedTokens = [];
          var collector = nestedTokens;
          var sections = [];
          var token, section;
          for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            token = tokens[i];
            switch (token[0]) {
              case "#":
              case "^":
                collector.push(token);
                sections.push(token);
                collector = token[4] = [];
                break;
              case "/":
                section = sections.pop();
                section[5] = token[2];
                collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
                break;
              default:
                collector.push(token);
            }
          }
          return nestedTokens;
        }
        function Scanner2(string) {
          this.string = string;
          this.tail = string;
          this.pos = 0;
        }
        Scanner2.prototype.eos = function eos2() {
          return this.tail === "";
        };
        Scanner2.prototype.scan = function scan2(re) {
          var match = this.tail.match(re);
          if (!match || match.index !== 0)
            return "";
          var string = match[0];
          this.tail = this.tail.substring(string.length);
          this.pos += string.length;
          return string;
        };
        Scanner2.prototype.scanUntil = function scanUntil2(re) {
          var index = this.tail.search(re), match;
          switch (index) {
            case -1:
              match = this.tail;
              this.tail = "";
              break;
            case 0:
              match = "";
              break;
            default:
              match = this.tail.substring(0, index);
              this.tail = this.tail.substring(index);
          }
          this.pos += match.length;
          return match;
        };
        function Context2(view, parentContext) {
          this.view = view;
          this.cache = { ".": this.view };
          this.parent = parentContext;
        }
        Context2.prototype.push = function push2(view) {
          return new Context2(view, this);
        };
        Context2.prototype.lookup = function lookup2(name) {
          var cache = this.cache;
          var value;
          if (cache.hasOwnProperty(name)) {
            value = cache[name];
          } else {
            var context = this, intermediateValue, names, index, lookupHit = false;
            while (context) {
              if (name.indexOf(".") > 0) {
                intermediateValue = context.view;
                names = name.split(".");
                index = 0;
                while (intermediateValue != null && index < names.length) {
                  if (index === names.length - 1)
                    lookupHit = hasProperty2(intermediateValue, names[index]) || primitiveHasOwnProperty2(intermediateValue, names[index]);
                  intermediateValue = intermediateValue[names[index++]];
                }
              } else {
                intermediateValue = context.view[name];
                lookupHit = hasProperty2(context.view, name);
              }
              if (lookupHit) {
                value = intermediateValue;
                break;
              }
              context = context.parent;
            }
            cache[name] = value;
          }
          if (isFunction2(value))
            value = value.call(this.view);
          return value;
        };
        function Writer2() {
          this.templateCache = {
            _cache: {},
            set: function set(key, value) {
              this._cache[key] = value;
            },
            get: function get(key) {
              return this._cache[key];
            },
            clear: function clear() {
              this._cache = {};
            }
          };
        }
        Writer2.prototype.clearCache = function clearCache3() {
          if (typeof this.templateCache !== "undefined") {
            this.templateCache.clear();
          }
        };
        Writer2.prototype.parse = function parse3(template, tags) {
          var cache = this.templateCache;
          var cacheKey = template + ":" + (tags || mustache2.tags).join(":");
          var isCacheEnabled = typeof cache !== "undefined";
          var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
          if (tokens == void 0) {
            tokens = parseTemplate2(template, tags);
            isCacheEnabled && cache.set(cacheKey, tokens);
          }
          return tokens;
        };
        Writer2.prototype.render = function render3(template, view, partials, tags) {
          var tokens = this.parse(template, tags);
          var context = view instanceof Context2 ? view : new Context2(view, void 0);
          return this.renderTokens(tokens, context, partials, template, tags);
        };
        Writer2.prototype.renderTokens = function renderTokens2(tokens, context, partials, originalTemplate, tags) {
          var buffer = "";
          var token, symbol, value;
          for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            value = void 0;
            token = tokens[i];
            symbol = token[0];
            if (symbol === "#") value = this.renderSection(token, context, partials, originalTemplate);
            else if (symbol === "^") value = this.renderInverted(token, context, partials, originalTemplate);
            else if (symbol === ">") value = this.renderPartial(token, context, partials, tags);
            else if (symbol === "&") value = this.unescapedValue(token, context);
            else if (symbol === "name") value = this.escapedValue(token, context);
            else if (symbol === "text") value = this.rawValue(token);
            if (value !== void 0)
              buffer += value;
          }
          return buffer;
        };
        Writer2.prototype.renderSection = function renderSection2(token, context, partials, originalTemplate) {
          var self2 = this;
          var buffer = "";
          var value = context.lookup(token[1]);
          function subRender(template) {
            return self2.render(template, context, partials);
          }
          if (!value) return;
          if (isArray2(value)) {
            for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
              buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
            }
          } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
            buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
          } else if (isFunction2(value)) {
            if (typeof originalTemplate !== "string")
              throw new Error("Cannot use higher-order sections without the original template");
            value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
            if (value != null)
              buffer += value;
          } else {
            buffer += this.renderTokens(token[4], context, partials, originalTemplate);
          }
          return buffer;
        };
        Writer2.prototype.renderInverted = function renderInverted2(token, context, partials, originalTemplate) {
          var value = context.lookup(token[1]);
          if (!value || isArray2(value) && value.length === 0)
            return this.renderTokens(token[4], context, partials, originalTemplate);
        };
        Writer2.prototype.indentPartial = function indentPartial2(partial, indentation, lineHasNonSpace) {
          var filteredIndentation = indentation.replace(/[^ \t]/g, "");
          var partialByNl = partial.split("\n");
          for (var i = 0; i < partialByNl.length; i++) {
            if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
              partialByNl[i] = filteredIndentation + partialByNl[i];
            }
          }
          return partialByNl.join("\n");
        };
        Writer2.prototype.renderPartial = function renderPartial2(token, context, partials, tags) {
          if (!partials) return;
          var value = isFunction2(partials) ? partials(token[1]) : partials[token[1]];
          if (value != null) {
            var lineHasNonSpace = token[6];
            var tagIndex = token[5];
            var indentation = token[4];
            var indentedValue = value;
            if (tagIndex == 0 && indentation) {
              indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
            }
            return this.renderTokens(this.parse(indentedValue, tags), context, partials, indentedValue);
          }
        };
        Writer2.prototype.unescapedValue = function unescapedValue2(token, context) {
          var value = context.lookup(token[1]);
          if (value != null)
            return value;
        };
        Writer2.prototype.escapedValue = function escapedValue2(token, context) {
          var value = context.lookup(token[1]);
          if (value != null)
            return mustache2.escape(value);
        };
        Writer2.prototype.rawValue = function rawValue2(token) {
          return token[1];
        };
        var mustache2 = {
          name: "mustache.js",
          version: "4.0.0",
          tags: ["{{", "}}"],
          clearCache: void 0,
          escape: void 0,
          parse: void 0,
          render: void 0,
          Scanner: void 0,
          Context: void 0,
          Writer: void 0,
          /**
           * Allows a user to override the default caching strategy, by providing an
           * object with set, get and clear methods. This can also be used to disable
           * the cache by setting it to the literal `undefined`.
           */
          set templateCache(cache) {
            defaultWriter2.templateCache = cache;
          },
          /**
           * Gets the default or overridden caching object from the default writer.
           */
          get templateCache() {
            return defaultWriter2.templateCache;
          }
        };
        var defaultWriter2 = new Writer2();
        mustache2.clearCache = function clearCache3() {
          return defaultWriter2.clearCache();
        };
        mustache2.parse = function parse3(template, tags) {
          return defaultWriter2.parse(template, tags);
        };
        mustache2.render = function render3(template, view, partials, tags) {
          if (typeof template !== "string") {
            throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr2(template) + '" was given as the first argument for mustache#render(template, view, partials)');
          }
          return defaultWriter2.render(template, view, partials, tags);
        };
        mustache2.escape = escapeHtml2;
        mustache2.Scanner = Scanner2;
        mustache2.Context = Context2;
        mustache2.Writer = Writer2;
        return mustache2;
      });
    }
  });

  // ../../node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "../../node_modules/safe-buffer/index.js"(exports, module) {
      var buffer = __require("buffer");
      var Buffer2 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer2.prototype);
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // ../../node_modules/bs58/node_modules/base-x/index.js
  var require_base_x = __commonJS({
    "../../node_modules/bs58/node_modules/base-x/index.js"(exports, module) {
      var Buffer2 = require_safe_buffer().Buffer;
      module.exports = function base2(ALPHABET2) {
        var ALPHABET_MAP = {};
        var BASE = ALPHABET2.length;
        var LEADER = ALPHABET2.charAt(0);
        for (var z = 0; z < ALPHABET2.length; z++) {
          var x = ALPHABET2.charAt(z);
          if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous");
          ALPHABET_MAP[x] = z;
        }
        function encode(source) {
          if (source.length === 0) return "";
          var digits = [0];
          for (var i = 0; i < source.length; ++i) {
            for (var j = 0, carry = source[i]; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % BASE;
              carry = carry / BASE | 0;
            }
            while (carry > 0) {
              digits.push(carry % BASE);
              carry = carry / BASE | 0;
            }
          }
          var string = "";
          for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) string += ALPHABET2[0];
          for (var q = digits.length - 1; q >= 0; --q) string += ALPHABET2[digits[q]];
          return string;
        }
        function decodeUnsafe(string) {
          if (string.length === 0) return Buffer2.allocUnsafe(0);
          var bytes2 = [0];
          for (var i = 0; i < string.length; i++) {
            var value = ALPHABET_MAP[string[i]];
            if (value === void 0) return;
            for (var j = 0, carry = value; j < bytes2.length; ++j) {
              carry += bytes2[j] * BASE;
              bytes2[j] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes2.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
            bytes2.push(0);
          }
          return Buffer2.from(bytes2.reverse());
        }
        function decode(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) return buffer;
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode,
          decodeUnsafe,
          decode
        };
      };
    }
  });

  // ../../node_modules/bs58/index.js
  var require_bs58 = __commonJS({
    "../../node_modules/bs58/index.js"(exports, module) {
      var basex = require_base_x();
      var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module.exports = basex(ALPHABET2);
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/format.cjs
  var require_format = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/format.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.baseDecode = exports.baseEncode = exports.parseNearAmount = exports.formatNearAmount = exports.NEAR_NOMINATION = exports.NEAR_NOMINATION_EXP = void 0;
      var bs58_1 = __importDefault(require_bs58());
      exports.NEAR_NOMINATION_EXP = 24;
      exports.NEAR_NOMINATION = 10n ** BigInt(exports.NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS3 = [];
      var BN103 = 10n;
      for (let i = 0, offset = 5n; i < exports.NEAR_NOMINATION_EXP; i++, offset = offset * BN103) {
        ROUNDING_OFFSETS3[i] = offset;
      }
      function formatNearAmount3(balance, fracDigits = exports.NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== exports.NEAR_NOMINATION_EXP) {
          const roundingExp = exports.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS3[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports.NEAR_NOMINATION_EXP).padStart(exports.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes2(`${formatWithCommas2(wholeStr)}.${fractionStr}`);
      }
      exports.formatNearAmount = formatNearAmount3;
      function parseNearAmount2(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount2(amt);
        const split3 = amt.split(".");
        const wholePart = split3[0];
        const fracPart = split3[1] || "";
        if (split3.length > 2 || fracPart.length > exports.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes2(wholePart + fracPart.padEnd(exports.NEAR_NOMINATION_EXP, "0"));
      }
      exports.parseNearAmount = parseNearAmount2;
      function cleanupAmount2(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes2(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes2(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas2(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode3(value) {
        if (typeof value === "string") {
          const bytes2 = [];
          for (let c = 0; c < value.length; c++) {
            bytes2.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes2);
        }
        return bs58_1.default.encode(value);
      }
      exports.baseEncode = baseEncode3;
      function baseDecode3(value) {
        return new Uint8Array(bs58_1.default.decode(value));
      }
      exports.baseDecode = baseDecode3;
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/errors/rpc_error_schema.json
  var require_rpc_error_schema = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/errors/rpc_error_schema.json"(exports, module) {
      module.exports = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              forwarded_buffered_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_buffered_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded",
              "StorageError",
              "ShardCongested",
              "ShardStuck"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptSizeExceeded: {
            name: "ReceiptSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation",
              "ReceiptSizeExceeded"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          ShardCongested: {
            name: "ShardCongested",
            subtypes: [],
            props: {
              congestion_level: "",
              shard_id: ""
            }
          },
          ShardStuck: {
            name: "ShardStuck",
            subtypes: [],
            props: {
              missed_chunks: "",
              shard_id: ""
            }
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/errors/rpc_errors.cjs
  var require_rpc_errors = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/errors/rpc_errors.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getErrorTypeFromErrorMessage = exports.formatError = exports.parseResultError = exports.parseRpcError = exports.ServerError = void 0;
      var types_1 = require_commonjs();
      var mustache_1 = __importDefault(require_mustache());
      var format_1 = require_format();
      var errors_1 = require_errors();
      var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema());
      var mustacheHelpers2 = {
        formatNear: () => (n, render3) => (0, format_1.formatNearAmount)(render3(n))
      };
      var ServerError3 = class extends types_1.TypedError {
      };
      exports.ServerError = ServerError3;
      var ServerTransactionError2 = class extends ServerError3 {
        transaction_outcome;
      };
      function parseRpcError3(errorObj) {
        const result = {};
        const errorClassName = walkSubtype2(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error = new ServerError3(formatError3(errorClassName, result), errorClassName);
        Object.assign(error, result);
        return error;
      }
      exports.parseRpcError = parseRpcError3;
      function parseResultError3(result) {
        const server_error = parseRpcError3(result.status.Failure);
        const server_tx_error = new ServerTransactionError2();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      exports.parseResultError = parseResultError3;
      function formatError3(errorClassName, errorData) {
        if (typeof errors_1.ErrorMessages[errorClassName] === "string") {
          return mustache_1.default.render(errors_1.ErrorMessages[errorClassName], {
            ...errorData,
            ...mustacheHelpers2
          });
        }
        return JSON.stringify(errorData);
      }
      exports.formatError = formatError3;
      function walkSubtype2(errorObj, schema, result, typeName) {
        let error;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject2(errorObj[errorName])) {
            error = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject2(errorObj.kind) && isObject2(errorObj.kind[errorName])) {
            error = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error[prop];
          }
          return walkSubtype2(error, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage3(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      exports.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage3;
      function isObject2(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/errors/index.cjs
  var require_errors3 = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/errors/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseRpcError = exports.parseResultError = exports.getErrorTypeFromErrorMessage = exports.formatError = exports.ServerError = exports.ErrorMessages = void 0;
      var errors_1 = require_errors();
      Object.defineProperty(exports, "ErrorMessages", { enumerable: true, get: function() {
        return errors_1.ErrorMessages;
      } });
      var rpc_errors_1 = require_rpc_errors();
      Object.defineProperty(exports, "ServerError", { enumerable: true, get: function() {
        return rpc_errors_1.ServerError;
      } });
      Object.defineProperty(exports, "formatError", { enumerable: true, get: function() {
        return rpc_errors_1.formatError;
      } });
      Object.defineProperty(exports, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports, "parseResultError", { enumerable: true, get: function() {
        return rpc_errors_1.parseResultError;
      } });
      Object.defineProperty(exports, "parseRpcError", { enumerable: true, get: function() {
        return rpc_errors_1.parseRpcError;
      } });
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/logger/console.logger.cjs
  var require_console_logger = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/logger/console.logger.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConsoleLogger = void 0;
      var ConsoleLogger3 = class {
        logLevels;
        constructor(logLevels) {
          this.logLevels = logLevels;
        }
        isLevelEnabled = (level) => {
          return this.logLevels.includes(level);
        };
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose"))
            return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug"))
            return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log"))
            return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn"))
            return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error"))
            return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal"))
            return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      exports.ConsoleLogger = ConsoleLogger3;
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/logger/logger.cjs
  var require_logger = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/logger/logger.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var console_logger_1 = require_console_logger();
      var DEFAULT_LOG_LEVELS3 = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER3 = new console_logger_1.ConsoleLogger(DEFAULT_LOG_LEVELS3);
      var Logger3 = class {
        static instanceRef = DEFAULT_LOGGER3;
        static overrideLogger = (logger) => {
          this.instanceRef = logger;
        };
        static error(message, ...optionalParams) {
          this.instanceRef?.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          this.instanceRef?.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          this.instanceRef?.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          this.instanceRef?.debug?.(message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          this.instanceRef?.verbose?.(message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          this.instanceRef?.fatal?.(message, ...optionalParams);
        }
      };
      exports.Logger = Logger3;
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/logger/index.cjs
  var require_logger2 = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/logger/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = exports.ConsoleLogger = void 0;
      var console_logger_1 = require_console_logger();
      Object.defineProperty(exports, "ConsoleLogger", { enumerable: true, get: function() {
        return console_logger_1.ConsoleLogger;
      } });
      var logger_1 = require_logger();
      Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/logging.cjs
  var require_logging = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/logging.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.printTxOutcomeLogs = exports.printTxOutcomeLogsAndFailures = void 0;
      var errors_1 = require_errors3();
      var logger_1 = require_logger2();
      function printTxOutcomeLogsAndFailures2({ contractId, outcome }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? (0, errors_1.parseRpcError)(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          logger_1.Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs2({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            logger_1.Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      exports.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures2;
      function printTxOutcomeLogs2({ contractId, logs, prefix = "" }) {
        for (const log of logs) {
          logger_1.Logger.log(`${prefix}Log [${contractId}]: ${log}`);
        }
      }
      exports.printTxOutcomeLogs = printTxOutcomeLogs2;
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/provider.cjs
  var require_provider2 = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/provider.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTransactionLastResult = void 0;
      function getTransactionLastResult2(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      exports.getTransactionLastResult = getTransactionLastResult2;
    }
  });

  // ../../node_modules/depd/lib/browser/index.js
  var require_browser = __commonJS({
    "../../node_modules/depd/lib/browser/index.js"(exports, module) {
      "use strict";
      module.exports = depd3;
      function depd3(namespace) {
        if (!namespace) {
          throw new TypeError("argument namespace is required");
        }
        function deprecate(message) {
        }
        deprecate._file = void 0;
        deprecate._ignored = true;
        deprecate._namespace = namespace;
        deprecate._traced = false;
        deprecate._warned = /* @__PURE__ */ Object.create(null);
        deprecate.function = wrapfunction;
        deprecate.property = wrapproperty;
        return deprecate;
      }
      function wrapfunction(fn, message) {
        if (typeof fn !== "function") {
          throw new TypeError("argument fn must be a function");
        }
        return fn;
      }
      function wrapproperty(obj, prop, message) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
          throw new TypeError("argument obj must be object");
        }
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        if (!descriptor) {
          throw new TypeError("must call property on owner object");
        }
        if (!descriptor.configurable) {
          throw new TypeError("property must be configurable");
        }
      }
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/utils.cjs
  var require_utils = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/utils.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sortBigIntAsc = void 0;
      function sortBigIntAsc3(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      exports.sortBigIntAsc = sortBigIntAsc3;
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/validators.cjs
  var require_validators = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/validators.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.diffEpochValidators = exports.findSeatPrice = void 0;
      var depd_1 = __importDefault(require_browser());
      var utils_1 = require_utils();
      function findSeatPrice2(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      exports.findSeatPrice = findSeatPrice2;
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = 1n, right = stakesSum + 1n;
        while (left !== right - 1n) {
          const mid = (left + right) / 2n;
          let found = false;
          let currentSum = 0n;
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + 1n;
        }
      }
      function diffEpochValidators2(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
      exports.diffEpochValidators = diffEpochValidators2;
    }
  });

  // ../../node_modules/@near-js/utils/lib/commonjs/index.cjs
  var require_commonjs2 = __commonJS({
    "../../node_modules/@near-js/utils/lib/commonjs/index.cjs"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_constants2(), exports);
      __exportStar(require_errors3(), exports);
      __exportStar(require_format(), exports);
      __exportStar(require_logging(), exports);
      __exportStar(require_provider2(), exports);
      __exportStar(require_validators(), exports);
      __exportStar(require_logger2(), exports);
      __exportStar(require_utils(), exports);
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/_assert.js
  var require_assert = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/hashes/_assert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports.bool = bool;
      function bytes2(b, ...lengths) {
        if (!(b instanceof Uint8Array))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports.bytes = bytes2;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports.hash = hash;
      function exists2(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports.exists = exists2;
      function output2(out, instance) {
        bytes2(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      exports.output = output2;
      var assert = { number, bool, bytes: bytes2, hash, exists: exists2, output: output2 };
      exports.default = assert;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/crypto.js
  var require_crypto = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/hashes/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/utils.js
  var require_utils2 = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/hashes/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
      var crypto_1 = require_crypto();
      var u8a3 = (a) => a instanceof Uint8Array;
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports.u32 = u32;
      var createView4 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.createView = createView4;
      var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
      exports.rotr = rotr2;
      exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex3(bytes2) {
        if (!u8a3(bytes2))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes2.length; i++) {
          hex += hexes3[bytes2[i]];
        }
        return hex;
      }
      exports.bytesToHex = bytesToHex3;
      function hexToBytes3(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports.hexToBytes = hexToBytes3;
      var nextTick = async () => {
      };
      exports.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      exports.asyncLoop = asyncLoop;
      function utf8ToBytes4(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports.utf8ToBytes = utf8ToBytes4;
      function toBytes4(data) {
        if (typeof data === "string")
          data = utf8ToBytes4(data);
        if (!u8a3(data))
          throw new Error(`expected Uint8Array, got ${typeof data}`);
        return data;
      }
      exports.toBytes = toBytes4;
      function concatBytes5(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad = 0;
        arrays.forEach((a) => {
          if (!u8a3(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad);
          pad += a.length;
        });
        return r;
      }
      exports.concatBytes = concatBytes5;
      var Hash4 = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports.Hash = Hash4;
      var toStr2 = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr2.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports.checkOpts = checkOpts;
      function wrapConstructor4(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports.wrapConstructor = wrapConstructor4;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes3(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports.randomBytes = randomBytes3;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/_sha2.js
  var require_sha2 = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/hashes/_sha2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA2 = void 0;
      var _assert_js_1 = require_assert();
      var utils_js_1 = require_utils2();
      function setBigUint644(view, byteOffset, value, isLE2) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE2);
        const _32n3 = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n3 & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE2 ? 4 : 0;
        const l = isLE2 ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE2);
        view.setUint32(byteOffset + l, wl, isLE2);
      }
      var SHA22 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE2) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE2;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE: isLE2 } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint644(view, blockLen - 8, BigInt(this.length * 8), isLE2);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE2);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports.SHA2 = SHA22;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/_u64.js
  var require_u64 = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/hashes/_u64.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
      var U32_MASK643 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n3 = /* @__PURE__ */ BigInt(32);
      function fromBig3(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK643), l: Number(n >> _32n3 & U32_MASK643) };
        return { h: Number(n >> _32n3 & U32_MASK643) | 0, l: Number(n & U32_MASK643) | 0 };
      }
      exports.fromBig = fromBig3;
      function split3(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig3(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports.split = split3;
      var toBig3 = (h, l) => BigInt(h >>> 0) << _32n3 | BigInt(l >>> 0);
      exports.toBig = toBig3;
      var shrSH3 = (h, _l, s) => h >>> s;
      exports.shrSH = shrSH3;
      var shrSL3 = (h, l, s) => h << 32 - s | l >>> s;
      exports.shrSL = shrSL3;
      var rotrSH3 = (h, l, s) => h >>> s | l << 32 - s;
      exports.rotrSH = rotrSH3;
      var rotrSL3 = (h, l, s) => h << 32 - s | l >>> s;
      exports.rotrSL = rotrSL3;
      var rotrBH3 = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports.rotrBH = rotrBH3;
      var rotrBL3 = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports.rotrBL = rotrBL3;
      var rotr32H3 = (_h, l) => l;
      exports.rotr32H = rotr32H3;
      var rotr32L3 = (h, _l) => h;
      exports.rotr32L = rotr32L3;
      var rotlSH3 = (h, l, s) => h << s | l >>> 32 - s;
      exports.rotlSH = rotlSH3;
      var rotlSL3 = (h, l, s) => l << s | h >>> 32 - s;
      exports.rotlSL = rotlSL3;
      var rotlBH3 = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports.rotlBH = rotlBH3;
      var rotlBL3 = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports.rotlBL = rotlBL3;
      function add3(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      exports.add = add3;
      var add3L3 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports.add3L = add3L3;
      var add3H3 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports.add3H = add3H3;
      var add4L3 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports.add4L = add4L3;
      var add4H3 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports.add4H = add4H3;
      var add5L3 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports.add5L = add5L3;
      var add5H3 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports.add5H = add5H3;
      var u643 = {
        fromBig: fromBig3,
        split: split3,
        toBig: toBig3,
        shrSH: shrSH3,
        shrSL: shrSL3,
        rotrSH: rotrSH3,
        rotrSL: rotrSL3,
        rotrBH: rotrBH3,
        rotrBL: rotrBL3,
        rotr32H: rotr32H3,
        rotr32L: rotr32L3,
        rotlSH: rotlSH3,
        rotlSL: rotlSL3,
        rotlBH: rotlBH3,
        rotlBL: rotlBL3,
        add: add3,
        add3L: add3L3,
        add3H: add3H3,
        add4L: add4L3,
        add4H: add4H3,
        add5H: add5H3,
        add5L: add5L3
      };
      exports.default = u643;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/sha512.js
  var require_sha512 = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/hashes/sha512.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
      var _sha2_js_1 = require_sha2();
      var _u64_js_1 = require_u64();
      var utils_js_1 = require_utils2();
      var [SHA512_Kh3, SHA512_Kl3] = /* @__PURE__ */ (() => _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_W_H3 = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L3 = /* @__PURE__ */ new Uint32Array(80);
      var SHA5123 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H3[i] = view.getUint32(offset);
            SHA512_W_L3[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H3[i - 15] | 0;
            const W15l = SHA512_W_L3[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H3[i - 2] | 0;
            const W2l = SHA512_W_L3[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L3[i - 7], SHA512_W_L3[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H3[i - 7], SHA512_W_H3[i - 16]);
            SHA512_W_H3[i] = SUMh | 0;
            SHA512_W_L3[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl3[i], SHA512_W_L3[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh3[i], SHA512_W_H3[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H3.fill(0);
          SHA512_W_L3.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports.SHA512 = SHA5123;
      var SHA512_224 = class extends SHA5123 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      var SHA512_256 = class extends SHA5123 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      var SHA384 = class extends SHA5123 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA5123());
      exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
      exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
      exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/utils.js
  var require_utils3 = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
      var _0n11 = BigInt(0);
      var _1n11 = BigInt(1);
      var _2n9 = BigInt(2);
      var u8a3 = (a) => a instanceof Uint8Array;
      var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex3(bytes2) {
        if (!u8a3(bytes2))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes2.length; i++) {
          hex += hexes3[bytes2[i]];
        }
        return hex;
      }
      exports.bytesToHex = bytesToHex3;
      function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      exports.numberToHexUnpadded = numberToHexUnpadded;
      function hexToNumber3(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        return BigInt(hex === "" ? "0" : `0x${hex}`);
      }
      exports.hexToNumber = hexToNumber3;
      function hexToBytes3(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports.hexToBytes = hexToBytes3;
      function bytesToNumberBE3(bytes2) {
        return hexToNumber3(bytesToHex3(bytes2));
      }
      exports.bytesToNumberBE = bytesToNumberBE3;
      function bytesToNumberLE3(bytes2) {
        if (!u8a3(bytes2))
          throw new Error("Uint8Array expected");
        return hexToNumber3(bytesToHex3(Uint8Array.from(bytes2).reverse()));
      }
      exports.bytesToNumberLE = bytesToNumberLE3;
      function numberToBytesBE3(n, len) {
        return hexToBytes3(n.toString(16).padStart(len * 2, "0"));
      }
      exports.numberToBytesBE = numberToBytesBE3;
      function numberToBytesLE3(n, len) {
        return numberToBytesBE3(n, len).reverse();
      }
      exports.numberToBytesLE = numberToBytesLE3;
      function numberToVarBytesBE(n) {
        return hexToBytes3(numberToHexUnpadded(n));
      }
      exports.numberToVarBytesBE = numberToVarBytesBE;
      function ensureBytes3(title, hex, expectedLength) {
        let res;
        if (typeof hex === "string") {
          try {
            res = hexToBytes3(hex);
          } catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
          }
        } else if (u8a3(hex)) {
          res = Uint8Array.from(hex);
        } else {
          throw new Error(`${title} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
        return res;
      }
      exports.ensureBytes = ensureBytes3;
      function concatBytes5(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad = 0;
        arrays.forEach((a) => {
          if (!u8a3(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad);
          pad += a.length;
        });
        return r;
      }
      exports.concatBytes = concatBytes5;
      function equalBytes(b1, b2) {
        if (b1.length !== b2.length)
          return false;
        for (let i = 0; i < b1.length; i++)
          if (b1[i] !== b2[i])
            return false;
        return true;
      }
      exports.equalBytes = equalBytes;
      function utf8ToBytes4(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports.utf8ToBytes = utf8ToBytes4;
      function bitLen2(n) {
        let len;
        for (len = 0; n > _0n11; n >>= _1n11, len += 1)
          ;
        return len;
      }
      exports.bitLen = bitLen2;
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n11;
      }
      exports.bitGet = bitGet;
      var bitSet = (n, pos, value) => {
        return n | (value ? _1n11 : _0n11) << BigInt(pos);
      };
      exports.bitSet = bitSet;
      var bitMask3 = (n) => (_2n9 << BigInt(n - 1)) - _1n11;
      exports.bitMask = bitMask3;
      var u8n = (data) => new Uint8Array(data);
      var u8fr = (arr) => Uint8Array.from(arr);
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed = u8n()) => {
          k = h(u8fr([0]), seed);
          v = h();
          if (seed.length === 0)
            return;
          k = h(u8fr([1]), seed);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
          }
          return concatBytes5(...out);
        };
        const genUntil = (seed, pred) => {
          reset();
          reseed(seed);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      exports.createHmacDrbg = createHmacDrbg;
      var validatorFns3 = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject3(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
          const checkVal = validatorFns3[type];
          if (typeof checkVal !== "function")
            throw new Error(`Invalid validator "${type}", expected function`);
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
          }
        };
        for (const [fieldName, type] of Object.entries(validators))
          checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
          checkField(fieldName, type, true);
        return object;
      }
      exports.validateObject = validateObject3;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/modular.js
  var require_modular = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/modular.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
      var utils_js_1 = require_utils3();
      var _0n11 = BigInt(0);
      var _1n11 = BigInt(1);
      var _2n9 = BigInt(2);
      var _3n4 = BigInt(3);
      var _4n3 = BigInt(4);
      var _5n5 = BigInt(5);
      var _8n6 = BigInt(8);
      var _9n3 = BigInt(9);
      var _16n3 = BigInt(16);
      function mod3(a, b) {
        const result = a % b;
        return result >= _0n11 ? result : b + result;
      }
      exports.mod = mod3;
      function pow4(num, power, modulo) {
        if (modulo <= _0n11 || power < _0n11)
          throw new Error("Expected power/modulo > 0");
        if (modulo === _1n11)
          return _0n11;
        let res = _1n11;
        while (power > _0n11) {
          if (power & _1n11)
            res = res * num % modulo;
          num = num * num % modulo;
          power >>= _1n11;
        }
        return res;
      }
      exports.pow = pow4;
      function pow23(x, power, modulo) {
        let res = x;
        while (power-- > _0n11) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      exports.pow2 = pow23;
      function invert3(number, modulo) {
        if (number === _0n11 || modulo <= _0n11) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod3(number, modulo);
        let b = modulo;
        let x = _0n11, y = _1n11, u = _1n11, v = _0n11;
        while (a !== _0n11) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n11)
          throw new Error("invert: does not exist");
        return mod3(x, modulo);
      }
      exports.invert = invert3;
      function tonelliShanks3(P) {
        const legendreC = (P - _1n11) / _2n9;
        let Q, S, Z;
        for (Q = P - _1n11, S = 0; Q % _2n9 === _0n11; Q /= _2n9, S++)
          ;
        for (Z = _2n9; Z < P && pow4(Z, legendreC, P) !== P - _1n11; Z++)
          ;
        if (S === 1) {
          const p1div4 = (P + _1n11) / _4n3;
          return function tonelliFast(Fp3, n) {
            const root = Fp3.pow(n, p1div4);
            if (!Fp3.eql(Fp3.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        const Q1div2 = (Q + _1n11) / _2n9;
        return function tonelliSlow(Fp3, n) {
          if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE))
            throw new Error("Cannot find square root");
          let r = S;
          let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
          let x = Fp3.pow(n, Q1div2);
          let b = Fp3.pow(n, Q);
          while (!Fp3.eql(b, Fp3.ONE)) {
            if (Fp3.eql(b, Fp3.ZERO))
              return Fp3.ZERO;
            let m = 1;
            for (let t2 = Fp3.sqr(b); m < r; m++) {
              if (Fp3.eql(t2, Fp3.ONE))
                break;
              t2 = Fp3.sqr(t2);
            }
            const ge = Fp3.pow(g, _1n11 << BigInt(r - m - 1));
            g = Fp3.sqr(ge);
            x = Fp3.mul(x, ge);
            b = Fp3.mul(b, g);
            r = m;
          }
          return x;
        };
      }
      exports.tonelliShanks = tonelliShanks3;
      function FpSqrt3(P) {
        if (P % _4n3 === _3n4) {
          const p1div4 = (P + _1n11) / _4n3;
          return function sqrt3mod4(Fp3, n) {
            const root = Fp3.pow(n, p1div4);
            if (!Fp3.eql(Fp3.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        if (P % _8n6 === _5n5) {
          const c1 = (P - _5n5) / _8n6;
          return function sqrt5mod8(Fp3, n) {
            const n2 = Fp3.mul(n, _2n9);
            const v = Fp3.pow(n2, c1);
            const nv = Fp3.mul(n, v);
            const i = Fp3.mul(Fp3.mul(nv, _2n9), v);
            const root = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
            if (!Fp3.eql(Fp3.sqr(root), n))
              throw new Error("Cannot find square root");
            return root;
          };
        }
        if (P % _16n3 === _9n3) {
        }
        return tonelliShanks3(P);
      }
      exports.FpSqrt = FpSqrt3;
      var isNegativeLE3 = (num, modulo) => (mod3(num, modulo) & _1n11) === _1n11;
      exports.isNegativeLE = isNegativeLE3;
      var FIELD_FIELDS3 = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField3(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        };
        const opts = FIELD_FIELDS3.reduce((map, val) => {
          map[val] = "function";
          return map;
        }, initial);
        return (0, utils_js_1.validateObject)(field, opts);
      }
      exports.validateField = validateField3;
      function FpPow3(f, num, power) {
        if (power < _0n11)
          throw new Error("Expected power > 0");
        if (power === _0n11)
          return f.ONE;
        if (power === _1n11)
          return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n11) {
          if (power & _1n11)
            p = f.mul(p, d);
          d = f.sqr(d);
          power >>= _1n11;
        }
        return p;
      }
      exports.FpPow = FpPow3;
      function FpInvertBatch3(f, nums) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = acc;
          return f.mul(acc, num);
        }, f.ONE);
        const inverted = f.inv(lastMultiplied);
        nums.reduceRight((acc, num, i) => {
          if (f.is0(num))
            return acc;
          tmp[i] = f.mul(acc, tmp[i]);
          return f.mul(acc, num);
        }, inverted);
        return tmp;
      }
      exports.FpInvertBatch = FpInvertBatch3;
      function FpDiv(f, lhs, rhs) {
        return f.mul(lhs, typeof rhs === "bigint" ? invert3(rhs, f.ORDER) : f.inv(rhs));
      }
      exports.FpDiv = FpDiv;
      function FpIsSquare(f) {
        const legendreConst = (f.ORDER - _1n11) / _2n9;
        return (x) => {
          const p = f.pow(x, legendreConst);
          return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
        };
      }
      exports.FpIsSquare = FpIsSquare;
      function nLength3(n, nBitLength) {
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      exports.nLength = nLength3;
      function Field3(ORDER, bitLen2, isLE2 = false, redef = {}) {
        if (ORDER <= _0n11)
          throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength3(ORDER, bitLen2);
        if (BYTES > 2048)
          throw new Error("Field lengths over 2048 bytes are not supported");
        const sqrtP = FpSqrt3(ORDER);
        const f = Object.freeze({
          ORDER,
          BITS,
          BYTES,
          MASK: (0, utils_js_1.bitMask)(BITS),
          ZERO: _0n11,
          ONE: _1n11,
          create: (num) => mod3(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n11 <= num && num < ORDER;
          },
          is0: (num) => num === _0n11,
          isOdd: (num) => (num & _1n11) === _1n11,
          neg: (num) => mod3(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod3(num * num, ORDER),
          add: (lhs, rhs) => mod3(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod3(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod3(lhs * rhs, ORDER),
          pow: (num, power) => FpPow3(f, num, power),
          div: (lhs, rhs) => mod3(lhs * invert3(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert3(num, ORDER),
          sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
          invertBatch: (lst) => FpInvertBatch3(f, lst),
          // TODO: do we really need constant cmov?
          // We don't have const-time bigints anyway, so probably will be not very useful
          cmov: (a, b, c) => c ? b : a,
          toBytes: (num) => isLE2 ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
          fromBytes: (bytes2) => {
            if (bytes2.length !== BYTES)
              throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
            return isLE2 ? (0, utils_js_1.bytesToNumberLE)(bytes2) : (0, utils_js_1.bytesToNumberBE)(bytes2);
          }
        });
        return Object.freeze(f);
      }
      exports.Field = Field3;
      function FpSqrtOdd(Fp3, elm) {
        if (!Fp3.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root = Fp3.sqrt(elm);
        return Fp3.isOdd(root) ? root : Fp3.neg(root);
      }
      exports.FpSqrtOdd = FpSqrtOdd;
      function FpSqrtEven3(Fp3, elm) {
        if (!Fp3.isOdd)
          throw new Error(`Field doesn't have isOdd`);
        const root = Fp3.sqrt(elm);
        return Fp3.isOdd(root) ? Fp3.neg(root) : root;
      }
      exports.FpSqrtEven = FpSqrtEven3;
      function hashToPrivateScalar(hash, groupOrder, isLE2 = false) {
        hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
        const hashLen = hash.length;
        const minLen = nLength3(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
        const num = isLE2 ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
        return mod3(num, groupOrder - _1n11) + _1n11;
      }
      exports.hashToPrivateScalar = hashToPrivateScalar;
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      exports.getFieldBytesLength = getFieldBytesLength;
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      exports.getMinHashLength = getMinHashLength;
      function mapHashToField(key, fieldOrder, isLE2 = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num = isLE2 ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
        const reduced = mod3(num, fieldOrder - _1n11) + _1n11;
        return isLE2 ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
      }
      exports.mapHashToField = mapHashToField;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/curve.js
  var require_curve = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validateBasic = exports.wNAF = void 0;
      var modular_js_1 = require_modular();
      var utils_js_1 = require_utils3();
      var _0n11 = BigInt(0);
      var _1n11 = BigInt(1);
      function wNAF3(c, bits) {
        const constTimeNegate2 = (condition, item) => {
          const neg = item.negate();
          return condition ? neg : item;
        };
        const opts = (W) => {
          const windows = Math.ceil(bits / W) + 1;
          const windowSize = 2 ** (W - 1);
          return { windows, windowSize };
        };
        return {
          constTimeNegate: constTimeNegate2,
          // non-const time multiplication ladder
          unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n11) {
              if (n & _1n11)
                p = p.add(d);
              d = d.double();
              n >>= _1n11;
            }
            return p;
          },
          /**
           * Creates a wNAF precomputation window. Used for caching.
           * Default window size is set by `utils.precompute()` and is equal to 8.
           * Number of precomputed points depends on the curve size:
           * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
           * - 𝑊 is the window size
           * - 𝑛 is the bitlength of the curve order.
           * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
           * @returns precomputed point tables flattened to a single array
           */
          precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base2 = p;
            for (let window2 = 0; window2 < windows; window2++) {
              base2 = p;
              points.push(base2);
              for (let i = 1; i < windowSize; i++) {
                base2 = base2.add(p);
                points.push(base2);
              }
              p = base2.double();
            }
            return points;
          },
          /**
           * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
           * @param W window size
           * @param precomputes precomputed tables
           * @param n scalar (we don't check here, but should be less than curve order)
           * @returns real and fake (for const-time) points
           */
          wNAF(W, precomputes, n) {
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window2 = 0; window2 < windows; window2++) {
              const offset = window2 * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n11;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window2 % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate2(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate2(cond2, precomputes[offset2]));
              }
            }
            return { p, f };
          },
          wNAFCached(P, precomputesMap, n, transform) {
            const W = P._WINDOW_SIZE || 1;
            let comp = precomputesMap.get(P);
            if (!comp) {
              comp = this.precomputeWindow(P, W);
              if (W !== 1) {
                precomputesMap.set(P, transform(comp));
              }
            }
            return this.wNAF(W, comp, n);
          }
        };
      }
      exports.wNAF = wNAF3;
      function validateBasic3(curve) {
        (0, modular_js_1.validateField)(curve.Fp);
        (0, utils_js_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
      exports.validateBasic = validateBasic3;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/edwards.js
  var require_edwards = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/edwards.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.twistedEdwards = void 0;
      var modular_js_1 = require_modular();
      var ut = require_utils3();
      var utils_js_1 = require_utils3();
      var curve_js_1 = require_curve();
      var _0n11 = BigInt(0);
      var _1n11 = BigInt(1);
      var _2n9 = BigInt(2);
      var _8n6 = BigInt(8);
      var VERIFY_DEFAULT3 = { zip215: true };
      function validateOpts3(curve) {
        const opts = (0, curve_js_1.validateBasic)(curve);
        ut.validateObject(curve, {
          hash: "function",
          a: "bigint",
          d: "bigint",
          randomBytes: "function"
        }, {
          adjustScalarBytes: "function",
          domain: "function",
          uvRatio: "function",
          mapToCurve: "function"
        });
        return Object.freeze({ ...opts });
      }
      function twistedEdwards3(curveDef) {
        const CURVE = validateOpts3(curveDef);
        const { Fp: Fp3, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes3, nByteLength, h: cofactor } = CURVE;
        const MASK = _2n9 << BigInt(nByteLength * 8) - _1n11;
        const modP = Fp3.create;
        const uvRatio3 = CURVE.uvRatio || ((u, v) => {
          try {
            return { isValid: true, value: Fp3.sqrt(u * Fp3.inv(v)) };
          } catch (e) {
            return { isValid: false, value: _0n11 };
          }
        });
        const adjustScalarBytes3 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
        const domain = CURVE.domain || ((data, ctx, phflag) => {
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data;
        });
        const inBig = (n) => typeof n === "bigint" && _0n11 < n;
        const inRange2 = (n, max) => inBig(n) && inBig(max) && n < max;
        const in0MaskRange = (n) => n === _0n11 || inRange2(n, MASK);
        function assertInRange(n, max) {
          if (inRange2(n, max))
            return n;
          throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);
        }
        function assertGE0(n) {
          return n === _0n11 ? n : assertInRange(n, CURVE_ORDER);
        }
        const pointPrecomputes2 = /* @__PURE__ */ new Map();
        function isPoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        class Point {
          constructor(ex, ey, ez, et) {
            this.ex = ex;
            this.ey = ey;
            this.ez = ez;
            this.et = et;
            if (!in0MaskRange(ex))
              throw new Error("x required");
            if (!in0MaskRange(ey))
              throw new Error("y required");
            if (!in0MaskRange(ez))
              throw new Error("z required");
            if (!in0MaskRange(et))
              throw new Error("t required");
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            const { x, y } = p || {};
            if (!in0MaskRange(x) || !in0MaskRange(y))
              throw new Error("invalid affine point");
            return new Point(x, y, _1n11, modP(x * y));
          }
          static normalizeZ(points) {
            const toInv = Fp3.invertBatch(points.map((p) => p.ez));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          }
          // "Private method", don't use it directly
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes2.delete(this);
          }
          // Not required for fromHex(), which always creates valid points.
          // Could be useful for fromAffine().
          assertValidity() {
            const { a, d } = CURVE;
            if (this.is0())
              throw new Error("bad point: ZERO");
            const { ex: X, ey: Y, ez: Z, et: T } = this;
            const X2 = modP(X * X);
            const Y2 = modP(Y * Y);
            const Z2 = modP(Z * Z);
            const Z4 = modP(Z2 * Z2);
            const aX2 = modP(X2 * a);
            const left = modP(Z2 * modP(aX2 + Y2));
            const right = modP(Z4 + modP(d * modP(X2 * Y2)));
            if (left !== right)
              throw new Error("bad point: equation left != right (1)");
            const XY = modP(X * Y);
            const ZT = modP(Z * T);
            if (XY !== ZT)
              throw new Error("bad point: equation left != right (2)");
          }
          // Compare one point to another.
          equals(other) {
            isPoint(other);
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const { ex: X2, ey: Y2, ez: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
          }
          // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          double() {
            const { a } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1 } = this;
            const A = modP(X1 * X1);
            const B = modP(Y1 * Y1);
            const C = modP(_2n9 * modP(Z1 * Z1));
            const D = modP(a * A);
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B);
            const G2 = D + B;
            const F = G2 - C;
            const H = D - B;
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          add(other) {
            isPoint(other);
            const { a, d } = CURVE;
            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
            if (a === BigInt(-1)) {
              const A2 = modP((Y1 - X1) * (Y2 + X2));
              const B2 = modP((Y1 + X1) * (Y2 - X2));
              const F2 = modP(B2 - A2);
              if (F2 === _0n11)
                return this.double();
              const C2 = modP(Z1 * _2n9 * T2);
              const D2 = modP(T1 * _2n9 * Z2);
              const E2 = D2 + C2;
              const G3 = B2 + A2;
              const H2 = D2 - C2;
              const X32 = modP(E2 * F2);
              const Y32 = modP(G3 * H2);
              const T32 = modP(E2 * H2);
              const Z32 = modP(F2 * G3);
              return new Point(X32, Y32, Z32, T32);
            }
            const A = modP(X1 * X2);
            const B = modP(Y1 * Y2);
            const C = modP(T1 * d * T2);
            const D = modP(Z1 * Z2);
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            const F = D - C;
            const G2 = D + C;
            const H = modP(B - a * A);
            const X3 = modP(E * F);
            const Y3 = modP(G2 * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G2);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes2, n, Point.normalizeZ);
          }
          // Constant-time multiplication.
          multiply(scalar) {
            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
            return Point.normalizeZ([p, f])[0];
          }
          // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          multiplyUnsafe(scalar) {
            let n = assertGE0(scalar);
            if (n === _0n11)
              return I;
            if (this.equals(I) || n === _1n11)
              return this;
            if (this.equals(G))
              return this.wNAF(n).p;
            return wnaf.unsafeLadder(this, n);
          }
          // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
          }
          // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          toAffine(iz) {
            const { ex: x, ey: y, ez: z } = this;
            const is0 = this.is0();
            if (iz == null)
              iz = is0 ? _8n6 : Fp3.inv(z);
            const ax = modP(x * iz);
            const ay = modP(y * iz);
            const zz = modP(z * iz);
            if (is0)
              return { x: _0n11, y: _1n11 };
            if (zz !== _1n11)
              throw new Error("invZ was invalid");
            return { x: ax, y: ay };
          }
          clearCofactor() {
            const { h: cofactor2 } = CURVE;
            if (cofactor2 === _1n11)
              return this;
            return this.multiplyUnsafe(cofactor2);
          }
          // Converts hash string or Uint8Array to Point.
          // Uses algo from RFC8032 5.1.3.
          static fromHex(hex, zip215 = false) {
            const { d, a } = CURVE;
            const len = Fp3.BYTES;
            hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len);
            const normed = hex.slice();
            const lastByte = hex[len - 1];
            normed[len - 1] = lastByte & ~128;
            const y = ut.bytesToNumberLE(normed);
            if (y === _0n11) {
            } else {
              if (zip215)
                assertInRange(y, MASK);
              else
                assertInRange(y, Fp3.ORDER);
            }
            const y2 = modP(y * y);
            const u = modP(y2 - _1n11);
            const v = modP(d * y2 - a);
            let { isValid, value: x } = uvRatio3(u, v);
            if (!isValid)
              throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n11) === _1n11;
            const isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n11 && isLastByteOdd)
              throw new Error("Point.fromHex: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd)
              x = modP(-x);
            return Point.fromAffine({ x, y });
          }
          static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
          }
          toRawBytes() {
            const { x, y } = this.toAffine();
            const bytes2 = ut.numberToBytesLE(y, Fp3.BYTES);
            bytes2[bytes2.length - 1] |= x & _1n11 ? 128 : 0;
            return bytes2;
          }
          toHex() {
            return ut.bytesToHex(this.toRawBytes());
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n11, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n11, _1n11, _1n11, _0n11);
        const { BASE: G, ZERO: I } = Point;
        const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
        function modN(a) {
          return (0, modular_js_1.mod)(a, CURVE_ORDER);
        }
        function modN_LE(hash) {
          return modN(ut.bytesToNumberLE(hash));
        }
        function getExtendedPublicKey(key) {
          const len = nByteLength;
          key = (0, utils_js_1.ensureBytes)("private key", key, len);
          const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          const head = adjustScalarBytes3(hashed.slice(0, len));
          const prefix = hashed.slice(len, 2 * len);
          const scalar = modN_LE(head);
          const point = G.multiply(scalar);
          const pointBytes = point.toRawBytes();
          return { head, prefix, scalar, point, pointBytes };
        }
        function getPublicKey(privKey) {
          return getExtendedPublicKey(privKey).pointBytes;
        }
        function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
          const msg = ut.concatBytes(...msgs);
          return modN_LE(cHash(domain(msg, (0, utils_js_1.ensureBytes)("context", context), !!prehash)));
        }
        function sign(msg, privKey, options = {}) {
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
          const r = hashDomainToScalar(options.context, prefix, msg);
          const R = G.multiply(r).toRawBytes();
          const k = hashDomainToScalar(options.context, R, pointBytes, msg);
          const s = modN(r + k * scalar);
          assertGE0(s);
          const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp3.BYTES));
          return (0, utils_js_1.ensureBytes)("result", res, nByteLength * 2);
        }
        const verifyOpts = VERIFY_DEFAULT3;
        function verify(sig, msg, publicKey, options = verifyOpts) {
          const { context, zip215 } = options;
          const len = Fp3.BYTES;
          sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len);
          msg = (0, utils_js_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
          let A, R, SB;
          try {
            A = Point.fromHex(publicKey, zip215);
            R = Point.fromHex(sig.slice(0, len), zip215);
            SB = G.multiplyUnsafe(s);
          } catch (error) {
            return false;
          }
          if (!zip215 && A.isSmallOrder())
            return false;
          const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
          const RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
        }
        G._setWindowSize(8);
        const utils = {
          getExtendedPublicKey,
          // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
          randomPrivateKey: () => randomBytes3(Fp3.BYTES),
          /**
           * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
           * values. This slows down first getPublicKey() by milliseconds (see Speed section),
           * but allows to speed-up subsequent getPublicKey() calls up to 20x.
           * @param windowSize 2, 4, 8, 16
           */
          precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3));
            return point;
          }
        };
        return {
          CURVE,
          getPublicKey,
          sign,
          verify,
          ExtendedPoint: Point,
          utils
        };
      }
      exports.twistedEdwards = twistedEdwards3;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/montgomery.js
  var require_montgomery = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/montgomery.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.montgomery = void 0;
      var modular_js_1 = require_modular();
      var utils_js_1 = require_utils3();
      var _0n11 = BigInt(0);
      var _1n11 = BigInt(1);
      function validateOpts3(curve) {
        (0, utils_js_1.validateObject)(curve, {
          a: "bigint"
        }, {
          montgomeryBits: "isSafeInteger",
          nByteLength: "isSafeInteger",
          adjustScalarBytes: "function",
          domain: "function",
          powPminus2: "function",
          Gu: "bigint"
        });
        return Object.freeze({ ...curve });
      }
      function montgomery(curveDef) {
        const CURVE = validateOpts3(curveDef);
        const { P } = CURVE;
        const modP = (n) => (0, modular_js_1.mod)(n, P);
        const montgomeryBits = CURVE.montgomeryBits;
        const montgomeryBytes = Math.ceil(montgomeryBits / 8);
        const fieldLen = CURVE.nByteLength;
        const adjustScalarBytes3 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
        const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
        function cswap(swap, x_2, x_3) {
          const dummy = modP(swap * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return [x_2, x_3];
        }
        function assertFieldElement(n) {
          if (typeof n === "bigint" && _0n11 <= n && n < P)
            return n;
          throw new Error("Expected valid scalar 0 < scalar < CURVE.P");
        }
        const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
        function montgomeryLadder(pointU, scalar) {
          const u = assertFieldElement(pointU);
          const k = assertFieldElement(scalar);
          const x_1 = u;
          let x_2 = _1n11;
          let z_2 = _0n11;
          let x_3 = u;
          let z_3 = _1n11;
          let swap = _0n11;
          let sw;
          for (let t = BigInt(montgomeryBits - 1); t >= _0n11; t--) {
            const k_t = k >> t & _1n11;
            swap ^= k_t;
            sw = cswap(swap, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }
          sw = cswap(swap, x_2, x_3);
          x_2 = sw[0];
          x_3 = sw[1];
          sw = cswap(swap, z_2, z_3);
          z_2 = sw[0];
          z_3 = sw[1];
          const z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }
        function encodeUCoordinate(u) {
          return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
        }
        function decodeUCoordinate(uEnc) {
          const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
          if (fieldLen === montgomeryBytes)
            u[fieldLen - 1] &= 127;
          return (0, utils_js_1.bytesToNumberLE)(u);
        }
        function decodeScalar(n) {
          const bytes2 = (0, utils_js_1.ensureBytes)("scalar", n);
          if (bytes2.length !== montgomeryBytes && bytes2.length !== fieldLen)
            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes2.length}`);
          return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes3(bytes2));
        }
        function scalarMult(scalar, u) {
          const pointU = decodeUCoordinate(u);
          const _scalar = decodeScalar(scalar);
          const pu = montgomeryLadder(pointU, _scalar);
          if (pu === _0n11)
            throw new Error("Invalid private or public key received");
          return encodeUCoordinate(pu);
        }
        const GuBytes = encodeUCoordinate(CURVE.Gu);
        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }
        return {
          scalarMult,
          scalarMultBase,
          getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
          getPublicKey: (privateKey) => scalarMultBase(privateKey),
          utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
          GuBytes
        };
      }
      exports.montgomery = montgomery;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
      var modular_js_1 = require_modular();
      var utils_js_1 = require_utils3();
      function validateDST(dst) {
        if (dst instanceof Uint8Array)
          return dst;
        if (typeof dst === "string")
          return (0, utils_js_1.utf8ToBytes)(dst);
        throw new Error("DST must be Uint8Array or string");
      }
      var os2ip = utils_js_1.bytesToNumberBE;
      function i2osp(value, length) {
        if (value < 0 || value >= 1 << 8 * length) {
          throw new Error(`bad I2OSP call: value=${value} length=${length}`);
        }
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function isBytes4(item) {
        if (!(item instanceof Uint8Array))
          throw new Error("Uint8Array expected");
      }
      function isNum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        isBytes4(msg);
        isBytes4(DST);
        isNum(lenInBytes);
        if (DST.length > 255)
          DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (ell > 255)
          throw new Error("Invalid xmd length");
        const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_js_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      exports.expand_message_xmd = expand_message_xmd;
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        isBytes4(msg);
        isBytes4(DST);
        isNum(lenInBytes);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      exports.expand_message_xof = expand_message_xof;
      function hash_to_field(msg, count, options) {
        (0, utils_js_1.validateObject)(options, {
          DST: "stringOrUint8Array",
          p: "bigint",
          m: "isSafeInteger",
          k: "isSafeInteger",
          hash: "hash"
        });
        const { p, k, m, hash, expand, DST: _DST } = options;
        isBytes4(msg);
        isNum(count);
        const DST = validateDST(_DST);
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      exports.hash_to_field = hash_to_field;
      function isogenyMap(field, map) {
        const COEFF = map.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          x = field.div(xNum, xDen);
          y = field.mul(y, field.div(yNum, yDen));
          return { x, y };
        };
      }
      exports.isogenyMap = isogenyMap;
      function createHasher(Point, mapToCurve, def) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        return {
          // Encodes byte string to elliptic curve.
          // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
          },
          // Encodes byte string to elliptic curve.
          // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
          encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
          }
        };
      }
      exports.createHasher = createHasher;
    }
  });

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/ed25519.js
  var require_ed25519 = __commonJS({
    "../../node_modules/@near-js/crypto/node_modules/@noble/curves/ed25519.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.edwardsToMontgomeryPriv = exports.edwardsToMontgomery = exports.edwardsToMontgomeryPub = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;
      var sha512_1 = require_sha512();
      var utils_1 = require_utils2();
      var edwards_js_1 = require_edwards();
      var montgomery_js_1 = require_montgomery();
      var modular_js_1 = require_modular();
      var utils_js_1 = require_utils3();
      var hash_to_curve_js_1 = require_hash_to_curve();
      var ED25519_P3 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
      var ED25519_SQRT_M13 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      var _0n11 = BigInt(0);
      var _1n11 = BigInt(1);
      var _2n9 = BigInt(2);
      var _5n5 = BigInt(5);
      var _10n2 = BigInt(10);
      var _20n2 = BigInt(20);
      var _40n2 = BigInt(40);
      var _80n2 = BigInt(80);
      function ed25519_pow_2_252_33(x) {
        const P = ED25519_P3;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = (0, modular_js_1.pow2)(b2, _2n9, P) * b2 % P;
        const b5 = (0, modular_js_1.pow2)(b4, _1n11, P) * x % P;
        const b10 = (0, modular_js_1.pow2)(b5, _5n5, P) * b5 % P;
        const b20 = (0, modular_js_1.pow2)(b10, _10n2, P) * b10 % P;
        const b40 = (0, modular_js_1.pow2)(b20, _20n2, P) * b20 % P;
        const b80 = (0, modular_js_1.pow2)(b40, _40n2, P) * b40 % P;
        const b160 = (0, modular_js_1.pow2)(b80, _80n2, P) * b80 % P;
        const b240 = (0, modular_js_1.pow2)(b160, _80n2, P) * b80 % P;
        const b250 = (0, modular_js_1.pow2)(b240, _10n2, P) * b10 % P;
        const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n9, P) * x % P;
        return { pow_p_5_8, b2 };
      }
      function adjustScalarBytes3(bytes2) {
        bytes2[0] &= 248;
        bytes2[31] &= 127;
        bytes2[31] |= 64;
        return bytes2;
      }
      function uvRatio3(u, v) {
        const P = ED25519_P3;
        const v3 = (0, modular_js_1.mod)(v * v * v, P);
        const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P);
        const pow4 = ed25519_pow_2_252_33(u * v7).pow_p_5_8;
        let x = (0, modular_js_1.mod)(u * v3 * pow4, P);
        const vx2 = (0, modular_js_1.mod)(v * x * x, P);
        const root1 = x;
        const root2 = (0, modular_js_1.mod)(x * ED25519_SQRT_M13, P);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P);
        const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M13, P);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root2;
        if ((0, modular_js_1.isNegativeLE)(x, P))
          x = (0, modular_js_1.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      exports.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ];
      var Fp3 = (0, modular_js_1.Field)(ED25519_P3, void 0, true);
      var ed25519Defaults3 = {
        // Param: a
        a: BigInt(-1),
        // d is equal to -121665/121666 over finite field.
        // Negative number is P - number, and division is invert(number, P)
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
        Fp: Fp3,
        // Subgroup order: how many points curve has
        // 2n**252n + 27742317777372353535851937790883648493n;
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        // Cofactor
        h: BigInt(8),
        // Base point (x, y) aka generator point
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: sha512_1.sha512,
        randomBytes: utils_1.randomBytes,
        adjustScalarBytes: adjustScalarBytes3,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/√v
        uvRatio: uvRatio3
      };
      exports.ed25519 = (0, edwards_js_1.twistedEdwards)(ed25519Defaults3);
      function ed25519_domain2(data, ctx, phflag) {
        if (ctx.length > 255)
          throw new Error("Context is too big");
        return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
      }
      exports.ed25519ctx = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults3,
        domain: ed25519_domain2
      });
      exports.ed25519ph = (0, edwards_js_1.twistedEdwards)({
        ...ed25519Defaults3,
        domain: ed25519_domain2,
        prehash: sha512_1.sha512
      });
      exports.x25519 = (() => (0, montgomery_js_1.montgomery)({
        P: ED25519_P3,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (x) => {
          const P = ED25519_P3;
          const { pow_p_5_8, b2 } = ed25519_pow_2_252_33(x);
          return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);
        },
        adjustScalarBytes: adjustScalarBytes3,
        randomBytes: utils_1.randomBytes
      }))();
      function edwardsToMontgomeryPub(edwardsPub) {
        const { y } = exports.ed25519.ExtendedPoint.fromHex(edwardsPub);
        const _1n12 = BigInt(1);
        return Fp3.toBytes(Fp3.create((_1n12 + y) * Fp3.inv(_1n12 - y)));
      }
      exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports.edwardsToMontgomery = edwardsToMontgomeryPub;
      function edwardsToMontgomeryPriv(edwardsPriv) {
        const hashed = ed25519Defaults3.hash(edwardsPriv.subarray(0, 32));
        return ed25519Defaults3.adjustScalarBytes(hashed).subarray(0, 32);
      }
      exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var ELL2_C12 = (Fp3.ORDER + BigInt(3)) / BigInt(8);
      var ELL2_C22 = Fp3.pow(_2n9, ELL2_C12);
      var ELL2_C32 = Fp3.sqrt(Fp3.neg(Fp3.ONE));
      var ELL2_C42 = (Fp3.ORDER - BigInt(5)) / BigInt(8);
      var ELL2_J2 = BigInt(486662);
      function map_to_curve_elligator2_curve25519(u) {
        let tv1 = Fp3.sqr(u);
        tv1 = Fp3.mul(tv1, _2n9);
        let xd = Fp3.add(tv1, Fp3.ONE);
        let x1n = Fp3.neg(ELL2_J2);
        let tv2 = Fp3.sqr(xd);
        let gxd = Fp3.mul(tv2, xd);
        let gx1 = Fp3.mul(tv1, ELL2_J2);
        gx1 = Fp3.mul(gx1, x1n);
        gx1 = Fp3.add(gx1, tv2);
        gx1 = Fp3.mul(gx1, x1n);
        let tv3 = Fp3.sqr(gxd);
        tv2 = Fp3.sqr(tv3);
        tv3 = Fp3.mul(tv3, gxd);
        tv3 = Fp3.mul(tv3, gx1);
        tv2 = Fp3.mul(tv2, tv3);
        let y11 = Fp3.pow(tv2, ELL2_C42);
        y11 = Fp3.mul(y11, tv3);
        let y12 = Fp3.mul(y11, ELL2_C32);
        tv2 = Fp3.sqr(y11);
        tv2 = Fp3.mul(tv2, gxd);
        let e1 = Fp3.eql(tv2, gx1);
        let y1 = Fp3.cmov(y12, y11, e1);
        let x2n = Fp3.mul(x1n, tv1);
        let y21 = Fp3.mul(y11, u);
        y21 = Fp3.mul(y21, ELL2_C22);
        let y22 = Fp3.mul(y21, ELL2_C32);
        let gx2 = Fp3.mul(gx1, tv1);
        tv2 = Fp3.sqr(y21);
        tv2 = Fp3.mul(tv2, gxd);
        let e2 = Fp3.eql(tv2, gx2);
        let y2 = Fp3.cmov(y22, y21, e2);
        tv2 = Fp3.sqr(y1);
        tv2 = Fp3.mul(tv2, gxd);
        let e3 = Fp3.eql(tv2, gx1);
        let xn = Fp3.cmov(x2n, x1n, e3);
        let y = Fp3.cmov(y2, y1, e3);
        let e4 = Fp3.isOdd(y);
        y = Fp3.cmov(y, Fp3.neg(y), e3 !== e4);
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n11 };
      }
      var ELL2_C1_EDWARDS2 = (0, modular_js_1.FpSqrtEven)(Fp3, Fp3.neg(BigInt(486664)));
      function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
        let xn = Fp3.mul(xMn, yMd);
        xn = Fp3.mul(xn, ELL2_C1_EDWARDS2);
        let xd = Fp3.mul(xMd, yMn);
        let yn = Fp3.sub(xMn, xMd);
        let yd = Fp3.add(xMn, xMd);
        let tv1 = Fp3.mul(xd, yd);
        let e = Fp3.eql(tv1, Fp3.ZERO);
        xn = Fp3.cmov(xn, Fp3.ZERO, e);
        xd = Fp3.cmov(xd, Fp3.ONE, e);
        yn = Fp3.cmov(yn, Fp3.ONE, e);
        yd = Fp3.cmov(yd, Fp3.ONE, e);
        const inv = Fp3.invertBatch([xd, yd]);
        return { x: Fp3.mul(xn, inv[0]), y: Fp3.mul(yn, inv[1]) };
      }
      var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: Fp3.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha512_1.sha512
      }))();
      exports.hashToCurve = (() => htf.hashToCurve)();
      exports.encodeToCurve = (() => htf.encodeToCurve)();
      function assertRstPoint(other) {
        if (!(other instanceof RistPoint))
          throw new Error("RistrettoPoint expected");
      }
      var SQRT_M1 = ED25519_SQRT_M13;
      var SQRT_AD_MINUS_ONE2 = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D2 = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ2 = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ2 = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      var invertSqrt = (number) => uvRatio3(_1n11, number);
      var MAX_255B2 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      var bytes255ToNumberLE = (bytes2) => exports.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes2) & MAX_255B2);
      function calcElligatorRistrettoMap(r0) {
        const { d } = exports.ed25519.CURVE;
        const P = exports.ed25519.CURVE.Fp.ORDER;
        const mod3 = exports.ed25519.CURVE.Fp.create;
        const r = mod3(SQRT_M1 * r0 * r0);
        const Ns = mod3((r + _1n11) * ONE_MINUS_D_SQ2);
        let c = BigInt(-1);
        const D = mod3((c - d * r) * mod3(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio3(Ns, D);
        let s_ = mod3(s * r0);
        if (!(0, modular_js_1.isNegativeLE)(s_, P))
          s_ = mod3(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod3(c * (r - _1n11) * D_MINUS_ONE_SQ2 - D);
        const s2 = s * s;
        const W0 = mod3((s + s) * D);
        const W1 = mod3(Nt * SQRT_AD_MINUS_ONE2);
        const W2 = mod3(_1n11 - s2);
        const W3 = mod3(_1n11 + s2);
        return new exports.ed25519.ExtendedPoint(mod3(W0 * W3), mod3(W2 * W1), mod3(W1 * W3), mod3(W0 * W2));
      }
      var RistPoint = class _RistPoint {
        // Private property to discourage combining ExtendedPoint + RistrettoPoint
        // Always use Ristretto encoding/decoding instead.
        constructor(ep) {
          this.ep = ep;
        }
        static fromAffine(ap) {
          return new _RistPoint(exports.ed25519.ExtendedPoint.fromAffine(ap));
        }
        /**
         * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
         * The hash-to-group operation applies Elligator twice and adds the results.
         * **Note:** this is one-way map, there is no conversion from point to hash.
         * https://ristretto.group/formulas/elligator.html
         * @param hex 64-byte output of a hash function
         */
        static hashToCurve(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
          const r1 = bytes255ToNumberLE(hex.slice(0, 32));
          const R1 = calcElligatorRistrettoMap(r1);
          const r2 = bytes255ToNumberLE(hex.slice(32, 64));
          const R2 = calcElligatorRistrettoMap(r2);
          return new _RistPoint(R1.add(R2));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * https://ristretto.group/formulas/decoding.html
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex) {
          hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
          const { a, d } = exports.ed25519.CURVE;
          const P = exports.ed25519.CURVE.Fp.ORDER;
          const mod3 = exports.ed25519.CURVE.Fp.create;
          const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
          const s = bytes255ToNumberLE(hex);
          if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
            throw new Error(emsg);
          const s2 = mod3(s * s);
          const u1 = mod3(_1n11 + a * s2);
          const u2 = mod3(_1n11 - a * s2);
          const u1_2 = mod3(u1 * u1);
          const u2_2 = mod3(u2 * u2);
          const v = mod3(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod3(v * u2_2));
          const Dx = mod3(I * u2);
          const Dy = mod3(I * Dx * v);
          let x = mod3((s + s) * Dx);
          if ((0, modular_js_1.isNegativeLE)(x, P))
            x = mod3(-x);
          const y = mod3(u1 * Dy);
          const t = mod3(x * y);
          if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n11)
            throw new Error(emsg);
          return new _RistPoint(new exports.ed25519.ExtendedPoint(x, y, _1n11, t));
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * https://ristretto.group/formulas/encoding.html
         */
        toRawBytes() {
          let { ex: x, ey: y, ez: z, et: t } = this.ep;
          const P = exports.ed25519.CURVE.Fp.ORDER;
          const mod3 = exports.ed25519.CURVE.Fp.create;
          const u1 = mod3(mod3(z + y) * mod3(z - y));
          const u2 = mod3(x * y);
          const u2sq = mod3(u2 * u2);
          const { value: invsqrt } = invertSqrt(mod3(u1 * u2sq));
          const D1 = mod3(invsqrt * u1);
          const D2 = mod3(invsqrt * u2);
          const zInv = mod3(D1 * D2 * t);
          let D;
          if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
            let _x = mod3(y * SQRT_M1);
            let _y = mod3(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod3(D1 * INVSQRT_A_MINUS_D2);
          } else {
            D = D2;
          }
          if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
            y = mod3(-y);
          let s = mod3((z - y) * D);
          if ((0, modular_js_1.isNegativeLE)(s, P))
            s = mod3(-s);
          return (0, utils_js_1.numberToBytesLE)(s, 32);
        }
        toHex() {
          return (0, utils_js_1.bytesToHex)(this.toRawBytes());
        }
        toString() {
          return this.toHex();
        }
        // Compare one point to another.
        equals(other) {
          assertRstPoint(other);
          const { ex: X1, ey: Y1 } = this.ep;
          const { ex: X2, ey: Y2 } = other.ep;
          const mod3 = exports.ed25519.CURVE.Fp.create;
          const one = mod3(X1 * Y2) === mod3(Y1 * X2);
          const two = mod3(Y1 * Y2) === mod3(X1 * X2);
          return one || two;
        }
        add(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.add(other.ep));
        }
        subtract(other) {
          assertRstPoint(other);
          return new _RistPoint(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
          return new _RistPoint(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
          return new _RistPoint(this.ep.multiplyUnsafe(scalar));
        }
      };
      exports.RistrettoPoint = (() => {
        if (!RistPoint.BASE)
          RistPoint.BASE = new RistPoint(exports.ed25519.ExtendedPoint.BASE);
        if (!RistPoint.ZERO)
          RistPoint.ZERO = new RistPoint(exports.ed25519.ExtendedPoint.ZERO);
        return RistPoint;
      })();
      var hashToRistretto255 = (msg, options) => {
        const d = options.DST;
        const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
        const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
        const P = RistPoint.hashToCurve(uniform_bytes);
        return P;
      };
      exports.hashToRistretto255 = hashToRistretto255;
      exports.hash_to_ristretto255 = exports.hashToRistretto255;
    }
  });

  // ../../node_modules/randombytes/browser.js
  var require_browser2 = __commonJS({
    "../../node_modules/randombytes/browser.js"(exports, module) {
      "use strict";
      var MAX_BYTES = 65536;
      var MAX_UINT32 = 4294967295;
      function oldBrowser() {
        throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
      }
      var Buffer2 = require_safe_buffer().Buffer;
      var crypto4 = global.crypto || global.msCrypto;
      if (crypto4 && crypto4.getRandomValues) {
        module.exports = randomBytes3;
      } else {
        module.exports = oldBrowser;
      }
      function randomBytes3(size, cb) {
        if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
        var bytes2 = Buffer2.allocUnsafe(size);
        if (size > 0) {
          if (size > MAX_BYTES) {
            for (var generated = 0; generated < size; generated += MAX_BYTES) {
              crypto4.getRandomValues(bytes2.slice(generated, generated + MAX_BYTES));
            }
          } else {
            crypto4.getRandomValues(bytes2);
          }
        }
        if (typeof cb === "function") {
          return process.nextTick(function() {
            cb(null, bytes2);
          });
        }
        return bytes2;
      }
    }
  });

  // ../../node_modules/secp256k1/lib/index.js
  var require_lib = __commonJS({
    "../../node_modules/secp256k1/lib/index.js"(exports, module) {
      var errors = {
        IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
        TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
        TWEAK_MUL: "The tweak was out of range or equal to zero",
        CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
        SECKEY_INVALID: "Private Key is invalid",
        PUBKEY_PARSE: "Public Key could not be parsed",
        PUBKEY_SERIALIZE: "Public Key serialization error",
        PUBKEY_COMBINE: "The sum of the public keys is not valid",
        SIG_PARSE: "Signature could not be parsed",
        SIGN: "The nonce generation function failed, or the private key was invalid",
        RECOVER: "Public key could not be recover",
        ECDH: "Scalar was invalid (zero or overflow)"
      };
      function assert(cond, msg) {
        if (!cond) throw new Error(msg);
      }
      function isUint8Array(name, value, length) {
        assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);
        if (length !== void 0) {
          if (Array.isArray(length)) {
            const numbers = length.join(", ");
            const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
            assert(length.includes(value.length), msg);
          } else {
            const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
            assert(value.length === length, msg);
          }
        }
      }
      function isCompressed(value) {
        assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
      }
      function getAssertedOutput(output2 = (len) => new Uint8Array(len), length) {
        if (typeof output2 === "function") output2 = output2(length);
        isUint8Array("output", output2, length);
        return output2;
      }
      function toTypeString(value) {
        return Object.prototype.toString.call(value).slice(8, -1);
      }
      module.exports = (secp256k15) => {
        return {
          contextRandomize(seed) {
            assert(
              seed === null || seed instanceof Uint8Array,
              "Expected seed to be an Uint8Array or null"
            );
            if (seed !== null) isUint8Array("seed", seed, 32);
            switch (secp256k15.contextRandomize(seed)) {
              case 1:
                throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
            }
          },
          privateKeyVerify(seckey) {
            isUint8Array("private key", seckey, 32);
            return secp256k15.privateKeyVerify(seckey) === 0;
          },
          privateKeyNegate(seckey) {
            isUint8Array("private key", seckey, 32);
            switch (secp256k15.privateKeyNegate(seckey)) {
              case 0:
                return seckey;
              case 1:
                throw new Error(errors.IMPOSSIBLE_CASE);
            }
          },
          privateKeyTweakAdd(seckey, tweak) {
            isUint8Array("private key", seckey, 32);
            isUint8Array("tweak", tweak, 32);
            switch (secp256k15.privateKeyTweakAdd(seckey, tweak)) {
              case 0:
                return seckey;
              case 1:
                throw new Error(errors.TWEAK_ADD);
            }
          },
          privateKeyTweakMul(seckey, tweak) {
            isUint8Array("private key", seckey, 32);
            isUint8Array("tweak", tweak, 32);
            switch (secp256k15.privateKeyTweakMul(seckey, tweak)) {
              case 0:
                return seckey;
              case 1:
                throw new Error(errors.TWEAK_MUL);
            }
          },
          publicKeyVerify(pubkey) {
            isUint8Array("public key", pubkey, [33, 65]);
            return secp256k15.publicKeyVerify(pubkey) === 0;
          },
          publicKeyCreate(seckey, compressed = true, output2) {
            isUint8Array("private key", seckey, 32);
            isCompressed(compressed);
            output2 = getAssertedOutput(output2, compressed ? 33 : 65);
            switch (secp256k15.publicKeyCreate(output2, seckey)) {
              case 0:
                return output2;
              case 1:
                throw new Error(errors.SECKEY_INVALID);
              case 2:
                throw new Error(errors.PUBKEY_SERIALIZE);
            }
          },
          publicKeyConvert(pubkey, compressed = true, output2) {
            isUint8Array("public key", pubkey, [33, 65]);
            isCompressed(compressed);
            output2 = getAssertedOutput(output2, compressed ? 33 : 65);
            switch (secp256k15.publicKeyConvert(output2, pubkey)) {
              case 0:
                return output2;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.PUBKEY_SERIALIZE);
            }
          },
          publicKeyNegate(pubkey, compressed = true, output2) {
            isUint8Array("public key", pubkey, [33, 65]);
            isCompressed(compressed);
            output2 = getAssertedOutput(output2, compressed ? 33 : 65);
            switch (secp256k15.publicKeyNegate(output2, pubkey)) {
              case 0:
                return output2;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.IMPOSSIBLE_CASE);
              case 3:
                throw new Error(errors.PUBKEY_SERIALIZE);
            }
          },
          publicKeyCombine(pubkeys, compressed = true, output2) {
            assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
            assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
            for (const pubkey of pubkeys) {
              isUint8Array("public key", pubkey, [33, 65]);
            }
            isCompressed(compressed);
            output2 = getAssertedOutput(output2, compressed ? 33 : 65);
            switch (secp256k15.publicKeyCombine(output2, pubkeys)) {
              case 0:
                return output2;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.PUBKEY_COMBINE);
              case 3:
                throw new Error(errors.PUBKEY_SERIALIZE);
            }
          },
          publicKeyTweakAdd(pubkey, tweak, compressed = true, output2) {
            isUint8Array("public key", pubkey, [33, 65]);
            isUint8Array("tweak", tweak, 32);
            isCompressed(compressed);
            output2 = getAssertedOutput(output2, compressed ? 33 : 65);
            switch (secp256k15.publicKeyTweakAdd(output2, pubkey, tweak)) {
              case 0:
                return output2;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.TWEAK_ADD);
            }
          },
          publicKeyTweakMul(pubkey, tweak, compressed = true, output2) {
            isUint8Array("public key", pubkey, [33, 65]);
            isUint8Array("tweak", tweak, 32);
            isCompressed(compressed);
            output2 = getAssertedOutput(output2, compressed ? 33 : 65);
            switch (secp256k15.publicKeyTweakMul(output2, pubkey, tweak)) {
              case 0:
                return output2;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.TWEAK_MUL);
            }
          },
          signatureNormalize(sig) {
            isUint8Array("signature", sig, 64);
            switch (secp256k15.signatureNormalize(sig)) {
              case 0:
                return sig;
              case 1:
                throw new Error(errors.SIG_PARSE);
            }
          },
          signatureExport(sig, output2) {
            isUint8Array("signature", sig, 64);
            output2 = getAssertedOutput(output2, 72);
            const obj = { output: output2, outputlen: 72 };
            switch (secp256k15.signatureExport(obj, sig)) {
              case 0:
                return output2.slice(0, obj.outputlen);
              case 1:
                throw new Error(errors.SIG_PARSE);
              case 2:
                throw new Error(errors.IMPOSSIBLE_CASE);
            }
          },
          signatureImport(sig, output2) {
            isUint8Array("signature", sig);
            output2 = getAssertedOutput(output2, 64);
            switch (secp256k15.signatureImport(output2, sig)) {
              case 0:
                return output2;
              case 1:
                throw new Error(errors.SIG_PARSE);
              case 2:
                throw new Error(errors.IMPOSSIBLE_CASE);
            }
          },
          ecdsaSign(msg32, seckey, options = {}, output2) {
            isUint8Array("message", msg32, 32);
            isUint8Array("private key", seckey, 32);
            assert(toTypeString(options) === "Object", "Expected options to be an Object");
            if (options.data !== void 0) isUint8Array("options.data", options.data);
            if (options.noncefn !== void 0) assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
            output2 = getAssertedOutput(output2, 64);
            const obj = { signature: output2, recid: null };
            switch (secp256k15.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
              case 0:
                return obj;
              case 1:
                throw new Error(errors.SIGN);
              case 2:
                throw new Error(errors.IMPOSSIBLE_CASE);
            }
          },
          ecdsaVerify(sig, msg32, pubkey) {
            isUint8Array("signature", sig, 64);
            isUint8Array("message", msg32, 32);
            isUint8Array("public key", pubkey, [33, 65]);
            switch (secp256k15.ecdsaVerify(sig, msg32, pubkey)) {
              case 0:
                return true;
              case 3:
                return false;
              case 1:
                throw new Error(errors.SIG_PARSE);
              case 2:
                throw new Error(errors.PUBKEY_PARSE);
            }
          },
          ecdsaRecover(sig, recid, msg32, compressed = true, output2) {
            isUint8Array("signature", sig, 64);
            assert(
              toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
              "Expected recovery id to be a Number within interval [0, 3]"
            );
            isUint8Array("message", msg32, 32);
            isCompressed(compressed);
            output2 = getAssertedOutput(output2, compressed ? 33 : 65);
            switch (secp256k15.ecdsaRecover(output2, sig, recid, msg32)) {
              case 0:
                return output2;
              case 1:
                throw new Error(errors.SIG_PARSE);
              case 2:
                throw new Error(errors.RECOVER);
              case 3:
                throw new Error(errors.IMPOSSIBLE_CASE);
            }
          },
          ecdh(pubkey, seckey, options = {}, output2) {
            isUint8Array("public key", pubkey, [33, 65]);
            isUint8Array("private key", seckey, 32);
            assert(toTypeString(options) === "Object", "Expected options to be an Object");
            if (options.data !== void 0) isUint8Array("options.data", options.data);
            if (options.hashfn !== void 0) {
              assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
              if (options.xbuf !== void 0) isUint8Array("options.xbuf", options.xbuf, 32);
              if (options.ybuf !== void 0) isUint8Array("options.ybuf", options.ybuf, 32);
              isUint8Array("output", output2);
            } else {
              output2 = getAssertedOutput(output2, 32);
            }
            switch (secp256k15.ecdh(output2, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
              case 0:
                return output2;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.ECDH);
            }
          }
        };
      };
    }
  });

  // ../../node_modules/elliptic/package.json
  var require_package = __commonJS({
    "../../node_modules/elliptic/package.json"(exports, module) {
      module.exports = {
        name: "elliptic",
        version: "6.6.1",
        description: "EC cryptography",
        main: "lib/elliptic.js",
        files: [
          "lib"
        ],
        scripts: {
          lint: "eslint lib test",
          "lint:fix": "npm run lint -- --fix",
          unit: "istanbul test _mocha --reporter=spec test/index.js",
          test: "npm run lint && npm run unit",
          version: "grunt dist && git add dist/"
        },
        repository: {
          type: "git",
          url: "git@github.com:indutny/elliptic"
        },
        keywords: [
          "EC",
          "Elliptic",
          "curve",
          "Cryptography"
        ],
        author: "Fedor Indutny <fedor@indutny.com>",
        license: "MIT",
        bugs: {
          url: "https://github.com/indutny/elliptic/issues"
        },
        homepage: "https://github.com/indutny/elliptic",
        devDependencies: {
          brfs: "^2.0.2",
          coveralls: "^3.1.0",
          eslint: "^7.6.0",
          grunt: "^1.2.1",
          "grunt-browserify": "^5.3.0",
          "grunt-cli": "^1.3.2",
          "grunt-contrib-connect": "^3.0.0",
          "grunt-contrib-copy": "^1.0.0",
          "grunt-contrib-uglify": "^5.0.0",
          "grunt-mocha-istanbul": "^5.0.2",
          "grunt-saucelabs": "^9.0.1",
          istanbul: "^0.4.5",
          mocha: "^8.0.1"
        },
        dependencies: {
          "bn.js": "^4.11.9",
          brorand: "^1.1.0",
          "hash.js": "^1.0.0",
          "hmac-drbg": "^1.0.1",
          inherits: "^2.0.4",
          "minimalistic-assert": "^1.0.1",
          "minimalistic-crypto-utils": "^1.0.1"
        }
      };
    }
  });

  // ../../node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "../../node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert(val, msg) {
          if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base2, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base2 === "le" || base2 === "be") {
              endian = base2;
              base2 = 10;
            }
            this._init(number || 0, base2 || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN;
        } else {
          exports2.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = __require("buffer").Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0) return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0) return left;
          return right;
        };
        BN.prototype._init = function init(number, base2, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base2, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base2, endian);
          }
          if (base2 === "hex") {
            base2 = 16;
          }
          assert(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base2 === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base2, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base2, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base2, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le") return;
          this._initArray(this.toArray(), base2, endian);
        };
        BN.prototype._initArray = function _initArray(number, base2, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base2, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base2 | 0;
          var total = number.length - start;
          var mod3 = total % limbLen;
          var end = Math.min(total, total - mod3) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base2);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod3 !== 0) {
            var pow4 = 1;
            word = parseBase(number, i, number.length, base2);
            for (i = 0; i < mod3; i++) {
              pow4 *= base2;
            }
            this.imuln(pow4);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString(base2, padding) {
          base2 = base2 || 10;
          padding = padding | 0 || 1;
          var out;
          if (base2 === 16 || base2 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
            var groupSize = groupSizes[base2];
            var groupBase = groupBases[base2];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base2);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0) return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero()) return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length) return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length) return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length) return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length) return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length) return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length) return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add3(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length) return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1) return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1) return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow4(num) {
          var w = toBitArray(num);
          if (w.length === 0) return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0) break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0) continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0) return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0) return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0) return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod3, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod3 = res.mod.neg();
              if (positive && mod3.negative !== 0) {
                mod3.iadd(num);
              }
            }
            return {
              div,
              mod: mod3
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod3 = res.mod.neg();
              if (positive && mod3.negative !== 0) {
                mod3.isub(num);
              }
            }
            return {
              div: res.div,
              mod: mod3
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod3(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero()) return dm.div;
          var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod3.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero()) return num.abs();
          if (num.isZero()) return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative) return -1;
          if (this.negative === 0 && negative) return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0) return -1;
          if (this.negative === 0 && num.negative !== 0) return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length) return 1;
          if (this.length < num.length) return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split3(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split3(input, output2) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output2.words[i] = input.words[i];
          }
          output2.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output2.words[output2.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name]) return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime) return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add3(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero()) return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow4 = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow4);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow4(a, num) {
          if (num.isZero()) return new BN(1).toRed(this);
          if (num.cmpn(1) === 0) return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // ../../node_modules/minimalistic-assert/index.js
  var require_minimalistic_assert = __commonJS({
    "../../node_modules/minimalistic-assert/index.js"(exports, module) {
      module.exports = assert;
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
    }
  });

  // ../../node_modules/minimalistic-crypto-utils/lib/utils.js
  var require_utils4 = __commonJS({
    "../../node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
      "use strict";
      var utils = exports;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        } else {
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            var hi = c >> 8;
            var lo = c & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      utils.toHex = toHex;
      utils.encode = function encode(arr, enc) {
        if (enc === "hex")
          return toHex(arr);
        else
          return arr;
      };
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/utils.js
  var require_utils5 = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/utils.js"(exports) {
      "use strict";
      var utils = exports;
      var BN = require_bn();
      var minAssert = require_minimalistic_assert();
      var minUtils = require_utils4();
      utils.assert = minAssert;
      utils.toArray = minUtils.toArray;
      utils.zero2 = minUtils.zero2;
      utils.toHex = minUtils.toHex;
      utils.encode = minUtils.encode;
      function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        var i;
        for (i = 0; i < naf.length; i += 1) {
          naf[i] = 0;
        }
        var ws = 1 << w + 1;
        var k = num.clone();
        for (i = 0; i < naf.length; i++) {
          var z;
          var mod3 = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod3 > (ws >> 1) - 1)
              z = (ws >> 1) - mod3;
            else
              z = mod3;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF;
      function getJSF(k1, k2) {
        var jsf = [
          [],
          []
        ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF;
      function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty2() {
          return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes2) {
        return typeof bytes2 === "string" ? utils.toArray(bytes2, "hex") : bytes2;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes2) {
        return new BN(bytes2, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    }
  });

  // ../../node_modules/brorand/index.js
  var require_brorand = __commonJS({
    "../../node_modules/brorand/index.js"(exports, module) {
      var r;
      module.exports = function rand(len) {
        if (!r)
          r = new Rand(null);
        return r.generate(len);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      module.exports.Rand = Rand;
      Rand.prototype.generate = function generate(len) {
        return this._rand(len);
      };
      Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++)
          res[i] = this.rand.getByte();
        return res;
      };
      if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.crypto.getRandomValues(arr);
            return arr;
          };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.msCrypto.getRandomValues(arr);
            return arr;
          };
        } else if (typeof window === "object") {
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      } else {
        try {
          crypto4 = __require("crypto");
          if (typeof crypto4.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n) {
            return crypto4.randomBytes(n);
          };
        } catch (e) {
        }
      }
      var crypto4;
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/curve/base.js
  var require_base = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var utils = require_utils5();
      var getNAF = utils.getNAF;
      var getJSF = utils.getJSF;
      var assert = utils.assert;
      function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN(conf.p, 16);
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.zero = new BN(0).toRed(this.red);
        this.one = new BN(1).toRed(this.red);
        this.two = new BN(2).toRed(this.red);
        this.n = conf.n && new BN(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
          this.redN = null;
        } else {
          this._maxwellTrick = true;
          this.redN = this.n.toRed(this.red);
        }
      }
      module.exports = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1, this._bitLength);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        var j;
        var nafW;
        for (j = 0; j < naf.length; j += doubles.step) {
          nafW = 0;
          for (var l = j + doubles.step - 1; l >= j; l--)
            nafW = (nafW << 1) + naf[l];
          repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
          for (j = 0; j < repr.length; j++) {
            nafW = repr[j];
            if (nafW === i)
              b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i)
              b = b.mixedAdd(doubles.points[j].neg());
          }
          a = a.add(b);
        }
        return a.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
          for (var l = 0; i >= 0 && naf[i] === 0; i--)
            l++;
          if (i >= 0)
            l++;
          acc = acc.dblp(l);
          if (i < 0)
            break;
          var z = naf[i];
          assert(z !== 0);
          if (p.type === "affine") {
            if (z > 0)
              acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
          } else {
            if (z > 0)
              acc = acc.add(wnd[z - 1 >> 1]);
            else
              acc = acc.add(wnd[-z - 1 >> 1].neg());
          }
        }
        return p.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        var i;
        var j;
        var p;
        for (i = 0; i < len; i++) {
          p = points[i];
          var nafPoints = p._getNAFPoints(defW);
          wndWidth[i] = nafPoints.wnd;
          wnd[i] = nafPoints.points;
        }
        for (i = len - 1; i >= 1; i -= 2) {
          var a = i - 1;
          var b = i;
          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
          }
          var comb = [
            points[a],
            /* 1 */
            null,
            /* 3 */
            null,
            /* 5 */
            points[b]
            /* 7 */
          ];
          if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          }
          var index = [
            -3,
            /* -1 -1 */
            -1,
            /* -1 0 */
            -5,
            /* -1 1 */
            -7,
            /* 0 -1 */
            0,
            /* 0 0 */
            7,
            /* 0 1 */
            5,
            /* 1 -1 */
            1,
            /* 1 0 */
            3
            /* 1 1 */
          ];
          var jsf = getJSF(coeffs[a], coeffs[b]);
          max = Math.max(jsf[0].length, max);
          naf[a] = new Array(max);
          naf[b] = new Array(max);
          for (j = 0; j < max; j++) {
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
          }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (i = max; i >= 0; i--) {
          var k = 0;
          while (i >= 0) {
            var zero = true;
            for (j = 0; j < len; j++) {
              tmp[j] = naf[j][i] | 0;
              if (tmp[j] !== 0)
                zero = false;
            }
            if (!zero)
              break;
            k++;
            i--;
          }
          if (i >= 0)
            k++;
          acc = acc.dblp(k);
          if (i < 0)
            break;
          for (j = 0; j < len; j++) {
            var z = tmp[j];
            p;
            if (z === 0)
              continue;
            else if (z > 0)
              p = wnd[j][z - 1 >> 1];
            else if (z < 0)
              p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine")
              acc = acc.mixedAdd(p);
            else
              acc = acc.add(p);
          }
        }
        for (i = 0; i < len; i++)
          wnd[i] = null;
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
        bytes2 = utils.toArray(bytes2, enc);
        var len = this.p.byteLength();
        if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len) {
          if (bytes2[0] === 6)
            assert(bytes2[bytes2.length - 1] % 2 === 0);
          else if (bytes2[0] === 7)
            assert(bytes2[bytes2.length - 1] % 2 === 1);
          var res = this.point(
            bytes2.slice(1, 1 + len),
            bytes2.slice(1 + len, 1 + 2 * len)
          );
          return res;
        } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len) {
          return this.pointFromX(bytes2.slice(1, 1 + len), bytes2[0] === 3);
        }
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact)
          return [this.getY().isEven() ? 2 : 3].concat(x);
        return [4].concat(x, this.getY().toArray("be", len));
      };
      BasePoint.prototype.encode = function encode(enc, compact) {
        return utils.encode(this._encode(compact), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = {
          doubles: null,
          naf: null,
          beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this];
        var acc = this;
        for (var i = 0; i < power; i += step) {
          for (var j = 0; j < step; j++)
            acc = acc.dbl();
          doubles.push(acc);
        }
        return {
          step,
          points: doubles
        };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++)
          res[i] = res[i - 1].add(dbl);
        return {
          wnd,
          points: res
        };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++)
          r = r.dbl();
        return r;
      };
    }
  });

  // ../../node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "../../node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/curve/short.js
  var require_short = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      var BN = require_bn();
      var inherits = require_inherits_browser();
      var Base = require_base();
      var assert = utils.assert;
      function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
      }
      inherits(ShortCurve, Base);
      module.exports = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta;
        var lambda;
        if (conf.beta) {
          beta = new BN(conf.beta, 16).toRed(this.red);
        } else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
          beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
          lambda = new BN(conf.lambda, 16);
        } else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
            lambda = lambdas[0];
          } else {
            lambda = lambdas[1];
            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
          }
        }
        var basis;
        if (conf.basis) {
          basis = conf.basis.map(function(vec) {
            return {
              a: new BN(vec.a, 16),
              b: new BN(vec.b, 16)
            };
          });
        } else {
          basis = this._getEndoBasis(lambda);
        }
        return {
          beta,
          lambda,
          basis
        };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num);
        var tinv = new BN(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new BN(1);
        var y1 = new BN(0);
        var x2 = new BN(0);
        var y2 = new BN(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
          var q = v.div(u);
          r = v.sub(q.mul(u));
          x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1));
          if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
          } else if (a1 && ++i === 2) {
            break;
          }
          prevR = r;
          v = u;
          u = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
          a2 = a0;
          b2 = b0;
        }
        if (a1.negative) {
          a1 = a1.neg();
          b1 = b1.neg();
        }
        if (a2.negative) {
          a2 = a2.neg();
          b2 = b2.neg();
        }
        return [
          { a: a1, b: b1 },
          { a: a2, b: b2 }
        ];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return { k1, k2 };
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
          return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split3 = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();
          if (split3.k1.negative) {
            split3.k1.ineg();
            p = p.neg(true);
          }
          if (split3.k2.negative) {
            split3.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split3.k1;
          ncoeffs[i * 2 + 1] = split3.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };
      function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
          this.x = null;
          this.y = null;
          this.inf = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
          }
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits(Point, Base.BasePoint);
      ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
      };
      Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve = this.curve;
          var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
          };
          pre.beta = beta;
          beta.precomputed = {
            beta: null,
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(endoMul)
            }
          };
        }
        return beta;
      };
      Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
          }
        }];
      };
      Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve.point(obj2[0], obj2[1], red);
        }
        var pre = obj[2];
        res.precomputed = {
          beta: null,
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [res].concat(pre.doubles.points.map(obj2point))
          },
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [res].concat(pre.naf.points.map(obj2point))
          }
        };
        return res;
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point.prototype.add = function add3(p) {
        if (this.inf)
          return p;
        if (p.inf)
          return this;
        if (this.eq(p))
          return this.dbl();
        if (this.neg().eq(p))
          return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0)
          return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
          c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point.prototype.mul = function mul(k) {
        k = new BN(k, 16);
        if (this.isInfinity())
          return this;
        else if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k]);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
      };
      Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed;
          var negate = function(p) {
            return p.neg();
          };
          res.precomputed = {
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(negate)
            }
          };
        }
        return res;
      };
      Point.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
          this.x = this.curve.one;
          this.y = this.curve.one;
          this.z = new BN(0);
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = new BN(z, 16);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits(JPoint, Base.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add3(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity())
          return p.toJ();
        if (p.isInfinity())
          return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow4) {
        if (pow4 === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow4)
          return this.dbl();
        var i;
        if (this.curve.zeroA || this.curve.threeA) {
          var r = this;
          for (i = 0; i < pow4; i++)
            r = r.dbl();
          return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (i = 0; i < pow4; i++) {
          var jx2 = jx.redSqr();
          var jyd2 = jyd.redSqr();
          var jyd4 = jyd2.redSqr();
          var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
          var t1 = jx.redMul(jyd2);
          var nx = c.redSqr().redISub(t1.redAdd(t1));
          var t2 = t1.redISub(nx);
          var dny = c.redMul(t2);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i + 1 < pow4)
            jz4 = jz4.redMul(jyd4);
          jx = nx;
          jz = nz;
          jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx);
          var t = m.redSqr().redISub(s).redISub(s);
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          nx = t;
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var a = this.x.redSqr();
          var b = this.y.redSqr();
          var c = b.redSqr();
          var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
          d = d.redIAdd(d);
          var e = a.redAdd(a).redIAdd(a);
          var f = e.redSqr();
          var c8 = c.redIAdd(c);
          c8 = c8.redIAdd(c8);
          c8 = c8.redIAdd(c8);
          nx = f.redISub(d).redISub(d);
          ny = e.redMul(d.redISub(nx)).redISub(c8);
          nz = this.y.redMul(this.z);
          nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
          var t = m.redSqr().redISub(s).redISub(s);
          nx = t;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr();
          var gamma = this.y.redSqr();
          var beta = this.x.redMul(gamma);
          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8);
          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN(k, kbase);
        return this.curve._wnafMul(this, k);
      };
      JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine")
          return this.eq(p.toJ());
        if (this === p)
          return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
          return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(zs);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/curve/mont.js
  var require_mont = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var inherits = require_inherits_browser();
      var Base = require_base();
      var utils = require_utils5();
      function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.i4 = new BN(4).toRed(this.red).redInvm();
        this.two = new BN(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits(MontCurve, Base);
      module.exports = MontCurve;
      MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
      };
      function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
          this.x = this.curve.one;
          this.z = this.curve.zero;
        } else {
          this.x = new BN(x, 16);
          this.z = new BN(z, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits(Point, Base.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
        return this.point(utils.toArray(bytes2, enc), 1);
      };
      MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      Point.prototype.precompute = function precompute() {
      };
      Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
      };
      Point.prototype.add = function add3() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
          bits.push(t.andln(1));
        for (var i = bits.length - 1; i >= 0; i--) {
          if (bits[i] === 0) {
            a = a.diffAdd(b, c);
            b = b.dbl();
          } else {
            b = a.diffAdd(b, c);
            a = a.dbl();
          }
        }
        return b;
      };
      Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/curve/edwards.js
  var require_edwards2 = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      var BN = require_bn();
      var inherits = require_inherits_browser();
      var Base = require_base();
      var assert = utils.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
      }
      inherits(EdwardsCurve, Base);
      module.exports = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN(y, 16);
        if (!y.red)
          y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.c2);
        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd)
          x = x.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
      };
      function Point(curve, x, y, z, t) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
          this.x = this.curve.zero;
          this.y = this.curve.one;
          this.z = this.curve.one;
          this.t = this.curve.zero;
          this.zOne = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = z ? new BN(z, 16) : this.curve.one;
          this.t = t && new BN(t, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          this.zOne = this.z === this.curve.one;
          if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits(Point, Base.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f = g.redSub(c);
        var h = d.redSub(b);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        var e;
        var h;
        var j;
        if (this.curve.twisted) {
          e = this.curve._mulA(c);
          var f = e.redAdd(d);
          if (this.zOne) {
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            ny = f.redMul(e.redSub(d));
            nz = f.redSqr().redSub(f).redSub(f);
          } else {
            h = this.z.redSqr();
            j = f.redSub(h).redISub(h);
            nx = b.redSub(c).redISub(d).redMul(j);
            ny = f.redMul(e.redSub(d));
            nz = f.redMul(j);
          }
        } else {
          e = c.redAdd(d);
          h = this.curve._mulC(this.z).redSqr();
          j = e.redSub(h).redSub(h);
          nx = this.curve._mulC(b.redISub(e)).redMul(j);
          ny = this.curve._mulC(e).redMul(c.redISub(d));
          nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f = d.redSub(c);
        var g = d.redAdd(c);
        var h = b.redAdd(a);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
          nz = f.redMul(g);
        } else {
          ny = a.redMul(g).redMul(d.redSub(c));
          nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.add = function add3(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p);
        else
          return this._projAdd(p);
      };
      Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
      };
      Point.prototype.normalize = function normalize() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
          this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
      };
      Point.prototype.neg = function neg() {
        return this.curve.point(
          this.x.redNeg(),
          this.y,
          this.z,
          this.t && this.t.redNeg()
        );
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
      };
      Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(this.z);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point.prototype.toP = Point.prototype.normalize;
      Point.prototype.mixedAdd = Point.prototype.add;
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/curve/index.js
  var require_curve2 = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
      "use strict";
      var curve = exports;
      curve.base = require_base();
      curve.short = require_short();
      curve.mont = require_mont();
      curve.edwards = require_edwards2();
    }
  });

  // ../../node_modules/hash.js/lib/hash/utils.js
  var require_utils6 = __commonJS({
    "../../node_modules/hash.js/lib/hash/utils.js"(exports) {
      "use strict";
      var assert = require_minimalistic_assert();
      var inherits = require_inherits_browser();
      exports.inherits = inherits;
      function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
          return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              if (c < 128) {
                res[p++] = c;
              } else if (c < 2048) {
                res[p++] = c >> 6 | 192;
                res[p++] = c & 63 | 128;
              } else if (isSurrogatePair(msg, i)) {
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                res[p++] = c >> 18 | 240;
                res[p++] = c >> 12 & 63 | 128;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              } else {
                res[p++] = c >> 12 | 224;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i = 0; i < msg.length; i += 2)
              res.push(parseInt(msg[i] + msg[i + 1], 16));
          }
        } else {
          for (i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
        }
        return res;
      }
      exports.toArray = toArray;
      function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      exports.toHex = toHex;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      exports.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          var w = msg[i];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      exports.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i] = w >>> 0;
        }
        return res;
      }
      exports.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
          var m = msg[i];
          if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 255;
            res[k + 2] = m >>> 8 & 255;
            res[k + 3] = m & 255;
          } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 255;
            res[k + 1] = m >>> 8 & 255;
            res[k] = m & 255;
          }
        }
        return res;
      }
      exports.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      exports.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      exports.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      exports.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      exports.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      exports.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      exports.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
      }
      exports.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      exports.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
      }
      exports.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
      }
      exports.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      exports.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports.shr64_lo = shr64_lo;
    }
  });

  // ../../node_modules/hash.js/lib/hash/common.js
  var require_common = __commonJS({
    "../../node_modules/hash.js/lib/hash/common.js"(exports) {
      "use strict";
      var utils = require_utils6();
      var assert = require_minimalistic_assert();
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r, this.endian);
          for (var i = 0; i < msg.length; i += this._delta32)
            this._update(msg, i, i + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes2 = this._delta8;
        var k = bytes2 - (len + this.padLength) % bytes2;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++)
          res[i] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t = 8; t < this.padLength; t++)
            res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = len >>> 24 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len & 255;
        } else {
          res[i++] = len & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 24 & 255;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          for (t = 8; t < this.padLength; t++)
            res[i++] = 0;
        }
        return res;
      };
    }
  });

  // ../../node_modules/hash.js/lib/hash/sha/common.js
  var require_common2 = __commonJS({
    "../../node_modules/hash.js/lib/hash/sha/common.js"(exports) {
      "use strict";
      var utils = require_utils6();
      var rotr32 = utils.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      exports.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      exports.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      exports.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      exports.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      exports.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      exports.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      exports.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      exports.g1_256 = g1_256;
    }
  });

  // ../../node_modules/hash.js/lib/hash/sha/1.js
  var require__ = __commonJS({
    "../../node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
      "use strict";
      var utils = require_utils6();
      var common = require_common();
      var shaCommon = require_common2();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_5 = utils.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
      ];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [
          1732584193,
          4023233417,
          2562383102,
          271733878,
          3285377520
        ];
        this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
          var s = ~~(i / 20);
          var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
          e = d;
          d = c;
          c = rotl32(b, 30);
          b = a;
          a = t;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // ../../node_modules/hash.js/lib/hash/sha/256.js
  var require__2 = __commonJS({
    "../../node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
      "use strict";
      var utils = require_utils6();
      var common = require_common();
      var shaCommon = require_common2();
      var assert = require_minimalistic_assert();
      var sum32 = utils.sum32;
      var sum32_4 = utils.sum32_4;
      var sum32_5 = utils.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function SHA2562() {
        if (!(this instanceof SHA2562))
          return new SHA2562();
        BlockHash.call(this);
        this.h = [
          1779033703,
          3144134277,
          1013904242,
          2773480762,
          1359893119,
          2600822924,
          528734635,
          1541459225
        ];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils.inherits(SHA2562, BlockHash);
      module.exports = SHA2562;
      SHA2562.blockSize = 512;
      SHA2562.outSize = 256;
      SHA2562.hmacStrength = 192;
      SHA2562.padLength = 64;
      SHA2562.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h = this.h[7];
        assert(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
          var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
          var T2 = sum32(s0_256(a), maj32(a, b, c));
          h = g;
          g = f;
          f = e;
          e = sum32(d, T1);
          d = c;
          c = b;
          b = a;
          a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h);
      };
      SHA2562.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // ../../node_modules/hash.js/lib/hash/sha/224.js
  var require__3 = __commonJS({
    "../../node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
      "use strict";
      var utils = require_utils6();
      var SHA2562 = require__2();
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA2562.call(this);
        this.h = [
          3238371032,
          914150663,
          812702999,
          4144912697,
          4290775857,
          1750603025,
          1694076839,
          3204075428
        ];
      }
      utils.inherits(SHA224, SHA2562);
      module.exports = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    }
  });

  // ../../node_modules/hash.js/lib/hash/sha/512.js
  var require__4 = __commonJS({
    "../../node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
      "use strict";
      var utils = require_utils6();
      var common = require_common();
      var assert = require_minimalistic_assert();
      var rotr64_hi = utils.rotr64_hi;
      var rotr64_lo = utils.rotr64_lo;
      var shr64_hi = utils.shr64_hi;
      var shr64_lo = utils.shr64_lo;
      var sum64 = utils.sum64;
      var sum64_hi = utils.sum64_hi;
      var sum64_lo = utils.sum64_lo;
      var sum64_4_hi = utils.sum64_4_hi;
      var sum64_4_lo = utils.sum64_4_lo;
      var sum64_5_hi = utils.sum64_5_hi;
      var sum64_5_lo = utils.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function SHA5123() {
        if (!(this instanceof SHA5123))
          return new SHA5123();
        BlockHash.call(this);
        this.h = [
          1779033703,
          4089235720,
          3144134277,
          2227873595,
          1013904242,
          4271175723,
          2773480762,
          1595750129,
          1359893119,
          2917565137,
          2600822924,
          725511199,
          528734635,
          4215389547,
          1541459225,
          327033209
        ];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils.inherits(SHA5123, BlockHash);
      module.exports = SHA5123;
      SHA5123.blockSize = 1024;
      SHA5123.outSize = 512;
      SHA5123.hmacStrength = 192;
      SHA5123.padLength = 128;
      SHA5123.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i] = sum64_4_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
          W[i + 1] = sum64_4_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
        }
      };
      SHA5123.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i];
          var c3_lo = this.k[i + 1];
          var c4_hi = W[i];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          var T1_lo = sum64_5_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA5123.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
    }
  });

  // ../../node_modules/hash.js/lib/hash/sha/384.js
  var require__5 = __commonJS({
    "../../node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
      "use strict";
      var utils = require_utils6();
      var SHA5123 = require__4();
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA5123.call(this);
        this.h = [
          3418070365,
          3238371032,
          1654270250,
          914150663,
          2438529370,
          812702999,
          355462360,
          4144912697,
          1731405415,
          4290775857,
          2394180231,
          1750603025,
          3675008525,
          1694076839,
          1203062813,
          3204075428
        ];
      }
      utils.inherits(SHA384, SHA5123);
      module.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    }
  });

  // ../../node_modules/hash.js/lib/hash/sha.js
  var require_sha = __commonJS({
    "../../node_modules/hash.js/lib/hash/sha.js"(exports) {
      "use strict";
      exports.sha1 = require__();
      exports.sha224 = require__3();
      exports.sha256 = require__2();
      exports.sha384 = require__5();
      exports.sha512 = require__4();
    }
  });

  // ../../node_modules/hash.js/lib/hash/ripemd.js
  var require_ripemd = __commonJS({
    "../../node_modules/hash.js/lib/hash/ripemd.js"(exports) {
      "use strict";
      var utils = require_utils6();
      var common = require_common();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_3 = utils.sum32_3;
      var sum32_4 = utils.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils.inherits(RIPEMD160, BlockHash);
      exports.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
          var T = sum32(
            rotl32(
              sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
              s[j]
            ),
            E
          );
          A = E;
          E = D;
          D = rotl32(C, 10);
          C = B;
          B = T;
          T = sum32(
            rotl32(
              sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
              sh[j]
            ),
            Eh
          );
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var rh = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var s = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sh = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
    }
  });

  // ../../node_modules/hash.js/lib/hash/hmac.js
  var require_hmac = __commonJS({
    "../../node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
      "use strict";
      var utils = require_utils6();
      var assert = require_minimalistic_assert();
      function Hmac(hash, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash, key, enc);
        this.Hash = hash;
        this.blockSize = hash.blockSize / 8;
        this.outSize = hash.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key, enc));
      }
      module.exports = Hmac;
      Hmac.prototype._init = function init(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++)
          key.push(0);
        for (i = 0; i < key.length; i++)
          key[i] ^= 54;
        this.inner = new this.Hash().update(key);
        for (i = 0; i < key.length; i++)
          key[i] ^= 106;
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }
  });

  // ../../node_modules/hash.js/lib/hash.js
  var require_hash = __commonJS({
    "../../node_modules/hash.js/lib/hash.js"(exports) {
      var hash = exports;
      hash.utils = require_utils6();
      hash.common = require_common();
      hash.sha = require_sha();
      hash.ripemd = require_ripemd();
      hash.hmac = require_hmac();
      hash.sha1 = hash.sha.sha1;
      hash.sha256 = hash.sha.sha256;
      hash.sha224 = hash.sha.sha224;
      hash.sha384 = hash.sha.sha384;
      hash.sha512 = hash.sha.sha512;
      hash.ripemd160 = hash.ripemd.ripemd160;
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
  var require_secp256k1 = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
      module.exports = {
        doubles: {
          step: 4,
          points: [
            [
              "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
              "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
              "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
              "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
              "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
              "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
              "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
              "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
              "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
              "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
              "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
              "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
              "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
              "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
              "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
              "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
              "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
              "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
              "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
              "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
              "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
              "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
              "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
              "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
              "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
              "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
              "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
              "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
              "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
              "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
              "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
              "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
              "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
              "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
              "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
              "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
              "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
              "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
              "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
              "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
              "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
              "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
              "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
              "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
              "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
              "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
              "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
              "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
              "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
              "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
              "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
              "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
              "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
              "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
              "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
              "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
              "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
              "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
              "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
              "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
              "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
              "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
              "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
              "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
              "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
              "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
              "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
              "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
              "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
              "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
              "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
              "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
              "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
              "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
              "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
              "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
              "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
              "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
              "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
              "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
              "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
              "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
              "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
              "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
              "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
              "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
              "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
              "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
              "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
              "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
              "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
              "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
              "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
              "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
              "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
              "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
              "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
              "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
              "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
              "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
              "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
              "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
              "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
              "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
              "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
              "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
              "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
              "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
              "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
              "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
              "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
              "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
              "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
              "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
              "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
              "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
              "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
              "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
              "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
              "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
              "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
              "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
              "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
              "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
              "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
              "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
              "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
              "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
              "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
              "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
          ]
        },
        naf: {
          wnd: 7,
          points: [
            [
              "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
              "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
              "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
              "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
              "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
              "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
              "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
              "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
              "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
              "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
              "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
              "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
              "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
              "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
              "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
              "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
              "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
              "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
              "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
              "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
              "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
              "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
              "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
              "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
              "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
              "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
              "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
              "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
              "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
              "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
              "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
              "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
              "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
              "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
              "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
              "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
              "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
              "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
              "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
              "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
              "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
              "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
              "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
              "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
              "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
              "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
              "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
              "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
              "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
              "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
              "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
              "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
              "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
              "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
              "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
              "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
              "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
              "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
              "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
              "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
              "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
              "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
              "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
              "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
              "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
              "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
              "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
              "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
              "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
              "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
              "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
              "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
              "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
              "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
              "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
              "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
              "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
              "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
              "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
              "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
              "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
              "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
              "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
              "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
              "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
              "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
              "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
              "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
              "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
              "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
              "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
              "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
              "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
              "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
              "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
              "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
              "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
              "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
              "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
              "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
              "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
              "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
              "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
              "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
              "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
              "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
              "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
              "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
              "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
              "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
              "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
              "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
              "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
              "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
              "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
              "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
              "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
              "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
              "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
              "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
              "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
              "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
              "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
              "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
              "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
              "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
              "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
              "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
              "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
              "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
              "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
              "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
              "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
              "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
              "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
              "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
              "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
              "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
              "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
              "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
              "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
              "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
              "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
              "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
              "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
              "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
              "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
              "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
              "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
              "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
              "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
              "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
              "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
              "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
              "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
              "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
              "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
              "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
              "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
              "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
              "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
              "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
              "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
              "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
              "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
              "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
              "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
              "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
              "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
              "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
              "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
              "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
              "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
              "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
              "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
              "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
              "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
              "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
              "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
              "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
              "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
              "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
              "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
              "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
              "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
              "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
              "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
              "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
              "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
              "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
              "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
              "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
              "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
              "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
              "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
              "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
              "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
              "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
              "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
              "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
              "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
              "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
              "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
              "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
              "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
              "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
              "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
              "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
              "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
              "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
              "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
              "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
              "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
              "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
              "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
              "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
              "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
              "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
              "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
              "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
              "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
              "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
              "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
              "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
              "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
              "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
              "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
              "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
              "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
              "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
              "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
              "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
              "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
              "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
              "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
              "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
              "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
              "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
              "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
              "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
              "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
              "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
              "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
              "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
              "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
              "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
              "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
              "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
              "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
              "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
              "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
              "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
              "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
              "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
          ]
        }
      };
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/curves.js
  var require_curves = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/curves.js"(exports) {
      "use strict";
      var curves = exports;
      var hash = require_hash();
      var curve = require_curve2();
      var utils = require_utils5();
      var assert = utils.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve.short(options);
        else if (options.type === "edwards")
          this.curve = new curve.edwards(options);
        else
          this.curve = new curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert(this.g.validate(), "Invalid curve");
        assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve2 = new PresetCurve(options);
            Object.defineProperty(curves, name, {
              configurable: true,
              enumerable: true,
              value: curve2
            });
            return curve2;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: hash.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: hash.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: hash.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: hash.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: hash.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          // 4/5
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = require_secp256k1();
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash.sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre
        ]
      });
    }
  });

  // ../../node_modules/hmac-drbg/lib/hmac-drbg.js
  var require_hmac_drbg = __commonJS({
    "../../node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
      "use strict";
      var hash = require_hash();
      var utils = require_utils4();
      var assert = require_minimalistic_assert();
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils.toArray(options.pers, options.persEnc || "hex");
        assert(
          entropy.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        );
        this._init(entropy, nonce, pers);
      }
      module.exports = HmacDRBG;
      HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
          this.K[i] = 0;
          this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac() {
        return new hash.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
        if (typeof entropyEnc !== "string") {
          addEnc = add3;
          add3 = entropyEnc;
          entropyEnc = null;
        }
        entropy = utils.toArray(entropy, entropyEnc);
        add3 = utils.toArray(add3, addEnc);
        assert(
          entropy.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        );
        this._update(entropy.concat(add3 || []));
        this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string") {
          addEnc = add3;
          add3 = enc;
          enc = null;
        }
        if (add3) {
          add3 = utils.toArray(add3, addEnc || "hex");
          this._update(add3);
        }
        var temp = [];
        while (temp.length < len) {
          this.V = this._hmac().update(this.V).digest();
          temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add3);
        this._reseed++;
        return utils.encode(res, enc);
      };
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/ec/key.js
  var require_key = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var utils = require_utils5();
      var assert = utils.assert;
      function KeyPair3(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      module.exports = KeyPair3;
      KeyPair3.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair3)
          return pub;
        return new KeyPair3(ec, {
          pub,
          pubEnc: enc
        });
      };
      KeyPair3.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair3)
          return priv;
        return new KeyPair3(ec, {
          priv,
          privEnc: enc
        });
      };
      KeyPair3.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return { result: false, reason: "Invalid public key" };
        if (!pub.validate())
          return { result: false, reason: "Public key is not a point" };
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return { result: false, reason: "Public key * N != O" };
        return { result: true, reason: null };
      };
      KeyPair3.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
          enc = compact;
          compact = null;
        }
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact);
      };
      KeyPair3.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair3.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair3.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
          if (this.ec.curve.type === "mont") {
            assert(key.x, "Need x coordinate");
          } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
            assert(key.x && key.y, "Need both x and y coordinate");
          }
          this.pub = this.ec.curve.point(key.x, key.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
      };
      KeyPair3.prototype.derive = function derive(pub) {
        if (!pub.validate()) {
          assert(pub.validate(), "public point not validated");
        }
        return pub.mul(this.priv).getX();
      };
      KeyPair3.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair3.prototype.verify = function verify(msg, signature, options) {
        return this.ec.verify(msg, signature, this, void 0, options);
      };
      KeyPair3.prototype.inspect = function inspect() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/ec/signature.js
  var require_signature = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var utils = require_utils5();
      var assert = utils.assert;
      function Signature(options, enc) {
        if (options instanceof Signature)
          return options;
        if (this._importDER(options, enc))
          return;
        assert(options.r && options.s, "Signature without r or s");
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
        if (options.recoveryParam === void 0)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      module.exports = Signature;
      function Position() {
        this.place = 0;
      }
      function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
          return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
          return false;
        }
        if (buf[p.place] === 0) {
          return false;
        }
        var val = 0;
        for (var i = 0, off = p.place; i < octetLen; i++, off++) {
          val <<= 8;
          val |= buf[off];
          val >>>= 0;
        }
        if (val <= 127) {
          return false;
        }
        p.place = off;
        return val;
      }
      function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
          i++;
        }
        if (i === 0) {
          return buf;
        }
        return buf.slice(i);
      }
      Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p = new Position();
        if (data[p.place++] !== 48) {
          return false;
        }
        var len = getLength(data, p);
        if (len === false) {
          return false;
        }
        if (len + p.place !== data.length) {
          return false;
        }
        if (data[p.place++] !== 2) {
          return false;
        }
        var rlen = getLength(data, p);
        if (rlen === false) {
          return false;
        }
        if ((data[p.place] & 128) !== 0) {
          return false;
        }
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
          return false;
        }
        var slen = getLength(data, p);
        if (slen === false) {
          return false;
        }
        if (data.length !== slen + p.place) {
          return false;
        }
        if ((data[p.place] & 128) !== 0) {
          return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0) {
          if (r[1] & 128) {
            r = r.slice(1);
          } else {
            return false;
          }
        }
        if (s[0] === 0) {
          if (s[1] & 128) {
            s = s.slice(1);
          } else {
            return false;
          }
        }
        this.r = new BN(r);
        this.s = new BN(s);
        this.recoveryParam = null;
        return true;
      };
      function constructLength(arr, len) {
        if (len < 128) {
          arr.push(len);
          return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
          arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
      }
      Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
          s = s.slice(1);
        }
        var arr = [2];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [48];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils.encode(res, enc);
      };
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/ec/index.js
  var require_ec = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var HmacDRBG = require_hmac_drbg();
      var utils = require_utils5();
      var curves = require_curves();
      var rand = require_brorand();
      var assert = utils.assert;
      var KeyPair3 = require_key();
      var Signature = require_signature();
      function EC(options) {
        if (!(this instanceof EC))
          return new EC(options);
        if (typeof options === "string") {
          assert(
            Object.prototype.hasOwnProperty.call(curves, options),
            "Unknown curve " + options
          );
          options = curves[options];
        }
        if (options instanceof curves.PresetCurve)
          options = { curve: options };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
      }
      module.exports = EC;
      EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair3(this, options);
      };
      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair3.fromPrivate(this, priv, enc);
      };
      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair3.fromPublic(this, pub, enc);
      };
      EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({
          hash: this.hash,
          pers: options.pers,
          persEnc: options.persEnc || "utf8",
          entropy: options.entropy || rand(this.hash.hmacStrength),
          entropyEnc: options.entropy && options.entropyEnc || "utf8",
          nonce: this.n.toArray()
        });
        var bytes2 = this.n.byteLength();
        var ns2 = this.n.sub(new BN(2));
        for (; ; ) {
          var priv = new BN(drbg.generate(bytes2));
          if (priv.cmp(ns2) > 0)
            continue;
          priv.iaddn(1);
          return this.keyFromPrivate(priv);
        }
      };
      EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
        var byteLength;
        if (BN.isBN(msg) || typeof msg === "number") {
          msg = new BN(msg, 16);
          byteLength = msg.byteLength();
        } else if (typeof msg === "object") {
          byteLength = msg.length;
          msg = new BN(msg, 16);
        } else {
          var str = msg.toString();
          byteLength = str.length + 1 >>> 1;
          msg = new BN(str, 16);
        }
        if (typeof bitLength !== "number") {
          bitLength = byteLength * 8;
        }
        var delta = bitLength - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC.prototype.sign = function sign(msg, key, enc, options) {
        if (typeof enc === "object") {
          options = enc;
          enc = null;
        }
        if (!options)
          options = {};
        if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
          assert(
            typeof msg === "object" && msg && typeof msg.length === "number",
            "Expected message to be an array-like, a hex string, or a BN instance"
          );
          assert(msg.length >>> 0 === msg.length);
          for (var i = 0; i < msg.length; i++) assert((msg[i] & 255) === msg[i]);
        }
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(msg, false, options.msgBitLength);
        assert(!msg.isNeg(), "Can not sign a negative message");
        var bytes2 = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes2);
        var nonce = msg.toArray("be", bytes2);
        assert(new BN(nonce).eq(msg), "Can not sign message");
        var drbg = new HmacDRBG({
          hash: this.hash,
          entropy: bkey,
          nonce,
          pers: options.pers,
          persEnc: options.persEnc || "utf8"
        });
        var ns1 = this.n.sub(new BN(1));
        for (var iter = 0; ; iter++) {
          var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
          k = this._truncateToN(k, true);
          if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX();
          var r = kpX.umod(this.n);
          if (r.cmpn(0) === 0)
            continue;
          var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
          s = s.umod(this.n);
          if (s.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
          if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
          }
          return new Signature({ r, s, recoveryParam });
        }
      };
      EC.prototype.verify = function verify(msg, signature, key, enc, options) {
        if (!options)
          options = {};
        msg = this._truncateToN(msg, false, options.msgBitLength);
        key = this.keyFromPublic(key, enc);
        signature = new Signature(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
          return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
          return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        var p;
        if (!this.curve._maxwellTrick) {
          p = this.g.mulAdd(u1, key.getPublic(), u2);
          if (p.isInfinity())
            return false;
          return p.getX().umod(this.n).cmp(r) === 0;
        }
        p = this.g.jmulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.eqXToP(r);
      };
      EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature(signature, enc);
        var n = this.n;
        var e = new BN(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
        else
          r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
      };
      EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature(signature, enc);
        if (signature.recoveryParam !== null)
          return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature, i);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q))
            return i;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/eddsa/key.js
  var require_key2 = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      var assert = utils.assert;
      var parseBytes = utils.parseBytes;
      var cachedProperty = utils.cachedProperty;
      function KeyPair3(eddsa, params2) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params2.secret);
        if (eddsa.isPoint(params2.pub))
          this._pub = params2.pub;
        else
          this._pubBytes = parseBytes(params2.pub);
      }
      KeyPair3.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair3)
          return pub;
        return new KeyPair3(eddsa, { pub });
      };
      KeyPair3.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair3)
          return secret;
        return new KeyPair3(eddsa, { secret });
      };
      KeyPair3.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair3, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair3, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair3, "privBytes", function privBytes() {
        var eddsa = this.eddsa;
        var hash = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
      });
      cachedProperty(KeyPair3, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair3, "hash", function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair3, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair3.prototype.sign = function sign(message) {
        assert(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
      };
      KeyPair3.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair3.prototype.getSecret = function getSecret(enc) {
        assert(this._secret, "KeyPair is public only");
        return utils.encode(this.secret(), enc);
      };
      KeyPair3.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
      };
      module.exports = KeyPair3;
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/eddsa/signature.js
  var require_signature2 = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
      "use strict";
      var BN = require_bn();
      var utils = require_utils5();
      var assert = utils.assert;
      var cachedProperty = utils.cachedProperty;
      var parseBytes = utils.parseBytes;
      function Signature(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig)) {
          assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
          sig = {
            R: sig.slice(0, eddsa.encodingLength),
            S: sig.slice(eddsa.encodingLength)
          };
        }
        assert(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature.prototype.toBytes = function toBytes4() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature.prototype.toHex = function toHex() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
      };
      module.exports = Signature;
    }
  });

  // ../../node_modules/elliptic/lib/elliptic/eddsa/index.js
  var require_eddsa = __commonJS({
    "../../node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
      "use strict";
      var hash = require_hash();
      var curves = require_curves();
      var utils = require_utils5();
      var assert = utils.assert;
      var parseBytes = utils.parseBytes;
      var KeyPair3 = require_key2();
      var Signature = require_signature2();
      function EDDSA(curve) {
        assert(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA))
          return new EDDSA(curve);
        curve = curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash.sha512;
      }
      module.exports = EDDSA;
      EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({ R, S, Rencoded });
      };
      EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
          return false;
        }
        var key = this.keyFromPublic(pub);
        var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash2 = this.hash();
        for (var i = 0; i < arguments.length; i++)
          hash2.update(arguments[i]);
        return utils.intFromLE(hash2.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair3.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair3.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature)
          return sig;
        return new Signature(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes2) {
        bytes2 = utils.parseBytes(bytes2);
        var lastIx = bytes2.length - 1;
        var normed = bytes2.slice(0, lastIx).concat(bytes2[lastIx] & ~128);
        var xIsOdd = (bytes2[lastIx] & 128) !== 0;
        var y = utils.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes2) {
        return utils.intFromLE(bytes2);
      };
      EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
      };
    }
  });

  // ../../node_modules/elliptic/lib/elliptic.js
  var require_elliptic = __commonJS({
    "../../node_modules/elliptic/lib/elliptic.js"(exports) {
      "use strict";
      var elliptic = exports;
      elliptic.version = require_package().version;
      elliptic.utils = require_utils5();
      elliptic.rand = require_brorand();
      elliptic.curve = require_curve2();
      elliptic.curves = require_curves();
      elliptic.ec = require_ec();
      elliptic.eddsa = require_eddsa();
    }
  });

  // ../../node_modules/secp256k1/lib/elliptic.js
  var require_elliptic2 = __commonJS({
    "../../node_modules/secp256k1/lib/elliptic.js"(exports, module) {
      var EC = require_elliptic().ec;
      var ec = new EC("secp256k1");
      var ecparams = ec.curve;
      var BN = ecparams.n.constructor;
      function loadCompressedPublicKey(first, xbuf) {
        let x = new BN(xbuf);
        if (x.cmp(ecparams.p) >= 0) return null;
        x = x.toRed(ecparams.red);
        let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
        if (first === 3 !== y.isOdd()) y = y.redNeg();
        return ec.keyPair({ pub: { x, y } });
      }
      function loadUncompressedPublicKey(first, xbuf, ybuf) {
        let x = new BN(xbuf);
        let y = new BN(ybuf);
        if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;
        x = x.toRed(ecparams.red);
        y = y.toRed(ecparams.red);
        if ((first === 6 || first === 7) && y.isOdd() !== (first === 7)) return null;
        const x3 = x.redSqr().redIMul(x);
        if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
        return ec.keyPair({ pub: { x, y } });
      }
      function loadPublicKey(pubkey) {
        const first = pubkey[0];
        switch (first) {
          case 2:
          case 3:
            if (pubkey.length !== 33) return null;
            return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
          case 4:
          case 6:
          case 7:
            if (pubkey.length !== 65) return null;
            return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
          default:
            return null;
        }
      }
      function savePublicKey(output2, point) {
        const pubkey = point.encode(null, output2.length === 33);
        for (let i = 0; i < output2.length; ++i) output2[i] = pubkey[i];
      }
      module.exports = {
        contextRandomize() {
          return 0;
        },
        privateKeyVerify(seckey) {
          const bn = new BN(seckey);
          return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
        },
        privateKeyNegate(seckey) {
          const bn = new BN(seckey);
          const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
          seckey.set(negate);
          return 0;
        },
        privateKeyTweakAdd(seckey, tweak) {
          const bn = new BN(tweak);
          if (bn.cmp(ecparams.n) >= 0) return 1;
          bn.iadd(new BN(seckey));
          if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);
          if (bn.isZero()) return 1;
          const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
          seckey.set(tweaked);
          return 0;
        },
        privateKeyTweakMul(seckey, tweak) {
          let bn = new BN(tweak);
          if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;
          bn.imul(new BN(seckey));
          if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);
          const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
          seckey.set(tweaked);
          return 0;
        },
        publicKeyVerify(pubkey) {
          const pair = loadPublicKey(pubkey);
          return pair === null ? 1 : 0;
        },
        publicKeyCreate(output2, seckey) {
          const bn = new BN(seckey);
          if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;
          const point = ec.keyFromPrivate(seckey).getPublic();
          savePublicKey(output2, point);
          return 0;
        },
        publicKeyConvert(output2, pubkey) {
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 1;
          const point = pair.getPublic();
          savePublicKey(output2, point);
          return 0;
        },
        publicKeyNegate(output2, pubkey) {
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 1;
          const point = pair.getPublic();
          point.y = point.y.redNeg();
          savePublicKey(output2, point);
          return 0;
        },
        publicKeyCombine(output2, pubkeys) {
          const pairs = new Array(pubkeys.length);
          for (let i = 0; i < pubkeys.length; ++i) {
            pairs[i] = loadPublicKey(pubkeys[i]);
            if (pairs[i] === null) return 1;
          }
          let point = pairs[0].getPublic();
          for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub);
          if (point.isInfinity()) return 2;
          savePublicKey(output2, point);
          return 0;
        },
        publicKeyTweakAdd(output2, pubkey, tweak) {
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 1;
          tweak = new BN(tweak);
          if (tweak.cmp(ecparams.n) >= 0) return 2;
          const point = pair.getPublic().add(ecparams.g.mul(tweak));
          if (point.isInfinity()) return 2;
          savePublicKey(output2, point);
          return 0;
        },
        publicKeyTweakMul(output2, pubkey, tweak) {
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 1;
          tweak = new BN(tweak);
          if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;
          const point = pair.getPublic().mul(tweak);
          savePublicKey(output2, point);
          return 0;
        },
        signatureNormalize(sig) {
          const r = new BN(sig.subarray(0, 32));
          const s = new BN(sig.subarray(32, 64));
          if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;
          if (s.cmp(ec.nh) === 1) {
            sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, "be", 32), 32);
          }
          return 0;
        },
        // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
        // Adapted for Uint8Array instead Buffer
        signatureExport(obj, sig) {
          const sigR = sig.subarray(0, 32);
          const sigS = sig.subarray(32, 64);
          if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;
          if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;
          const { output: output2 } = obj;
          let r = output2.subarray(4, 4 + 33);
          r[0] = 0;
          r.set(sigR, 1);
          let lenR = 33;
          let posR = 0;
          for (; lenR > 1 && r[posR] === 0 && !(r[posR + 1] & 128); --lenR, ++posR) ;
          r = r.subarray(posR);
          if (r[0] & 128) return 1;
          if (lenR > 1 && r[0] === 0 && !(r[1] & 128)) return 1;
          let s = output2.subarray(6 + 33, 6 + 33 + 33);
          s[0] = 0;
          s.set(sigS, 1);
          let lenS = 33;
          let posS = 0;
          for (; lenS > 1 && s[posS] === 0 && !(s[posS + 1] & 128); --lenS, ++posS) ;
          s = s.subarray(posS);
          if (s[0] & 128) return 1;
          if (lenS > 1 && s[0] === 0 && !(s[1] & 128)) return 1;
          obj.outputlen = 6 + lenR + lenS;
          output2[0] = 48;
          output2[1] = obj.outputlen - 2;
          output2[2] = 2;
          output2[3] = r.length;
          output2.set(r, 4);
          output2[4 + lenR] = 2;
          output2[5 + lenR] = s.length;
          output2.set(s, 6 + lenR);
          return 0;
        },
        // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
        // Adapted for Uint8Array instead Buffer
        signatureImport(output2, sig) {
          if (sig.length < 8) return 1;
          if (sig.length > 72) return 1;
          if (sig[0] !== 48) return 1;
          if (sig[1] !== sig.length - 2) return 1;
          if (sig[2] !== 2) return 1;
          const lenR = sig[3];
          if (lenR === 0) return 1;
          if (5 + lenR >= sig.length) return 1;
          if (sig[4 + lenR] !== 2) return 1;
          const lenS = sig[5 + lenR];
          if (lenS === 0) return 1;
          if (6 + lenR + lenS !== sig.length) return 1;
          if (sig[4] & 128) return 1;
          if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128)) return 1;
          if (sig[lenR + 6] & 128) return 1;
          if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128)) return 1;
          let sigR = sig.subarray(4, 4 + lenR);
          if (sigR.length === 33 && sigR[0] === 0) sigR = sigR.subarray(1);
          if (sigR.length > 32) return 1;
          let sigS = sig.subarray(6 + lenR);
          if (sigS.length === 33 && sigS[0] === 0) sigS = sigS.slice(1);
          if (sigS.length > 32) throw new Error("S length is too long");
          let r = new BN(sigR);
          if (r.cmp(ecparams.n) >= 0) r = new BN(0);
          let s = new BN(sig.subarray(6 + lenR));
          if (s.cmp(ecparams.n) >= 0) s = new BN(0);
          output2.set(r.toArrayLike(Uint8Array, "be", 32), 0);
          output2.set(s.toArrayLike(Uint8Array, "be", 32), 32);
          return 0;
        },
        ecdsaSign(obj, message, seckey, data, noncefn) {
          if (noncefn) {
            const _noncefn = noncefn;
            noncefn = (counter) => {
              const nonce = _noncefn(message, seckey, null, data, counter);
              const isValid = nonce instanceof Uint8Array && nonce.length === 32;
              if (!isValid) throw new Error("This is the way");
              return new BN(nonce);
            };
          }
          const d = new BN(seckey);
          if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;
          let sig;
          try {
            sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
          } catch (err) {
            return 1;
          }
          obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
          obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
          obj.recid = sig.recoveryParam;
          return 0;
        },
        ecdsaVerify(sig, msg32, pubkey) {
          const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
          const sigr = new BN(sigObj.r);
          const sigs = new BN(sigObj.s);
          if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
          if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 2;
          const point = pair.getPublic();
          const isValid = ec.verify(msg32, sigObj, point);
          return isValid ? 0 : 3;
        },
        ecdsaRecover(output2, sig, recid, msg32) {
          const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
          const sigr = new BN(sigObj.r);
          const sigs = new BN(sigObj.s);
          if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
          if (sigr.isZero() || sigs.isZero()) return 2;
          let point;
          try {
            point = ec.recoverPubKey(msg32, sigObj, recid);
          } catch (err) {
            return 2;
          }
          savePublicKey(output2, point);
          return 0;
        },
        ecdh(output2, pubkey, seckey, data, hashfn, xbuf, ybuf) {
          const pair = loadPublicKey(pubkey);
          if (pair === null) return 1;
          const scalar = new BN(seckey);
          if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;
          const point = pair.getPublic().mul(scalar);
          if (hashfn === void 0) {
            const data2 = point.encode(null, true);
            const sha2562 = ec.hash().update(data2).digest();
            for (let i = 0; i < 32; ++i) output2[i] = sha2562[i];
          } else {
            if (!xbuf) xbuf = new Uint8Array(32);
            const x = point.getX().toArray("be", 32);
            for (let i = 0; i < 32; ++i) xbuf[i] = x[i];
            if (!ybuf) ybuf = new Uint8Array(32);
            const y = point.getY().toArray("be", 32);
            for (let i = 0; i < 32; ++i) ybuf[i] = y[i];
            const hash = hashfn(xbuf, ybuf, data);
            const isValid = hash instanceof Uint8Array && hash.length === output2.length;
            if (!isValid) return 2;
            output2.set(hash);
          }
          return 0;
        }
      };
    }
  });

  // ../../node_modules/secp256k1/elliptic.js
  var require_elliptic3 = __commonJS({
    "../../node_modules/secp256k1/elliptic.js"(exports, module) {
      module.exports = require_lib()(require_elliptic2());
    }
  });

  // ../../node_modules/@near-js/crypto/lib/commonjs/public_key.cjs
  var require_public_key = __commonJS({
    "../../node_modules/@near-js/crypto/lib/commonjs/public_key.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PublicKey = void 0;
      var utils_1 = require_commonjs2();
      var ed25519_1 = require_ed25519();
      var secp256k1_1 = __importDefault(require_elliptic3());
      var constants_1 = require_constants();
      function key_type_to_str2(keyType) {
        switch (keyType) {
          case constants_1.KeyType.ED25519:
            return "ed25519";
          case constants_1.KeyType.SECP256K1:
            return "secp256k1";
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function str_to_key_type2(keyType) {
        switch (keyType.toLowerCase()) {
          case "ed25519":
            return constants_1.KeyType.ED25519;
          case "secp256k1":
            return constants_1.KeyType.SECP256K1;
          default:
            throw new Error(`Unknown key type ${keyType}`);
        }
      }
      function resolveEnumKeyName3(keyType) {
        switch (keyType) {
          case constants_1.KeyType.ED25519: {
            return "ed25519Key";
          }
          case constants_1.KeyType.SECP256K1: {
            return "secp256k1Key";
          }
          default: {
            throw Error(`unknown type ${keyType}`);
          }
        }
      }
      var Enum3 = class {
        constructor(properties) {
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      var PublicKey3 = class _PublicKey extends Enum3 {
        enum;
        ed25519Key;
        secp256k1Key;
        constructor(publicKey) {
          const keyName = resolveEnumKeyName3(publicKey.keyType);
          super({ [keyName]: publicKey });
          this[keyName] = publicKey;
          this.enum = keyName;
        }
        /**
         * Creates a PublicKey instance from a string or an existing PublicKey instance.
         * @param value The string or PublicKey instance to create a PublicKey from.
         * @returns {PublicKey} The PublicKey instance.
         */
        static from(value) {
          if (typeof value === "string") {
            return _PublicKey.fromString(value);
          }
          return value;
        }
        /**
         * Creates a PublicKey instance from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {PublicKey} The PublicKey instance created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          let publicKey;
          let keyType;
          if (parts.length === 1) {
            publicKey = parts[0];
          } else if (parts.length === 2) {
            publicKey = parts[1];
            keyType = str_to_key_type2(parts[0]);
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
          const decodedPublicKey = (0, utils_1.baseDecode)(publicKey);
          if (!keyType) {
            keyType = decodedPublicKey.length === constants_1.KeySize.SECP256k1_PUBLIC_KEY ? constants_1.KeyType.SECP256K1 : constants_1.KeyType.ED25519;
          }
          const keySize = keyType === constants_1.KeyType.ED25519 ? constants_1.KeySize.ED25519_PUBLIC_KEY : constants_1.KeySize.SECP256k1_PUBLIC_KEY;
          if (decodedPublicKey.length !== keySize) {
            throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${keySize}`);
          }
          return new _PublicKey({ keyType, data: decodedPublicKey });
        }
        /**
         * Returns a string representation of the public key.
         * @returns {string} The string representation of the public key.
         */
        toString() {
          const encodedKey = (0, utils_1.baseEncode)(this.data);
          return `${key_type_to_str2(this.keyType)}:${encodedKey}`;
        }
        /**
         * Verifies a message signature using the public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          const keyType = this.keyType;
          const data = this.data;
          switch (keyType) {
            case constants_1.KeyType.ED25519:
              return ed25519_1.ed25519.verify(signature, message, data);
            case constants_1.KeyType.SECP256K1:
              return secp256k1_1.default.ecdsaVerify(signature.subarray(0, 64), message, new Uint8Array([4, ...data]));
            default:
              throw new Error(`Unknown key type: ${keyType}`);
          }
        }
        get keyPair() {
          return this.ed25519Key || this.secp256k1Key;
        }
        get keyType() {
          return this.keyPair.keyType;
        }
        get data() {
          return this.keyPair.data;
        }
      };
      exports.PublicKey = PublicKey3;
    }
  });

  // ../../node_modules/@near-js/crypto/lib/commonjs/key_pair_ed25519.cjs
  var require_key_pair_ed25519 = __commonJS({
    "../../node_modules/@near-js/crypto/lib/commonjs/key_pair_ed25519.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyPairEd25519 = void 0;
      var utils_1 = require_commonjs2();
      var ed25519_1 = require_ed25519();
      var randombytes_1 = __importDefault(require_browser2());
      var constants_1 = require_constants();
      var key_pair_base_1 = require_key_pair_base();
      var public_key_1 = require_public_key();
      var KeyPairEd255193 = class _KeyPairEd25519 extends key_pair_base_1.KeyPairBase {
        publicKey;
        secretKey;
        extendedSecretKey;
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = (0, utils_1.baseDecode)(extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, constants_1.KeySize.SECRET_KEY));
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          this.publicKey = new public_key_1.PublicKey({ keyType: constants_1.KeyType.ED25519, data: publicKey });
          this.secretKey = (0, utils_1.baseEncode)(secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = (0, randombytes_1.default)(constants_1.KeySize.SECRET_KEY);
          const publicKey = ed25519_1.ed25519.getPublicKey(new Uint8Array(secretKey));
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairEd25519((0, utils_1.baseEncode)(extendedSecretKey));
        }
        /**
         * Signs a message using the key pair's secret key.
         * @param message The message to be signed.
         * @returns {Signature} The signature object containing the signature and the public key.
         */
        sign(message) {
          const signature = ed25519_1.ed25519.sign(message, (0, utils_1.baseDecode)(this.secretKey));
          return { signature, publicKey: this.publicKey };
        }
        /**
         * Verifies the signature of a message using the key pair's public key.
         * @param message The message to be verified.
         * @param signature The signature to be verified.
         * @returns {boolean} `true` if the signature is valid, otherwise `false`.
         */
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        /**
         * Returns a string representation of the key pair in the format 'ed25519:[extendedSecretKey]'.
         * @returns {string} The string representation of the key pair.
         */
        toString() {
          return `ed25519:${this.extendedSecretKey}`;
        }
        /**
         * Retrieves the public key associated with the key pair.
         * @returns {PublicKey} The public key.
         */
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports.KeyPairEd25519 = KeyPairEd255193;
    }
  });

  // ../../node_modules/@near-js/crypto/lib/commonjs/key_pair_secp256k1.cjs
  var require_key_pair_secp256k1 = __commonJS({
    "../../node_modules/@near-js/crypto/lib/commonjs/key_pair_secp256k1.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyPairSecp256k1 = void 0;
      var utils_1 = require_commonjs2();
      var randombytes_1 = __importDefault(require_browser2());
      var secp256k1_1 = __importDefault(require_elliptic3());
      var constants_1 = require_constants();
      var key_pair_base_1 = require_key_pair_base();
      var public_key_1 = require_public_key();
      var KeyPairSecp256k13 = class _KeyPairSecp256k1 extends key_pair_base_1.KeyPairBase {
        publicKey;
        secretKey;
        extendedSecretKey;
        /**
         * Construct an instance of key pair given a secret key.
         * It's generally assumed that these are encoded in base58.
         * @param {string} extendedSecretKey
         */
        constructor(extendedSecretKey) {
          super();
          const decoded = (0, utils_1.baseDecode)(extendedSecretKey);
          const secretKey = new Uint8Array(decoded.slice(0, constants_1.KeySize.SECRET_KEY));
          const withHeader = secp256k1_1.default.publicKeyCreate(new Uint8Array(secretKey), false);
          const data = withHeader.subarray(1, withHeader.length);
          this.publicKey = new public_key_1.PublicKey({
            keyType: constants_1.KeyType.SECP256K1,
            data
          });
          this.secretKey = (0, utils_1.baseEncode)(secretKey);
          this.extendedSecretKey = extendedSecretKey;
        }
        /**
         * Generate a new random keypair.
         * @example
         * const keyRandom = KeyPair.fromRandom();
         * keyRandom.publicKey
         * // returns [PUBLIC_KEY]
         *
         * keyRandom.secretKey
         * // returns [SECRET_KEY]
         */
        static fromRandom() {
          const secretKey = (0, randombytes_1.default)(constants_1.KeySize.SECRET_KEY);
          const withHeader = secp256k1_1.default.publicKeyCreate(new Uint8Array(secretKey), false);
          const publicKey = withHeader.subarray(1, withHeader.length);
          const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
          return new _KeyPairSecp256k1((0, utils_1.baseEncode)(extendedSecretKey));
        }
        sign(message) {
          const { signature, recid } = secp256k1_1.default.ecdsaSign(message, (0, utils_1.baseDecode)(this.secretKey));
          return { signature: new Uint8Array([...signature, recid]), publicKey: this.publicKey };
        }
        verify(message, signature) {
          return this.publicKey.verify(message, signature);
        }
        toString() {
          return `secp256k1:${this.extendedSecretKey}`;
        }
        getPublicKey() {
          return this.publicKey;
        }
      };
      exports.KeyPairSecp256k1 = KeyPairSecp256k13;
    }
  });

  // ../../node_modules/@near-js/crypto/lib/commonjs/key_pair.cjs
  var require_key_pair = __commonJS({
    "../../node_modules/@near-js/crypto/lib/commonjs/key_pair.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyPair = void 0;
      var key_pair_base_1 = require_key_pair_base();
      var key_pair_ed25519_1 = require_key_pair_ed25519();
      var key_pair_secp256k1_1 = require_key_pair_secp256k1();
      var KeyPair3 = class extends key_pair_base_1.KeyPairBase {
        /**
         * @param curve Name of elliptical curve, case-insensitive
         * @returns Random KeyPair based on the curve
         */
        static fromRandom(curve) {
          switch (curve.toUpperCase()) {
            case "ED25519":
              return key_pair_ed25519_1.KeyPairEd25519.fromRandom();
            case "SECP256K1":
              return key_pair_secp256k1_1.KeyPairSecp256k1.fromRandom();
            default:
              throw new Error(`Unknown curve ${curve}`);
          }
        }
        /**
         * Creates a key pair from an encoded key string.
         * @param encodedKey The encoded key string.
         * @returns {KeyPair} The key pair created from the encoded key string.
         */
        static fromString(encodedKey) {
          const parts = encodedKey.split(":");
          if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
              case "ED25519":
                return new key_pair_ed25519_1.KeyPairEd25519(parts[1]);
              case "SECP256K1":
                return new key_pair_secp256k1_1.KeyPairSecp256k1(parts[1]);
              default:
                throw new Error(`Unknown curve: ${parts[0]}`);
            }
          } else {
            throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
          }
        }
      };
      exports.KeyPair = KeyPair3;
    }
  });

  // ../../node_modules/@near-js/crypto/lib/commonjs/index.cjs
  var require_commonjs3 = __commonJS({
    "../../node_modules/@near-js/crypto/lib/commonjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PublicKey = exports.KeyPairSecp256k1 = exports.KeyPairEd25519 = exports.KeyPair = exports.KeyType = void 0;
      var constants_1 = require_constants();
      Object.defineProperty(exports, "KeyType", { enumerable: true, get: function() {
        return constants_1.KeyType;
      } });
      var key_pair_1 = require_key_pair();
      Object.defineProperty(exports, "KeyPair", { enumerable: true, get: function() {
        return key_pair_1.KeyPair;
      } });
      var key_pair_ed25519_1 = require_key_pair_ed25519();
      Object.defineProperty(exports, "KeyPairEd25519", { enumerable: true, get: function() {
        return key_pair_ed25519_1.KeyPairEd25519;
      } });
      var key_pair_secp256k1_1 = require_key_pair_secp256k1();
      Object.defineProperty(exports, "KeyPairSecp256k1", { enumerable: true, get: function() {
        return key_pair_secp256k1_1.KeyPairSecp256k1;
      } });
      var public_key_1 = require_public_key();
      Object.defineProperty(exports, "PublicKey", { enumerable: true, get: function() {
        return public_key_1.PublicKey;
      } });
    }
  });

  // ../../node_modules/@near-js/providers/lib/commonjs/exponential-backoff.cjs
  var require_exponential_backoff = __commonJS({
    "../../node_modules/@near-js/providers/lib/commonjs/exponential-backoff.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.exponentialBackoff = void 0;
      async function exponentialBackoff2(startWaitTime, retryNumber, waitBackoff, getResult) {
        let waitTime = startWaitTime;
        for (let i = 0; i < retryNumber; i++) {
          const result = await getResult();
          if (result) {
            return result;
          }
          await sleep2(waitTime);
          waitTime *= waitBackoff;
        }
        return null;
      }
      exports.exponentialBackoff = exponentialBackoff2;
      function sleep2(millis) {
        return new Promise((resolve) => setTimeout(resolve, millis));
      }
    }
  });

  // ../../node_modules/@near-js/transactions/lib/commonjs/actions.cjs
  var require_actions = __commonJS({
    "../../node_modules/@near-js/transactions/lib/commonjs/actions.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Action = exports.SignedDelegate = exports.DeleteAccount = exports.DeleteKey = exports.AddKey = exports.Stake = exports.Transfer = exports.FunctionCall = exports.DeployContract = exports.CreateAccount = exports.AccessKey = exports.AccessKeyPermission = exports.FullAccessPermission = exports.FunctionCallPermission = void 0;
      var types_1 = require_commonjs();
      var FunctionCallPermission2 = class {
        allowance;
        receiverId;
        methodNames;
        constructor({ allowance, receiverId, methodNames }) {
          this.allowance = allowance;
          this.receiverId = receiverId;
          this.methodNames = methodNames;
        }
      };
      exports.FunctionCallPermission = FunctionCallPermission2;
      var FullAccessPermission2 = class {
      };
      exports.FullAccessPermission = FullAccessPermission2;
      var AccessKeyPermission2 = class extends types_1.Enum {
        enum;
        functionCall;
        fullAccess;
        constructor(props) {
          super(props);
          for (const [k, v] of Object.entries(props || {})) {
            this[k] = v;
            this.enum = k;
          }
        }
      };
      exports.AccessKeyPermission = AccessKeyPermission2;
      var AccessKey2 = class {
        nonce;
        permission;
        constructor({ nonce, permission }) {
          this.nonce = nonce;
          this.permission = permission;
        }
      };
      exports.AccessKey = AccessKey2;
      var CreateAccount2 = class {
      };
      exports.CreateAccount = CreateAccount2;
      var DeployContract2 = class {
        code;
        constructor({ code }) {
          this.code = code;
        }
      };
      exports.DeployContract = DeployContract2;
      var FunctionCall2 = class {
        methodName;
        args;
        gas;
        deposit;
        constructor({ methodName, args, gas, deposit }) {
          this.methodName = methodName;
          this.args = args;
          this.gas = gas;
          this.deposit = deposit;
        }
      };
      exports.FunctionCall = FunctionCall2;
      var Transfer2 = class {
        deposit;
        constructor({ deposit }) {
          this.deposit = deposit;
        }
      };
      exports.Transfer = Transfer2;
      var Stake2 = class {
        stake;
        publicKey;
        constructor({ stake: stake4, publicKey }) {
          this.stake = stake4;
          this.publicKey = publicKey;
        }
      };
      exports.Stake = Stake2;
      var AddKey2 = class {
        publicKey;
        accessKey;
        constructor({ publicKey, accessKey }) {
          this.publicKey = publicKey;
          this.accessKey = accessKey;
        }
      };
      exports.AddKey = AddKey2;
      var DeleteKey2 = class {
        publicKey;
        constructor({ publicKey }) {
          this.publicKey = publicKey;
        }
      };
      exports.DeleteKey = DeleteKey2;
      var DeleteAccount2 = class {
        beneficiaryId;
        constructor({ beneficiaryId }) {
          this.beneficiaryId = beneficiaryId;
        }
      };
      exports.DeleteAccount = DeleteAccount2;
      var SignedDelegate2 = class {
        delegateAction;
        signature;
        constructor({ delegateAction, signature }) {
          this.delegateAction = delegateAction;
          this.signature = signature;
        }
      };
      exports.SignedDelegate = SignedDelegate2;
      var Action2 = class extends types_1.Enum {
        enum;
        createAccount;
        deployContract;
        functionCall;
        transfer;
        stake;
        addKey;
        deleteKey;
        deleteAccount;
        signedDelegate;
        constructor(props) {
          super(props);
          for (const [k, v] of Object.entries(props || {})) {
            this[k] = v;
            this.enum = k;
          }
        }
      };
      exports.Action = Action2;
    }
  });

  // ../../node_modules/@near-js/transactions/lib/commonjs/action_creators.cjs
  var require_action_creators = __commonJS({
    "../../node_modules/@near-js/transactions/lib/commonjs/action_creators.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.actionCreators = exports.stringifyJsonOrBytes = void 0;
      var actions_1 = require_actions();
      function fullAccessKey4() {
        return new actions_1.AccessKey({
          nonce: 0n,
          permission: new actions_1.AccessKeyPermission({
            fullAccess: new actions_1.FullAccessPermission()
          })
        });
      }
      function functionCallAccessKey4(receiverId, methodNames, allowance) {
        return new actions_1.AccessKey({
          nonce: 0n,
          permission: new actions_1.AccessKeyPermission({
            functionCall: new actions_1.FunctionCallPermission({
              receiverId,
              allowance,
              methodNames
            })
          })
        });
      }
      function createAccount4() {
        return new actions_1.Action({ createAccount: new actions_1.CreateAccount() });
      }
      function deployContract6(code) {
        return new actions_1.Action({ deployContract: new actions_1.DeployContract({ code }) });
      }
      function stringifyJsonOrBytes2(args) {
        const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
        return isUint8Array ? args : Buffer.from(JSON.stringify(args));
      }
      exports.stringifyJsonOrBytes = stringifyJsonOrBytes2;
      function functionCall6(methodName, args, gas = 0n, deposit = 0n, stringify = stringifyJsonOrBytes2, jsContract = false) {
        if (jsContract) {
          return new actions_1.Action({
            functionCall: new actions_1.FunctionCall({ methodName, args, gas, deposit })
          });
        }
        return new actions_1.Action({
          functionCall: new actions_1.FunctionCall({
            methodName,
            args: stringify(args),
            gas,
            deposit
          })
        });
      }
      function transfer4(deposit = 0n) {
        return new actions_1.Action({ transfer: new actions_1.Transfer({ deposit }) });
      }
      function stake4(stake5 = 0n, publicKey) {
        return new actions_1.Action({ stake: new actions_1.Stake({ stake: stake5, publicKey }) });
      }
      function addKey5(publicKey, accessKey) {
        return new actions_1.Action({ addKey: new actions_1.AddKey({ publicKey, accessKey }) });
      }
      function deleteKey5(publicKey) {
        return new actions_1.Action({ deleteKey: new actions_1.DeleteKey({ publicKey }) });
      }
      function deleteAccount4(beneficiaryId) {
        return new actions_1.Action({ deleteAccount: new actions_1.DeleteAccount({ beneficiaryId }) });
      }
      function signedDelegate2({ delegateAction, signature }) {
        return new actions_1.Action({
          signedDelegate: new actions_1.SignedDelegate({ delegateAction, signature })
        });
      }
      exports.actionCreators = {
        addKey: addKey5,
        createAccount: createAccount4,
        deleteAccount: deleteAccount4,
        deleteKey: deleteKey5,
        deployContract: deployContract6,
        fullAccessKey: fullAccessKey4,
        functionCall: functionCall6,
        functionCallAccessKey: functionCallAccessKey4,
        signedDelegate: signedDelegate2,
        stake: stake4,
        transfer: transfer4
      };
    }
  });

  // ../../node_modules/borsh/lib/cjs/types.js
  var require_types = __commonJS({
    "../../node_modules/borsh/lib/cjs/types.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.integers = void 0;
      exports.integers = ["u8", "u16", "u32", "u64", "u128", "i8", "i16", "i32", "i64", "i128", "f32", "f64"];
    }
  });

  // ../../node_modules/borsh/lib/cjs/buffer.js
  var require_buffer = __commonJS({
    "../../node_modules/borsh/lib/cjs/buffer.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.DecodeBuffer = exports.EncodeBuffer = void 0;
      var EncodeBuffer2 = (
        /** @class */
        function() {
          function EncodeBuffer3() {
            this.offset = 0;
            this.buffer_size = 256;
            this.buffer = new ArrayBuffer(this.buffer_size);
            this.view = new DataView(this.buffer);
          }
          EncodeBuffer3.prototype.resize_if_necessary = function(needed_space) {
            if (this.buffer_size - this.offset < needed_space) {
              this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
              var new_buffer = new ArrayBuffer(this.buffer_size);
              new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
              this.buffer = new_buffer;
              this.view = new DataView(new_buffer);
            }
          };
          EncodeBuffer3.prototype.get_used_buffer = function() {
            return new Uint8Array(this.buffer).slice(0, this.offset);
          };
          EncodeBuffer3.prototype.store_value = function(value, type) {
            var bSize = type.substring(1);
            var size = parseInt(bSize) / 8;
            this.resize_if_necessary(size);
            var toCall = type[0] === "f" ? "setFloat".concat(bSize) : type[0] === "i" ? "setInt".concat(bSize) : "setUint".concat(bSize);
            this.view[toCall](this.offset, value, true);
            this.offset += size;
          };
          EncodeBuffer3.prototype.store_bytes = function(from) {
            this.resize_if_necessary(from.length);
            new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
            this.offset += from.length;
          };
          return EncodeBuffer3;
        }()
      );
      exports.EncodeBuffer = EncodeBuffer2;
      var DecodeBuffer2 = (
        /** @class */
        function() {
          function DecodeBuffer3(buf) {
            this.offset = 0;
            this.buffer_size = buf.length;
            this.buffer = new ArrayBuffer(buf.length);
            new Uint8Array(this.buffer).set(buf);
            this.view = new DataView(this.buffer);
          }
          DecodeBuffer3.prototype.assert_enough_buffer = function(size) {
            if (this.offset + size > this.buffer.byteLength) {
              throw new Error("Error in schema, the buffer is smaller than expected");
            }
          };
          DecodeBuffer3.prototype.consume_value = function(type) {
            var bSize = type.substring(1);
            var size = parseInt(bSize) / 8;
            this.assert_enough_buffer(size);
            var toCall = type[0] === "f" ? "getFloat".concat(bSize) : type[0] === "i" ? "getInt".concat(bSize) : "getUint".concat(bSize);
            var ret = this.view[toCall](this.offset, true);
            this.offset += size;
            return ret;
          };
          DecodeBuffer3.prototype.consume_bytes = function(size) {
            this.assert_enough_buffer(size);
            var ret = this.buffer.slice(this.offset, this.offset + size);
            this.offset += size;
            return ret;
          };
          return DecodeBuffer3;
        }()
      );
      exports.DecodeBuffer = DecodeBuffer2;
    }
  });

  // ../../node_modules/borsh/lib/cjs/utils.js
  var require_utils7 = __commonJS({
    "../../node_modules/borsh/lib/cjs/utils.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      exports.__esModule = true;
      exports.validate_schema = exports.ErrorSchema = exports.expect_enum = exports.expect_same_size = exports.expect_bigint = exports.expect_type = exports.isArrayLike = void 0;
      var types_js_1 = require_types();
      function isArrayLike2(value) {
        return Array.isArray(value) || !!value && typeof value === "object" && "length" in value && typeof value.length === "number" && (value.length === 0 || value.length > 0 && value.length - 1 in value);
      }
      exports.isArrayLike = isArrayLike2;
      function expect_type2(value, type, fieldPath) {
        if (typeof value !== type) {
          throw new Error("Expected ".concat(type, " not ").concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
        }
      }
      exports.expect_type = expect_type2;
      function expect_bigint2(value, fieldPath) {
        var basicType = ["number", "string", "bigint", "boolean"].includes(typeof value);
        var strObject = typeof value === "object" && value !== null && "toString" in value;
        if (!basicType && !strObject) {
          throw new Error("Expected bigint, number, boolean or string not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
        }
      }
      exports.expect_bigint = expect_bigint2;
      function expect_same_size2(length, expected, fieldPath) {
        if (length !== expected) {
          throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join(".")));
        }
      }
      exports.expect_same_size = expect_same_size2;
      function expect_enum2(value, fieldPath) {
        if (typeof value !== "object" || value === null) {
          throw new Error("Expected object not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
        }
      }
      exports.expect_enum = expect_enum2;
      var VALID_STRING_TYPES2 = types_js_1.integers.concat(["bool", "string"]);
      var VALID_OBJECT_KEYS2 = ["option", "enum", "array", "set", "map", "struct"];
      var ErrorSchema2 = (
        /** @class */
        function(_super) {
          __extends2(ErrorSchema3, _super);
          function ErrorSchema3(schema, expected) {
            var message = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
            return _super.call(this, message) || this;
          }
          return ErrorSchema3;
        }(Error)
      );
      exports.ErrorSchema = ErrorSchema2;
      function validate_schema2(schema) {
        if (typeof schema === "string" && VALID_STRING_TYPES2.includes(schema)) {
          return;
        }
        if (schema && typeof schema === "object") {
          var keys = Object.keys(schema);
          if (keys.length === 1 && VALID_OBJECT_KEYS2.includes(keys[0])) {
            var key = keys[0];
            if (key === "option")
              return validate_schema2(schema[key]);
            if (key === "enum")
              return validate_enum_schema2(schema[key]);
            if (key === "array")
              return validate_array_schema2(schema[key]);
            if (key === "set")
              return validate_schema2(schema[key]);
            if (key === "map")
              return validate_map_schema2(schema[key]);
            if (key === "struct")
              return validate_struct_schema2(schema[key]);
          }
        }
        throw new ErrorSchema2(schema, VALID_OBJECT_KEYS2.join(", ") + " or " + VALID_STRING_TYPES2.join(", "));
      }
      exports.validate_schema = validate_schema2;
      function validate_enum_schema2(schema) {
        if (!Array.isArray(schema))
          throw new ErrorSchema2(schema, "Array");
        for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
          var sch = schema_1[_i];
          if (typeof sch !== "object" || !("struct" in sch)) {
            throw new Error('Missing "struct" key in enum schema');
          }
          if (typeof sch.struct !== "object" || Object.keys(sch.struct).length !== 1) {
            throw new Error('The "struct" in each enum must have a single key');
          }
          validate_schema2({ struct: sch.struct });
        }
      }
      function validate_array_schema2(schema) {
        if (typeof schema !== "object")
          throw new ErrorSchema2(schema, "{ type, len? }");
        if (schema.len && typeof schema.len !== "number") {
          throw new Error("Invalid schema: ".concat(schema));
        }
        if ("type" in schema)
          return validate_schema2(schema.type);
        throw new ErrorSchema2(schema, "{ type, len? }");
      }
      function validate_map_schema2(schema) {
        if (typeof schema === "object" && "key" in schema && "value" in schema) {
          validate_schema2(schema.key);
          validate_schema2(schema.value);
        } else {
          throw new ErrorSchema2(schema, "{ key, value }");
        }
      }
      function validate_struct_schema2(schema) {
        if (typeof schema !== "object")
          throw new ErrorSchema2(schema, "object");
        for (var key in schema) {
          validate_schema2(schema[key]);
        }
      }
    }
  });

  // ../../node_modules/borsh/lib/cjs/serialize.js
  var require_serialize = __commonJS({
    "../../node_modules/borsh/lib/cjs/serialize.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule) return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      exports.__esModule = true;
      exports.BorshSerializer = void 0;
      var types_js_1 = require_types();
      var buffer_js_1 = require_buffer();
      var utils = __importStar(require_utils7());
      var BorshSerializer2 = (
        /** @class */
        function() {
          function BorshSerializer3(checkTypes) {
            this.encoded = new buffer_js_1.EncodeBuffer();
            this.fieldPath = ["value"];
            this.checkTypes = checkTypes;
          }
          BorshSerializer3.prototype.encode = function(value, schema) {
            this.encode_value(value, schema);
            return this.encoded.get_used_buffer();
          };
          BorshSerializer3.prototype.encode_value = function(value, schema) {
            if (typeof schema === "string") {
              if (types_js_1.integers.includes(schema))
                return this.encode_integer(value, schema);
              if (schema === "string")
                return this.encode_string(value);
              if (schema === "bool")
                return this.encode_boolean(value);
            }
            if (typeof schema === "object") {
              if ("option" in schema)
                return this.encode_option(value, schema);
              if ("enum" in schema)
                return this.encode_enum(value, schema);
              if ("array" in schema)
                return this.encode_array(value, schema);
              if ("set" in schema)
                return this.encode_set(value, schema);
              if ("map" in schema)
                return this.encode_map(value, schema);
              if ("struct" in schema)
                return this.encode_struct(value, schema);
            }
          };
          BorshSerializer3.prototype.encode_integer = function(value, schema) {
            var size = parseInt(schema.substring(1));
            if (size <= 32 || schema == "f64") {
              this.checkTypes && utils.expect_type(value, "number", this.fieldPath);
              this.encoded.store_value(value, schema);
            } else {
              this.checkTypes && utils.expect_bigint(value, this.fieldPath);
              this.encode_bigint(BigInt(value), size);
            }
          };
          BorshSerializer3.prototype.encode_bigint = function(value, size) {
            var buffer_len = size / 8;
            var buffer = new Uint8Array(buffer_len);
            for (var i = 0; i < buffer_len; i++) {
              buffer[i] = Number(value & BigInt(255));
              value = value >> BigInt(8);
            }
            this.encoded.store_bytes(new Uint8Array(buffer));
          };
          BorshSerializer3.prototype.encode_string = function(value) {
            this.checkTypes && utils.expect_type(value, "string", this.fieldPath);
            var _value = value;
            var utf8Bytes = [];
            for (var i = 0; i < _value.length; i++) {
              var charCode = _value.charCodeAt(i);
              if (charCode < 128) {
                utf8Bytes.push(charCode);
              } else if (charCode < 2048) {
                utf8Bytes.push(192 | charCode >> 6, 128 | charCode & 63);
              } else if (charCode < 55296 || charCode >= 57344) {
                utf8Bytes.push(224 | charCode >> 12, 128 | charCode >> 6 & 63, 128 | charCode & 63);
              } else {
                i++;
                charCode = 65536 + ((charCode & 1023) << 10 | _value.charCodeAt(i) & 1023);
                utf8Bytes.push(240 | charCode >> 18, 128 | charCode >> 12 & 63, 128 | charCode >> 6 & 63, 128 | charCode & 63);
              }
            }
            this.encoded.store_value(utf8Bytes.length, "u32");
            this.encoded.store_bytes(new Uint8Array(utf8Bytes));
          };
          BorshSerializer3.prototype.encode_boolean = function(value) {
            this.checkTypes && utils.expect_type(value, "boolean", this.fieldPath);
            this.encoded.store_value(value ? 1 : 0, "u8");
          };
          BorshSerializer3.prototype.encode_option = function(value, schema) {
            if (value === null || value === void 0) {
              this.encoded.store_value(0, "u8");
            } else {
              this.encoded.store_value(1, "u8");
              this.encode_value(value, schema.option);
            }
          };
          BorshSerializer3.prototype.encode_enum = function(value, schema) {
            this.checkTypes && utils.expect_enum(value, this.fieldPath);
            var valueKey = Object.keys(value)[0];
            for (var i = 0; i < schema["enum"].length; i++) {
              var valueSchema = schema["enum"][i];
              if (valueKey === Object.keys(valueSchema.struct)[0]) {
                this.encoded.store_value(i, "u8");
                return this.encode_struct(value, valueSchema);
              }
            }
            throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join(".")));
          };
          BorshSerializer3.prototype.encode_array = function(value, schema) {
            if (utils.isArrayLike(value))
              return this.encode_arraylike(value, schema);
            if (value instanceof ArrayBuffer)
              return this.encode_buffer(value, schema);
            throw new Error("Expected Array-like not ".concat(typeof value, "(").concat(value, ") at ").concat(this.fieldPath.join(".")));
          };
          BorshSerializer3.prototype.encode_arraylike = function(value, schema) {
            if (schema.array.len) {
              utils.expect_same_size(value.length, schema.array.len, this.fieldPath);
            } else {
              this.encoded.store_value(value.length, "u32");
            }
            for (var i = 0; i < value.length; i++) {
              this.encode_value(value[i], schema.array.type);
            }
          };
          BorshSerializer3.prototype.encode_buffer = function(value, schema) {
            if (schema.array.len) {
              utils.expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
            } else {
              this.encoded.store_value(value.byteLength, "u32");
            }
            this.encoded.store_bytes(new Uint8Array(value));
          };
          BorshSerializer3.prototype.encode_set = function(value, schema) {
            this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
            var isSet = value instanceof Set;
            var values = isSet ? Array.from(value.values()) : Object.values(value);
            this.encoded.store_value(values.length, "u32");
            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
              var value_1 = values_1[_i];
              this.encode_value(value_1, schema.set);
            }
          };
          BorshSerializer3.prototype.encode_map = function(value, schema) {
            this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
            var isMap = value instanceof Map;
            var keys = isMap ? Array.from(value.keys()) : Object.keys(value);
            this.encoded.store_value(keys.length, "u32");
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
              var key = keys_1[_i];
              this.encode_value(key, schema.map.key);
              this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
            }
          };
          BorshSerializer3.prototype.encode_struct = function(value, schema) {
            this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
            for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
              var key = _a[_i];
              this.fieldPath.push(key);
              this.encode_value(value[key], schema.struct[key]);
              this.fieldPath.pop();
            }
          };
          return BorshSerializer3;
        }()
      );
      exports.BorshSerializer = BorshSerializer2;
    }
  });

  // ../../node_modules/borsh/lib/cjs/deserialize.js
  var require_deserialize = __commonJS({
    "../../node_modules/borsh/lib/cjs/deserialize.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.BorshDeserializer = void 0;
      var types_js_1 = require_types();
      var buffer_js_1 = require_buffer();
      var BorshDeserializer2 = (
        /** @class */
        function() {
          function BorshDeserializer3(bufferArray) {
            this.buffer = new buffer_js_1.DecodeBuffer(bufferArray);
          }
          BorshDeserializer3.prototype.decode = function(schema) {
            return this.decode_value(schema);
          };
          BorshDeserializer3.prototype.decode_value = function(schema) {
            if (typeof schema === "string") {
              if (types_js_1.integers.includes(schema))
                return this.decode_integer(schema);
              if (schema === "string")
                return this.decode_string();
              if (schema === "bool")
                return this.decode_boolean();
            }
            if (typeof schema === "object") {
              if ("option" in schema)
                return this.decode_option(schema);
              if ("enum" in schema)
                return this.decode_enum(schema);
              if ("array" in schema)
                return this.decode_array(schema);
              if ("set" in schema)
                return this.decode_set(schema);
              if ("map" in schema)
                return this.decode_map(schema);
              if ("struct" in schema)
                return this.decode_struct(schema);
            }
            throw new Error("Unsupported type: ".concat(schema));
          };
          BorshDeserializer3.prototype.decode_integer = function(schema) {
            var size = parseInt(schema.substring(1));
            if (size <= 32 || schema == "f64") {
              return this.buffer.consume_value(schema);
            }
            return this.decode_bigint(size, schema.startsWith("i"));
          };
          BorshDeserializer3.prototype.decode_bigint = function(size, signed) {
            if (signed === void 0) {
              signed = false;
            }
            var buffer_len = size / 8;
            var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
            var bits = buffer.reduceRight(function(r, x) {
              return r + x.toString(16).padStart(2, "0");
            }, "");
            if (signed && buffer[buffer_len - 1]) {
              return BigInt.asIntN(size, BigInt("0x".concat(bits)));
            }
            return BigInt("0x".concat(bits));
          };
          BorshDeserializer3.prototype.decode_string = function() {
            var len = this.decode_integer("u32");
            var buffer = new Uint8Array(this.buffer.consume_bytes(len));
            var codePoints = [];
            for (var i = 0; i < len; ++i) {
              var byte = buffer[i];
              if (byte < 128) {
                codePoints.push(byte);
              } else if (byte < 224) {
                codePoints.push((byte & 31) << 6 | buffer[++i] & 63);
              } else if (byte < 240) {
                codePoints.push((byte & 15) << 12 | (buffer[++i] & 63) << 6 | buffer[++i] & 63);
              } else {
                var codePoint = (byte & 7) << 18 | (buffer[++i] & 63) << 12 | (buffer[++i] & 63) << 6 | buffer[++i] & 63;
                codePoints.push(codePoint);
              }
            }
            return String.fromCodePoint.apply(String, codePoints);
          };
          BorshDeserializer3.prototype.decode_boolean = function() {
            return this.buffer.consume_value("u8") > 0;
          };
          BorshDeserializer3.prototype.decode_option = function(schema) {
            var option = this.buffer.consume_value("u8");
            if (option === 1) {
              return this.decode_value(schema.option);
            }
            if (option !== 0) {
              throw new Error("Invalid option ".concat(option));
            }
            return null;
          };
          BorshDeserializer3.prototype.decode_enum = function(schema) {
            var _a;
            var valueIndex = this.buffer.consume_value("u8");
            if (valueIndex > schema["enum"].length) {
              throw new Error("Enum option ".concat(valueIndex, " is not available"));
            }
            var struct = schema["enum"][valueIndex].struct;
            var key = Object.keys(struct)[0];
            return _a = {}, _a[key] = this.decode_value(struct[key]), _a;
          };
          BorshDeserializer3.prototype.decode_array = function(schema) {
            var result = [];
            var len = schema.array.len ? schema.array.len : this.decode_integer("u32");
            for (var i = 0; i < len; ++i) {
              result.push(this.decode_value(schema.array.type));
            }
            return result;
          };
          BorshDeserializer3.prototype.decode_set = function(schema) {
            var len = this.decode_integer("u32");
            var result = /* @__PURE__ */ new Set();
            for (var i = 0; i < len; ++i) {
              result.add(this.decode_value(schema.set));
            }
            return result;
          };
          BorshDeserializer3.prototype.decode_map = function(schema) {
            var len = this.decode_integer("u32");
            var result = /* @__PURE__ */ new Map();
            for (var i = 0; i < len; ++i) {
              var key = this.decode_value(schema.map.key);
              var value = this.decode_value(schema.map.value);
              result.set(key, value);
            }
            return result;
          };
          BorshDeserializer3.prototype.decode_struct = function(schema) {
            var result = {};
            for (var key in schema.struct) {
              result[key] = this.decode_value(schema.struct[key]);
            }
            return result;
          };
          return BorshDeserializer3;
        }()
      );
      exports.BorshDeserializer = BorshDeserializer2;
    }
  });

  // ../../node_modules/borsh/lib/cjs/index.js
  var require_cjs = __commonJS({
    "../../node_modules/borsh/lib/cjs/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule) return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      exports.__esModule = true;
      exports.deserialize = exports.serialize = void 0;
      var serialize_js_1 = require_serialize();
      var deserialize_js_1 = require_deserialize();
      var utils = __importStar(require_utils7());
      function serialize2(schema, value, validate) {
        if (validate === void 0) {
          validate = true;
        }
        if (validate)
          utils.validate_schema(schema);
        var serializer = new serialize_js_1.BorshSerializer(validate);
        return serializer.encode(value, schema);
      }
      exports.serialize = serialize2;
      function deserialize2(schema, buffer, validate) {
        if (validate === void 0) {
          validate = true;
        }
        if (validate)
          utils.validate_schema(schema);
        var deserializer = new deserialize_js_1.BorshDeserializer(buffer);
        return deserializer.decode(schema);
      }
      exports.deserialize = deserialize2;
    }
  });

  // ../../node_modules/@near-js/transactions/lib/commonjs/prefix.cjs
  var require_prefix = __commonJS({
    "../../node_modules/@near-js/transactions/lib/commonjs/prefix.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DelegateActionPrefix = void 0;
      var ACTIONABLE_MESSAGE_BASE = Math.pow(2, 30);
      var NEP = {
        MetaTransactions: 366
      };
      var NEPPrefix = class {
        prefix;
        constructor({ prefix }) {
          this.prefix = prefix;
        }
      };
      var ActionableMessagePrefix = class extends NEPPrefix {
        /** Given the NEP number, set the prefix using 2^30 as the offset **/
        constructor(prefix) {
          super({ prefix: ACTIONABLE_MESSAGE_BASE + prefix });
        }
      };
      var DelegateActionPrefix = class extends ActionableMessagePrefix {
        constructor() {
          super(NEP.MetaTransactions);
        }
      };
      exports.DelegateActionPrefix = DelegateActionPrefix;
    }
  });

  // ../../node_modules/@near-js/transactions/lib/commonjs/schema.cjs
  var require_schema = __commonJS({
    "../../node_modules/@near-js/transactions/lib/commonjs/schema.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SCHEMA = exports.SignedTransaction = exports.Transaction = exports.decodeSignedTransaction = exports.decodeTransaction = exports.encodeTransaction = exports.encodeSignedDelegate = exports.encodeDelegateAction = void 0;
      var borsh_1 = require_cjs();
      var prefix_1 = require_prefix();
      function encodeDelegateAction2(delegateAction) {
        return new Uint8Array([
          ...(0, borsh_1.serialize)(exports.SCHEMA.DelegateActionPrefix, new prefix_1.DelegateActionPrefix()),
          ...(0, borsh_1.serialize)(exports.SCHEMA.DelegateAction, delegateAction)
        ]);
      }
      exports.encodeDelegateAction = encodeDelegateAction2;
      function encodeSignedDelegate2(signedDelegate2) {
        return (0, borsh_1.serialize)(exports.SCHEMA.SignedDelegate, signedDelegate2);
      }
      exports.encodeSignedDelegate = encodeSignedDelegate2;
      function encodeTransaction2(transaction) {
        const schema = transaction instanceof SignedTransaction2 ? exports.SCHEMA.SignedTransaction : exports.SCHEMA.Transaction;
        return (0, borsh_1.serialize)(schema, transaction);
      }
      exports.encodeTransaction = encodeTransaction2;
      function decodeTransaction2(bytes2) {
        return new Transaction2((0, borsh_1.deserialize)(exports.SCHEMA.Transaction, bytes2));
      }
      exports.decodeTransaction = decodeTransaction2;
      function decodeSignedTransaction2(bytes2) {
        return new SignedTransaction2((0, borsh_1.deserialize)(exports.SCHEMA.SignedTransaction, bytes2));
      }
      exports.decodeSignedTransaction = decodeSignedTransaction2;
      var Transaction2 = class {
        signerId;
        publicKey;
        nonce;
        receiverId;
        actions;
        blockHash;
        constructor({ signerId, publicKey, nonce, receiverId, actions, blockHash }) {
          this.signerId = signerId;
          this.publicKey = publicKey;
          this.nonce = nonce;
          this.receiverId = receiverId;
          this.actions = actions;
          this.blockHash = blockHash;
        }
        encode() {
          return encodeTransaction2(this);
        }
        static decode(bytes2) {
          return decodeTransaction2(bytes2);
        }
      };
      exports.Transaction = Transaction2;
      var SignedTransaction2 = class {
        transaction;
        signature;
        constructor({ transaction, signature }) {
          this.transaction = transaction;
          this.signature = signature;
        }
        encode() {
          return encodeTransaction2(this);
        }
        static decode(bytes2) {
          return decodeSignedTransaction2(bytes2);
        }
      };
      exports.SignedTransaction = SignedTransaction2;
      exports.SCHEMA = new class BorshSchema {
        Ed25519Signature = {
          struct: {
            data: { array: { type: "u8", len: 64 } }
          }
        };
        Secp256k1Signature = {
          struct: {
            data: { array: { type: "u8", len: 65 } }
          }
        };
        Signature = {
          enum: [
            { struct: { ed25519Signature: this.Ed25519Signature } },
            { struct: { secp256k1Signature: this.Secp256k1Signature } }
          ]
        };
        Ed25519Data = {
          struct: {
            data: { array: { type: "u8", len: 32 } }
          }
        };
        Secp256k1Data = {
          struct: {
            data: { array: { type: "u8", len: 64 } }
          }
        };
        PublicKey = {
          enum: [
            { struct: { ed25519Key: this.Ed25519Data } },
            { struct: { secp256k1Key: this.Secp256k1Data } }
          ]
        };
        FunctionCallPermission = {
          struct: {
            allowance: { option: "u128" },
            receiverId: "string",
            methodNames: { array: { type: "string" } }
          }
        };
        FullAccessPermission = {
          struct: {}
        };
        AccessKeyPermission = {
          enum: [
            { struct: { functionCall: this.FunctionCallPermission } },
            { struct: { fullAccess: this.FullAccessPermission } }
          ]
        };
        AccessKey = {
          struct: {
            nonce: "u64",
            permission: this.AccessKeyPermission
          }
        };
        CreateAccount = {
          struct: {}
        };
        DeployContract = {
          struct: {
            code: { array: { type: "u8" } }
          }
        };
        FunctionCall = {
          struct: {
            methodName: "string",
            args: { array: { type: "u8" } },
            gas: "u64",
            deposit: "u128"
          }
        };
        Transfer = {
          struct: {
            deposit: "u128"
          }
        };
        Stake = {
          struct: {
            stake: "u128",
            publicKey: this.PublicKey
          }
        };
        AddKey = {
          struct: {
            publicKey: this.PublicKey,
            accessKey: this.AccessKey
          }
        };
        DeleteKey = {
          struct: {
            publicKey: this.PublicKey
          }
        };
        DeleteAccount = {
          struct: {
            beneficiaryId: "string"
          }
        };
        DelegateActionPrefix = {
          struct: {
            prefix: "u32"
          }
        };
        ClassicActions = {
          enum: [
            { struct: { createAccount: this.CreateAccount } },
            { struct: { deployContract: this.DeployContract } },
            { struct: { functionCall: this.FunctionCall } },
            { struct: { transfer: this.Transfer } },
            { struct: { stake: this.Stake } },
            { struct: { addKey: this.AddKey } },
            { struct: { deleteKey: this.DeleteKey } },
            { struct: { deleteAccount: this.DeleteAccount } }
          ]
        };
        DelegateAction = {
          struct: {
            senderId: "string",
            receiverId: "string",
            actions: { array: { type: this.ClassicActions } },
            nonce: "u64",
            maxBlockHeight: "u64",
            publicKey: this.PublicKey
          }
        };
        SignedDelegate = {
          struct: {
            delegateAction: this.DelegateAction,
            signature: this.Signature
          }
        };
        Action = {
          enum: [
            { struct: { createAccount: this.CreateAccount } },
            { struct: { deployContract: this.DeployContract } },
            { struct: { functionCall: this.FunctionCall } },
            { struct: { transfer: this.Transfer } },
            { struct: { stake: this.Stake } },
            { struct: { addKey: this.AddKey } },
            { struct: { deleteKey: this.DeleteKey } },
            { struct: { deleteAccount: this.DeleteAccount } },
            { struct: { signedDelegate: this.SignedDelegate } }
          ]
        };
        Transaction = {
          struct: {
            signerId: "string",
            publicKey: this.PublicKey,
            nonce: "u64",
            receiverId: "string",
            blockHash: { array: { type: "u8", len: 32 } },
            actions: { array: { type: this.Action } }
          }
        };
        SignedTransaction = {
          struct: {
            transaction: this.Transaction,
            signature: this.Signature
          }
        };
      }();
    }
  });

  // ../../node_modules/@near-js/transactions/lib/commonjs/create_transaction.cjs
  var require_create_transaction = __commonJS({
    "../../node_modules/@near-js/transactions/lib/commonjs/create_transaction.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createTransaction = void 0;
      var schema_1 = require_schema();
      function createTransaction2(signerId, publicKey, receiverId, nonce, actions, blockHash) {
        const txNonce = typeof nonce === "bigint" ? nonce : BigInt(nonce);
        return new schema_1.Transaction({
          signerId,
          publicKey,
          nonce: txNonce,
          receiverId,
          actions,
          blockHash
        });
      }
      exports.createTransaction = createTransaction2;
    }
  });

  // ../../node_modules/@near-js/transactions/lib/commonjs/delegate.cjs
  var require_delegate = __commonJS({
    "../../node_modules/@near-js/transactions/lib/commonjs/delegate.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.buildDelegateAction = exports.DelegateAction = void 0;
      var action_creators_1 = require_action_creators();
      var { addKey: addKey5, createAccount: createAccount4, deleteAccount: deleteAccount4, deleteKey: deleteKey5, deployContract: deployContract6, functionCall: functionCall6, stake: stake4, transfer: transfer4 } = action_creators_1.actionCreators;
      var DelegateAction2 = class {
        senderId;
        receiverId;
        actions;
        nonce;
        maxBlockHeight;
        publicKey;
        constructor({ senderId, receiverId, actions, nonce, maxBlockHeight, publicKey }) {
          this.senderId = senderId;
          this.receiverId = receiverId;
          this.actions = actions;
          this.nonce = nonce;
          this.maxBlockHeight = maxBlockHeight;
          this.publicKey = publicKey;
        }
      };
      exports.DelegateAction = DelegateAction2;
      function buildDelegateAction2({ actions, maxBlockHeight, nonce, publicKey, receiverId, senderId }) {
        return new DelegateAction2({
          senderId,
          receiverId,
          actions: actions.map((a) => {
            if (!a.type && !a.params) {
              return a;
            }
            switch (a.type) {
              case "AddKey": {
                const { publicKey: publicKey2, accessKey } = a.params;
                return addKey5(publicKey2, accessKey);
              }
              case "CreateAccount": {
                return createAccount4(a.params.createAccount);
              }
              case "DeleteAccount": {
                return deleteAccount4(a.params.deleteAccount);
              }
              case "DeleteKey": {
                return deleteKey5(a.params.publicKey);
              }
              case "DeployContract": {
                return deployContract6(a.params.code);
              }
              case "FunctionCall": {
                const { methodName, args, gas, deposit } = a.params;
                return functionCall6(methodName, args, gas, deposit);
              }
              case "Stake": {
                return stake4(a.params.stake, a.params.publicKey);
              }
              case "Transfer": {
                const { deposit } = a.params;
                return transfer4(deposit);
              }
            }
            throw new Error("Unrecognized action");
          }),
          nonce,
          maxBlockHeight,
          publicKey
        });
      }
      exports.buildDelegateAction = buildDelegateAction2;
    }
  });

  // ../../node_modules/@near-js/transactions/node_modules/@noble/hashes/_assert.js
  var require_assert2 = __commonJS({
    "../../node_modules/@near-js/transactions/node_modules/@noble/hashes/_assert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports.bool = bool;
      function isBytes4(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function bytes2(b, ...lengths) {
        if (!isBytes4(b))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports.bytes = bytes2;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports.hash = hash;
      function exists2(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports.exists = exists2;
      function output2(out, instance) {
        bytes2(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      exports.output = output2;
      var assert = { number, bool, bytes: bytes2, hash, exists: exists2, output: output2 };
      exports.default = assert;
    }
  });

  // ../../node_modules/@near-js/transactions/node_modules/@noble/hashes/crypto.js
  var require_crypto2 = __commonJS({
    "../../node_modules/@near-js/transactions/node_modules/@noble/hashes/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // ../../node_modules/@near-js/transactions/node_modules/@noble/hashes/utils.js
  var require_utils8 = __commonJS({
    "../../node_modules/@near-js/transactions/node_modules/@noble/hashes/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
      var crypto_1 = require_crypto2();
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports.u32 = u32;
      function isBytes4(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      var createView4 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.createView = createView4;
      var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
      exports.rotr = rotr2;
      exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex3(bytes2) {
        if (!isBytes4(bytes2))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes2.length; i++) {
          hex += hexes3[bytes2[i]];
        }
        return hex;
      }
      exports.bytesToHex = bytesToHex3;
      var asciis2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase162(char) {
        if (char >= asciis2._0 && char <= asciis2._9)
          return char - asciis2._0;
        if (char >= asciis2._A && char <= asciis2._F)
          return char - (asciis2._A - 10);
        if (char >= asciis2._a && char <= asciis2._f)
          return char - (asciis2._a - 10);
        return;
      }
      function hexToBytes3(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase162(hex.charCodeAt(hi));
          const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      exports.hexToBytes = hexToBytes3;
      var nextTick = async () => {
      };
      exports.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      exports.asyncLoop = asyncLoop;
      function utf8ToBytes4(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports.utf8ToBytes = utf8ToBytes4;
      function toBytes4(data) {
        if (typeof data === "string")
          data = utf8ToBytes4(data);
        if (!isBytes4(data))
          throw new Error(`expected Uint8Array, got ${typeof data}`);
        return data;
      }
      exports.toBytes = toBytes4;
      function concatBytes5(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          if (!isBytes4(a))
            throw new Error("Uint8Array expected");
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      exports.concatBytes = concatBytes5;
      var Hash4 = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports.Hash = Hash4;
      var toStr2 = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr2.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports.checkOpts = checkOpts;
      function wrapConstructor4(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports.wrapConstructor = wrapConstructor4;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes3(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports.randomBytes = randomBytes3;
    }
  });

  // ../../node_modules/@near-js/transactions/node_modules/@noble/hashes/_sha2.js
  var require_sha22 = __commonJS({
    "../../node_modules/@near-js/transactions/node_modules/@noble/hashes/_sha2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA2 = void 0;
      var _assert_js_1 = require_assert2();
      var utils_js_1 = require_utils8();
      function setBigUint644(view, byteOffset, value, isLE2) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE2);
        const _32n3 = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n3 & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE2 ? 4 : 0;
        const l = isLE2 ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE2);
        view.setUint32(byteOffset + l, wl, isLE2);
      }
      var SHA22 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE2) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE2;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE: isLE2 } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint644(view, blockLen - 8, BigInt(this.length * 8), isLE2);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE2);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports.SHA2 = SHA22;
    }
  });

  // ../../node_modules/@near-js/transactions/node_modules/@noble/hashes/sha256.js
  var require_sha256 = __commonJS({
    "../../node_modules/@near-js/transactions/node_modules/@noble/hashes/sha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha224 = exports.sha256 = void 0;
      var _sha2_js_1 = require_sha22();
      var utils_js_1 = require_utils8();
      var Chi2 = (a, b, c) => a & b ^ ~a & c;
      var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
      var SHA256_K2 = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
      var SHA2562 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W2[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W2[i - 15];
            const W2 = SHA256_W2[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj2(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W2.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA224 = class extends SHA2562 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA2562());
      exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
    }
  });

  // ../../node_modules/@near-js/transactions/lib/commonjs/signature.cjs
  var require_signature3 = __commonJS({
    "../../node_modules/@near-js/transactions/lib/commonjs/signature.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signature = void 0;
      var crypto_1 = require_commonjs3();
      var types_1 = require_commonjs();
      function resolveEnumKeyName3(keyType) {
        switch (keyType) {
          case crypto_1.KeyType.ED25519: {
            return "ed25519Signature";
          }
          case crypto_1.KeyType.SECP256K1: {
            return "secp256k1Signature";
          }
          default: {
            throw Error(`unknown type ${keyType}`);
          }
        }
      }
      var Signature = class extends types_1.Enum {
        enum;
        ed25519Signature;
        secp256k1Signature;
        constructor(signature) {
          const keyName = resolveEnumKeyName3(signature.keyType);
          super({ [keyName]: signature });
          this[keyName] = signature;
          this.enum = keyName;
        }
        get signature() {
          return this.ed25519Signature || this.secp256k1Signature;
        }
        get signatureType() {
          return this.signature.keyType;
        }
        get data() {
          return this.signature.data;
        }
      };
      exports.Signature = Signature;
    }
  });

  // ../../node_modules/@near-js/transactions/lib/commonjs/sign.cjs
  var require_sign = __commonJS({
    "../../node_modules/@near-js/transactions/lib/commonjs/sign.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.signDelegateAction = exports.signTransaction = void 0;
      var sha256_1 = require_sha256();
      var actions_1 = require_actions();
      var create_transaction_1 = require_create_transaction();
      var schema_1 = require_schema();
      var signature_1 = require_signature3();
      var crypto_1 = require_commonjs3();
      async function signTransactionObject2(transaction, signer, accountId, networkId) {
        const message = (0, schema_1.encodeTransaction)(transaction);
        const hash = new Uint8Array((0, sha256_1.sha256)(message));
        const signature = await signer.signMessage(message, accountId, networkId);
        const keyType = transaction.publicKey.ed25519Key ? crypto_1.KeyType.ED25519 : crypto_1.KeyType.SECP256K1;
        const signedTx = new schema_1.SignedTransaction({
          transaction,
          signature: new signature_1.Signature({ keyType, data: signature.signature })
        });
        return [hash, signedTx];
      }
      async function signTransaction2(...args) {
        if (args[0].constructor === schema_1.Transaction) {
          const [transaction, signer, accountId, networkId] = args;
          return signTransactionObject2(transaction, signer, accountId, networkId);
        } else {
          const [receiverId, nonce, actions, blockHash, signer, accountId, networkId] = args;
          const publicKey = await signer.getPublicKey(accountId, networkId);
          const transaction = (0, create_transaction_1.createTransaction)(accountId, publicKey, receiverId, nonce, actions, blockHash);
          return signTransactionObject2(transaction, signer, accountId, networkId);
        }
      }
      exports.signTransaction = signTransaction2;
      async function signDelegateAction2({ delegateAction, signer }) {
        const message = (0, schema_1.encodeDelegateAction)(delegateAction);
        const signature = await signer.sign(message);
        const keyType = delegateAction.publicKey.ed25519Key ? crypto_1.KeyType.ED25519 : crypto_1.KeyType.SECP256K1;
        const signedDelegateAction = new actions_1.SignedDelegate({
          delegateAction,
          signature: new signature_1.Signature({
            keyType,
            data: signature
          })
        });
        return {
          hash: new Uint8Array((0, sha256_1.sha256)(message)),
          signedDelegateAction
        };
      }
      exports.signDelegateAction = signDelegateAction2;
    }
  });

  // ../../node_modules/@near-js/transactions/lib/commonjs/index.cjs
  var require_commonjs4 = __commonJS({
    "../../node_modules/@near-js/transactions/lib/commonjs/index.cjs"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_action_creators(), exports);
      __exportStar(require_actions(), exports);
      __exportStar(require_create_transaction(), exports);
      __exportStar(require_delegate(), exports);
      __exportStar(require_schema(), exports);
      __exportStar(require_sign(), exports);
      __exportStar(require_signature3(), exports);
    }
  });

  // ../../node_modules/@near-js/providers/lib/commonjs/provider.cjs
  var require_provider3 = __commonJS({
    "../../node_modules/@near-js/providers/lib/commonjs/provider.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Provider = void 0;
      var Provider2 = class {
      };
      exports.Provider = Provider2;
    }
  });

  // ../../node_modules/exponential-backoff/dist/options.js
  var require_options = __commonJS({
    "../../node_modules/exponential-backoff/dist/options.js"(exports) {
      "use strict";
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var defaultOptions = {
        delayFirstAttempt: false,
        jitter: "none",
        maxDelay: Infinity,
        numOfAttempts: 10,
        retry: function() {
          return true;
        },
        startingDelay: 100,
        timeMultiple: 2
      };
      function getSanitizedOptions(options) {
        var sanitized = __assign(__assign({}, defaultOptions), options);
        if (sanitized.numOfAttempts < 1) {
          sanitized.numOfAttempts = 1;
        }
        return sanitized;
      }
      exports.getSanitizedOptions = getSanitizedOptions;
    }
  });

  // ../../node_modules/exponential-backoff/dist/jitter/full/full.jitter.js
  var require_full_jitter = __commonJS({
    "../../node_modules/exponential-backoff/dist/jitter/full/full.jitter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function fullJitter(delay) {
        var jitteredDelay = Math.random() * delay;
        return Math.round(jitteredDelay);
      }
      exports.fullJitter = fullJitter;
    }
  });

  // ../../node_modules/exponential-backoff/dist/jitter/no/no.jitter.js
  var require_no_jitter = __commonJS({
    "../../node_modules/exponential-backoff/dist/jitter/no/no.jitter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function noJitter(delay) {
        return delay;
      }
      exports.noJitter = noJitter;
    }
  });

  // ../../node_modules/exponential-backoff/dist/jitter/jitter.factory.js
  var require_jitter_factory = __commonJS({
    "../../node_modules/exponential-backoff/dist/jitter/jitter.factory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var full_jitter_1 = require_full_jitter();
      var no_jitter_1 = require_no_jitter();
      function JitterFactory(options) {
        switch (options.jitter) {
          case "full":
            return full_jitter_1.fullJitter;
          case "none":
          default:
            return no_jitter_1.noJitter;
        }
      }
      exports.JitterFactory = JitterFactory;
    }
  });

  // ../../node_modules/exponential-backoff/dist/delay/delay.base.js
  var require_delay_base = __commonJS({
    "../../node_modules/exponential-backoff/dist/delay/delay.base.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var jitter_factory_1 = require_jitter_factory();
      var Delay = (
        /** @class */
        function() {
          function Delay2(options) {
            this.options = options;
            this.attempt = 0;
          }
          Delay2.prototype.apply = function() {
            var _this = this;
            return new Promise(function(resolve) {
              return setTimeout(resolve, _this.jitteredDelay);
            });
          };
          Delay2.prototype.setAttemptNumber = function(attempt) {
            this.attempt = attempt;
          };
          Object.defineProperty(Delay2.prototype, "jitteredDelay", {
            get: function() {
              var jitter = jitter_factory_1.JitterFactory(this.options);
              return jitter(this.delay);
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Delay2.prototype, "delay", {
            get: function() {
              var constant = this.options.startingDelay;
              var base2 = this.options.timeMultiple;
              var power = this.numOfDelayedAttempts;
              var delay = constant * Math.pow(base2, power);
              return Math.min(delay, this.options.maxDelay);
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Delay2.prototype, "numOfDelayedAttempts", {
            get: function() {
              return this.attempt;
            },
            enumerable: true,
            configurable: true
          });
          return Delay2;
        }()
      );
      exports.Delay = Delay;
    }
  });

  // ../../node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js
  var require_skip_first_delay = __commonJS({
    "../../node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1) throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var delay_base_1 = require_delay_base();
      var SkipFirstDelay = (
        /** @class */
        function(_super) {
          __extends2(SkipFirstDelay2, _super);
          function SkipFirstDelay2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          SkipFirstDelay2.prototype.apply = function() {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a) {
                return [2, this.isFirstAttempt ? true : _super.prototype.apply.call(this)];
              });
            });
          };
          Object.defineProperty(SkipFirstDelay2.prototype, "isFirstAttempt", {
            get: function() {
              return this.attempt === 0;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(SkipFirstDelay2.prototype, "numOfDelayedAttempts", {
            get: function() {
              return this.attempt - 1;
            },
            enumerable: true,
            configurable: true
          });
          return SkipFirstDelay2;
        }(delay_base_1.Delay)
      );
      exports.SkipFirstDelay = SkipFirstDelay;
    }
  });

  // ../../node_modules/exponential-backoff/dist/delay/always/always.delay.js
  var require_always_delay = __commonJS({
    "../../node_modules/exponential-backoff/dist/delay/always/always.delay.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      var delay_base_1 = require_delay_base();
      var AlwaysDelay = (
        /** @class */
        function(_super) {
          __extends2(AlwaysDelay2, _super);
          function AlwaysDelay2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          return AlwaysDelay2;
        }(delay_base_1.Delay)
      );
      exports.AlwaysDelay = AlwaysDelay;
    }
  });

  // ../../node_modules/exponential-backoff/dist/delay/delay.factory.js
  var require_delay_factory = __commonJS({
    "../../node_modules/exponential-backoff/dist/delay/delay.factory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var skip_first_delay_1 = require_skip_first_delay();
      var always_delay_1 = require_always_delay();
      function DelayFactory(options, attempt) {
        var delay = initDelayClass(options);
        delay.setAttemptNumber(attempt);
        return delay;
      }
      exports.DelayFactory = DelayFactory;
      function initDelayClass(options) {
        if (!options.delayFirstAttempt) {
          return new skip_first_delay_1.SkipFirstDelay(options);
        }
        return new always_delay_1.AlwaysDelay(options);
      }
    }
  });

  // ../../node_modules/exponential-backoff/dist/backoff.js
  var require_backoff = __commonJS({
    "../../node_modules/exponential-backoff/dist/backoff.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1) throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var options_1 = require_options();
      var delay_factory_1 = require_delay_factory();
      function backOff(request, options) {
        if (options === void 0) {
          options = {};
        }
        return __awaiter(this, void 0, void 0, function() {
          var sanitizedOptions, backOff2;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                sanitizedOptions = options_1.getSanitizedOptions(options);
                backOff2 = new BackOff(request, sanitizedOptions);
                return [4, backOff2.execute()];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      }
      exports.backOff = backOff;
      var BackOff = (
        /** @class */
        function() {
          function BackOff2(request, options) {
            this.request = request;
            this.options = options;
            this.attemptNumber = 0;
          }
          BackOff2.prototype.execute = function() {
            return __awaiter(this, void 0, void 0, function() {
              var e_1, shouldRetry;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!!this.attemptLimitReached) return [3, 7];
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 4, , 6]);
                    return [4, this.applyDelay()];
                  case 2:
                    _a.sent();
                    return [4, this.request()];
                  case 3:
                    return [2, _a.sent()];
                  case 4:
                    e_1 = _a.sent();
                    this.attemptNumber++;
                    return [4, this.options.retry(e_1, this.attemptNumber)];
                  case 5:
                    shouldRetry = _a.sent();
                    if (!shouldRetry || this.attemptLimitReached) {
                      throw e_1;
                    }
                    return [3, 6];
                  case 6:
                    return [3, 0];
                  case 7:
                    throw new Error("Something went wrong.");
                }
              });
            });
          };
          Object.defineProperty(BackOff2.prototype, "attemptLimitReached", {
            get: function() {
              return this.attemptNumber >= this.options.numOfAttempts;
            },
            enumerable: true,
            configurable: true
          });
          BackOff2.prototype.applyDelay = function() {
            return __awaiter(this, void 0, void 0, function() {
              var delay;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    delay = delay_factory_1.DelayFactory(this.options, this.attemptNumber);
                    return [4, delay.apply()];
                  case 1:
                    _a.sent();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          return BackOff2;
        }()
      );
    }
  });

  // ../../node_modules/unfetch/dist/unfetch.module.js
  var unfetch_module_exports = {};
  __export(unfetch_module_exports, {
    default: () => unfetch_module_default
  });
  function unfetch_module_default(e, n) {
    return n = n || {}, new Promise(function(t, r) {
      var s = new XMLHttpRequest(), o = [], u = [], i = {}, a = function() {
        return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {
          return Promise.resolve(s.responseText);
        }, json: function() {
          return Promise.resolve(s.responseText).then(JSON.parse);
        }, blob: function() {
          return Promise.resolve(new Blob([s.response]));
        }, clone: a, headers: { keys: function() {
          return o;
        }, entries: function() {
          return u;
        }, get: function(e2) {
          return i[e2.toLowerCase()];
        }, has: function(e2) {
          return e2.toLowerCase() in i;
        } } };
      };
      for (var l in s.open(n.method || "get", e, true), s.onload = function() {
        s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e2, n2, t2) {
          o.push(n2 = n2.toLowerCase()), u.push([n2, t2]), i[n2] = i[n2] ? i[n2] + "," + t2 : t2;
        }), t(a());
      }, s.onerror = r, s.withCredentials = "include" == n.credentials, n.headers) s.setRequestHeader(l, n.headers[l]);
      s.send(n.body || null);
    });
  }
  var init_unfetch_module = __esm({
    "../../node_modules/unfetch/dist/unfetch.module.js"() {
    }
  });

  // ../../node_modules/isomorphic-unfetch/browser.js
  var require_browser3 = __commonJS({
    "../../node_modules/isomorphic-unfetch/browser.js"(exports, module) {
      module.exports = self.fetch || (self.fetch = (init_unfetch_module(), __toCommonJS(unfetch_module_exports)).default || (init_unfetch_module(), __toCommonJS(unfetch_module_exports)));
    }
  });

  // ../../node_modules/@near-js/providers/lib/commonjs/fetch_json.cjs
  var require_fetch_json = __commonJS({
    "../../node_modules/@near-js/providers/lib/commonjs/fetch_json.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fetchJsonRpc = void 0;
      var types_1 = require_commonjs();
      var exponential_backoff_1 = require_backoff();
      var isomorphic_unfetch_1 = __importDefault(require_browser3());
      var BACKOFF_MULTIPLIER = 1.5;
      var RETRY_NUMBER = 10;
      var retryConfig = {
        numOfAttempts: RETRY_NUMBER,
        timeMultiple: BACKOFF_MULTIPLIER,
        retry: (e) => {
          if ([503, 408].includes(e.cause)) {
            return true;
          }
          if (e.toString().includes("FetchError") || e.toString().includes("Failed to fetch")) {
            return true;
          }
          return false;
        }
      };
      var ProviderError = class extends Error {
        cause;
        constructor(message, options) {
          super(message, options);
        }
      };
      async function fetchJsonRpc(url, json, headers) {
        const response = await (0, exponential_backoff_1.backOff)(async () => {
          const res = await (0, isomorphic_unfetch_1.default)(url, {
            method: "POST",
            body: JSON.stringify(json),
            headers: { ...headers, "Content-Type": "application/json" }
          });
          const { ok, status } = res;
          if (!ok) {
            throw new ProviderError(await res.text(), { cause: status });
          }
          if (status === 503) {
            throw new ProviderError(`${url} unavailable`, { cause: status });
          } else if (status === 408) {
            throw new ProviderError("Unused connection", { cause: status });
          }
          return res;
        }, retryConfig);
        if (!response) {
          throw new types_1.TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${url}.`, "RetriesExceeded");
        }
        return await response.json();
      }
      exports.fetchJsonRpc = fetchJsonRpc;
    }
  });

  // ../../node_modules/@near-js/providers/lib/commonjs/json-rpc-provider.cjs
  var require_json_rpc_provider = __commonJS({
    "../../node_modules/@near-js/providers/lib/commonjs/json-rpc-provider.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JsonRpcProvider = void 0;
      var utils_1 = require_commonjs2();
      var types_1 = require_commonjs();
      var transactions_1 = require_commonjs4();
      var exponential_backoff_1 = require_exponential_backoff();
      var provider_1 = require_provider3();
      var fetch_json_1 = require_fetch_json();
      var REQUEST_RETRY_NUMBER2 = 12;
      var REQUEST_RETRY_WAIT2 = 500;
      var REQUEST_RETRY_WAIT_BACKOFF2 = 1.5;
      var _nextId2 = 123;
      var JsonRpcProvider2 = class extends provider_1.Provider {
        /** @hidden */
        connection;
        /** @hidden */
        options;
        /**
         * @param connectionInfo Connection info
         */
        constructor(connectionInfo, options) {
          super();
          this.connection = connectionInfo || { url: "" };
          const defaultOptions = {
            retries: REQUEST_RETRY_NUMBER2,
            wait: REQUEST_RETRY_WAIT2,
            backoff: REQUEST_RETRY_WAIT_BACKOFF2
          };
          this.options = Object.assign({}, defaultOptions, options);
        }
        /**
         * Gets the RPC's status
         * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         */
        async status() {
          return this.sendJsonRpc("status", []);
        }
        /**
         * Sends a signed transaction to the RPC
         *
         * @param signedTransaction The signed transaction being sent
         * @param waitUntil
         */
        async sendTransactionUntil(signedTransaction, waitUntil) {
          const bytes2 = (0, transactions_1.encodeTransaction)(signedTransaction);
          return this.sendJsonRpc("send_tx", { signed_tx_base64: Buffer.from(bytes2).toString("base64"), wait_until: waitUntil });
        }
        /**
         * Sends a signed transaction to the RPC and waits until transaction is fully complete
         * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param signedTransaction The signed transaction being sent
         */
        async sendTransaction(signedTransaction) {
          return this.sendTransactionUntil(signedTransaction, "EXECUTED_OPTIMISTIC");
        }
        /**
         * Sends a signed transaction to the RPC and immediately returns transaction hash
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
         * @param signedTransaction The signed transaction being sent
         * @returns {Promise<FinalExecutionOutcome>}
         */
        async sendTransactionAsync(signedTransaction) {
          return this.sendTransactionUntil(signedTransaction, "NONE");
        }
        /**
         * Gets a transaction's status from the RPC
         * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
         * @param accountId The NEAR account that signed the transaction
         * @param waitUntil
         */
        async txStatus(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
          if (typeof txHash === "string") {
            return this.txStatusString(txHash, accountId, waitUntil);
          } else {
            return this.txStatusUint8Array(txHash, accountId, waitUntil);
          }
        }
        async txStatusUint8Array(txHash, accountId, waitUntil) {
          return this.sendJsonRpc("tx", { tx_hash: (0, utils_1.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
        }
        async txStatusString(txHash, accountId, waitUntil) {
          return this.sendJsonRpc("tx", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
        }
        /**
         * Gets a transaction's status from the RPC with receipts
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
         * @param txHash The hash of the transaction
         * @param accountId The NEAR account that signed the transaction
         * @param waitUntil
         * @returns {Promise<FinalExecutionOutcome>}
         */
        async txStatusReceipts(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
          if (typeof txHash === "string") {
            return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
          } else {
            return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: (0, utils_1.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
          }
        }
        /**
         * Query the RPC by passing an {@link "@near-js/types".provider/request.RpcQueryRequest | RpcQueryRequest }
         * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
         *
         * @typeParam T the shape of the returned query response
         */
        async query(...args) {
          let result;
          if (args.length === 1) {
            const { block_id, blockId, ...otherParams } = args[0];
            result = await this.sendJsonRpc("query", { ...otherParams, block_id: block_id || blockId });
          } else {
            const [path, data] = args;
            result = await this.sendJsonRpc("query", [path, data]);
          }
          if (result && result.error) {
            throw new types_1.TypedError(`Querying failed: ${result.error}.
${JSON.stringify(result, null, 2)}`, (0, utils_1.getErrorTypeFromErrorMessage)(result.error, result.error.name));
          }
          return result;
        }
        /**
         * Query for block info from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
         */
        async block(blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("block", { block_id: blockId, finality });
        }
        /**
         * Query changes in block from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         */
        async blockChanges(blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", { block_id: blockId, finality });
        }
        /**
         * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param chunkId Hash of a chunk ID or shard ID
         */
        async chunk(chunkId) {
          return this.sendJsonRpc("chunk", [chunkId]);
        }
        /**
         * Query validators of the epoch defined by the given block id.
         * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        async validators(blockId) {
          return this.sendJsonRpc("validators", [blockId]);
        }
        /**
         * Gets the protocol config at a block from RPC
         *
         * @param blockReference specifies the block to get the protocol config for
         */
        async experimental_protocolConfig(blockReference) {
          const { blockId, ...otherParams } = blockReference;
          return await this.sendJsonRpc("EXPERIMENTAL_protocol_config", { ...otherParams, block_id: blockId });
        }
        /**
         * Gets a light client execution proof for verifying execution outcomes
         * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
         */
        async lightClientProof(request) {
          return await this.sendJsonRpc("EXPERIMENTAL_light_client_proof", request);
        }
        /**
         * Returns the next light client block as far in the future as possible from the last known hash
         * to still be able to validate from that hash. This will either return the last block of the
         * next epoch, or the last final known block.
         *
         * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
         */
        async nextLightClientBlock(request) {
          return await this.sendJsonRpc("next_light_client_block", request);
        }
        /**
         * Gets access key changes for a given array of accountIds
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
         * @returns {Promise<ChangeResult>}
         */
        async accessKeyChanges(accountIdArray, blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "all_access_key_changes",
            account_ids: accountIdArray,
            block_id: blockId,
            finality
          });
        }
        /**
         * Gets single access key changes for a given array of access keys
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
         * @returns {Promise<ChangeResult>}
         */
        async singleAccessKeyChanges(accessKeyArray, blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "single_access_key_changes",
            keys: accessKeyArray,
            block_id: blockId,
            finality
          });
        }
        /**
         * Gets account changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
         * @returns {Promise<ChangeResult>}
         */
        async accountChanges(accountIdArray, blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "account_changes",
            account_ids: accountIdArray,
            block_id: blockId,
            finality
          });
        }
        /**
         * Gets contract state changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: If you pass a keyPrefix it must be base64 encoded
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
         * @returns {Promise<ChangeResult>}
         */
        async contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "data_changes",
            account_ids: accountIdArray,
            key_prefix_base64: keyPrefix,
            block_id: blockId,
            finality
          });
        }
        /**
         * Gets contract code changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: Change is returned in a base64 encoded WASM file
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
         * @returns {Promise<ChangeResult>}
         */
        async contractCodeChanges(accountIdArray, blockQuery) {
          const { finality } = blockQuery;
          const { blockId } = blockQuery;
          return this.sendJsonRpc("EXPERIMENTAL_changes", {
            changes_type: "contract_code_changes",
            account_ids: accountIdArray,
            block_id: blockId,
            finality
          });
        }
        /**
         * Returns gas price for a specific block_height or block_hash.
         * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        async gasPrice(blockId) {
          return await this.sendJsonRpc("gas_price", [blockId]);
        }
        /**
         * Directly call the RPC specifying the method and params
         *
         * @param method RPC method
         * @param params Parameters to the method
         */
        async sendJsonRpc(method, params2) {
          const response = await (0, exponential_backoff_1.exponentialBackoff)(this.options.wait, this.options.retries, this.options.backoff, async () => {
            try {
              const request = {
                method,
                params: params2,
                id: _nextId2++,
                jsonrpc: "2.0"
              };
              const response2 = await (0, fetch_json_1.fetchJsonRpc)(this.connection.url, request, this.connection.headers);
              if (response2.error) {
                if (typeof response2.error.data === "object") {
                  if (typeof response2.error.data.error_message === "string" && typeof response2.error.data.error_type === "string") {
                    throw new types_1.TypedError(response2.error.data.error_message, response2.error.data.error_type);
                  }
                  throw (0, utils_1.parseRpcError)(response2.error.data);
                } else {
                  const errorMessage = `[${response2.error.code}] ${response2.error.message}: ${response2.error.data}`;
                  if (response2.error.data === "Timeout" || errorMessage.includes("Timeout error") || errorMessage.includes("query has timed out")) {
                    throw new types_1.TypedError(errorMessage, "TimeoutError");
                  }
                  const errorType = (0, utils_1.getErrorTypeFromErrorMessage)(response2.error.data, "");
                  if (errorType) {
                    throw new types_1.TypedError((0, utils_1.formatError)(errorType, params2), errorType);
                  }
                  throw new types_1.TypedError(errorMessage, response2.error.name);
                }
              } else if (typeof response2.result?.error === "string") {
                const errorType = (0, utils_1.getErrorTypeFromErrorMessage)(response2.result.error, "");
                if (errorType) {
                  throw new utils_1.ServerError((0, utils_1.formatError)(errorType, params2), errorType);
                }
              }
              return response2;
            } catch (error) {
              if (error.type === "TimeoutError") {
                utils_1.Logger.warn(`Retrying request to ${method} as it has timed out`, params2);
                return null;
              }
              throw error;
            }
          });
          const { result } = response;
          if (typeof result === "undefined") {
            throw new types_1.TypedError(`Exceeded ${this.options.retries} attempts for request to ${method}.`, "RetriesExceeded");
          }
          return result;
        }
      };
      exports.JsonRpcProvider = JsonRpcProvider2;
    }
  });

  // ../../node_modules/@near-js/providers/lib/commonjs/failover-rpc-provider.cjs
  var require_failover_rpc_provider = __commonJS({
    "../../node_modules/@near-js/providers/lib/commonjs/failover-rpc-provider.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FailoverRpcProvider = void 0;
      var utils_1 = require_commonjs2();
      var types_1 = require_commonjs();
      var provider_1 = require_provider3();
      var FailoverRpcProvider2 = class extends provider_1.Provider {
        /** @hidden */
        providers;
        currentProviderIndex;
        /**
         * @param providers list of providers
         */
        constructor(providers) {
          super();
          if (providers.length === 0) {
            throw new Error("At least one provider must be specified");
          }
          this.providers = providers;
          this.currentProviderIndex = 0;
        }
        switchToNextProvider() {
          if (this.providers.length === 1)
            return;
          if (this.providers.length - 1 <= this.currentProviderIndex) {
            this.currentProviderIndex = 0;
          } else {
            this.currentProviderIndex += 1;
          }
          utils_1.Logger.debug(`Switched to provider at the index ${this.currentProviderIndex}`);
        }
        get currentProvider() {
          const provider = this.providers[this.currentProviderIndex];
          if (!provider)
            throw new Error(`Provider wasn't found at index ${this.currentProviderIndex}`);
          return provider;
        }
        async withBackoff(getResult) {
          for (let i = 0; i < this.providers.length; i++) {
            try {
              const result = await getResult(this.currentProvider);
              if (result)
                return result;
            } catch (e) {
              console.error(e);
              this.switchToNextProvider();
            }
          }
          throw new types_1.TypedError(`Exceeded ${this.providers.length} providers to execute request`, "RetriesExceeded");
        }
        /**
         * Gets the RPC's status
         * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         */
        async status() {
          return this.withBackoff((currentProvider) => currentProvider.status());
        }
        async sendTransactionUntil(signedTransaction, waitUntil) {
          return this.withBackoff((currentProvider) => currentProvider.sendTransactionUntil(signedTransaction, waitUntil));
        }
        /**
         * Sends a signed transaction to the RPC and waits until transaction is fully complete
         * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param signedTransaction The signed transaction being sent
         */
        async sendTransaction(signedTransaction) {
          return this.withBackoff((currentProvider) => currentProvider.sendTransaction(signedTransaction));
        }
        /**
         * Sends a signed transaction to the RPC and immediately returns transaction hash
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
         * @param signedTransaction The signed transaction being sent
         * @returns {Promise<FinalExecutionOutcome>}
         */
        async sendTransactionAsync(signedTransaction) {
          return this.withBackoff((currentProvider) => currentProvider.sendTransactionAsync(signedTransaction));
        }
        /**
         * Gets a transaction's status from the RPC
         * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
         *
         * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
         * @param accountId The NEAR account that signed the transaction
         */
        async txStatus(txHash, accountId, waitUntil) {
          return this.withBackoff((currentProvider) => currentProvider.txStatus(txHash, accountId, waitUntil));
        }
        /**
         * Gets a transaction's status from the RPC with receipts
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
         * @param txHash The hash of the transaction
         * @param accountId The NEAR account that signed the transaction
         * @returns {Promise<FinalExecutionOutcome>}
         */
        async txStatusReceipts(txHash, accountId, waitUntil) {
          return this.withBackoff((currentProvider) => currentProvider.txStatusReceipts(txHash, accountId, waitUntil));
        }
        async query(paramsOrPath, data) {
          if (data) {
            return this.withBackoff((currentProvider) => currentProvider.query(paramsOrPath, data));
          }
          return this.withBackoff((currentProvider) => currentProvider.query(paramsOrPath));
        }
        /**
         * Query for block info from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
         */
        async block(blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.block(blockQuery));
        }
        /**
         * Query changes in block from the RPC
         * pass block_id OR finality as blockQuery, not both
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         */
        async blockChanges(blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.blockChanges(blockQuery));
        }
        /**
         * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
         * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
         *
         * @param chunkId Hash of a chunk ID or shard ID
         */
        async chunk(chunkId) {
          return this.withBackoff((currentProvider) => currentProvider.chunk(chunkId));
        }
        /**
         * Query validators of the epoch defined by the given block id.
         * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        async validators(blockId) {
          return this.withBackoff((currentProvider) => currentProvider.validators(blockId));
        }
        /**
         * Gets the protocol config at a block from RPC
         *
         * @param blockReference specifies the block to get the protocol config for
         */
        async experimental_protocolConfig(blockReference) {
          return this.withBackoff((currentProvider) => currentProvider.experimental_protocolConfig(blockReference));
        }
        /**
         * Gets a light client execution proof for verifying execution outcomes
         * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
         */
        async lightClientProof(request) {
          return this.withBackoff((currentProvider) => currentProvider.lightClientProof(request));
        }
        /**
         * Returns the next light client block as far in the future as possible from the last known hash
         * to still be able to validate from that hash. This will either return the last block of the
         * next epoch, or the last final known block.
         *
         * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
         */
        async nextLightClientBlock(request) {
          return this.withBackoff((currentProvider) => currentProvider.nextLightClientBlock(request));
        }
        /**
         * Gets access key changes for a given array of accountIds
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
         * @returns {Promise<ChangeResult>}
         */
        async accessKeyChanges(accountIdArray, blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.accessKeyChanges(accountIdArray, blockQuery));
        }
        /**
         * Gets single access key changes for a given array of access keys
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
         * @returns {Promise<ChangeResult>}
         */
        async singleAccessKeyChanges(accessKeyArray, blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.singleAccessKeyChanges(accessKeyArray, blockQuery));
        }
        /**
         * Gets account changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
         * @returns {Promise<ChangeResult>}
         */
        async accountChanges(accountIdArray, blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.accountChanges(accountIdArray, blockQuery));
        }
        /**
         * Gets contract state changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: If you pass a keyPrefix it must be base64 encoded
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
         * @returns {Promise<ChangeResult>}
         */
        async contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
          return this.withBackoff((currentProvider) => currentProvider.contractStateChanges(accountIdArray, blockQuery, keyPrefix));
        }
        /**
         * Gets contract code changes for a given array of accountIds
         * pass block_id OR finality as blockQuery, not both
         * Note: Change is returned in a base64 encoded WASM file
         * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
         * @returns {Promise<ChangeResult>}
         */
        async contractCodeChanges(accountIdArray, blockQuery) {
          return this.withBackoff((currentProvider) => currentProvider.contractCodeChanges(accountIdArray, blockQuery));
        }
        /**
         * Returns gas price for a specific block_height or block_hash.
         * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
         *
         * @param blockId Block hash or height, or null for latest.
         */
        async gasPrice(blockId) {
          return this.withBackoff((currentProvider) => currentProvider.gasPrice(blockId));
        }
      };
      exports.FailoverRpcProvider = FailoverRpcProvider2;
    }
  });

  // ../../node_modules/@near-js/providers/lib/commonjs/index.cjs
  var require_commonjs5 = __commonJS({
    "../../node_modules/@near-js/providers/lib/commonjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Provider = exports.FailoverRpcProvider = exports.JsonRpcProvider = exports.exponentialBackoff = void 0;
      var exponential_backoff_1 = require_exponential_backoff();
      Object.defineProperty(exports, "exponentialBackoff", { enumerable: true, get: function() {
        return exponential_backoff_1.exponentialBackoff;
      } });
      var json_rpc_provider_1 = require_json_rpc_provider();
      Object.defineProperty(exports, "JsonRpcProvider", { enumerable: true, get: function() {
        return json_rpc_provider_1.JsonRpcProvider;
      } });
      var failover_rpc_provider_1 = require_failover_rpc_provider();
      Object.defineProperty(exports, "FailoverRpcProvider", { enumerable: true, get: function() {
        return failover_rpc_provider_1.FailoverRpcProvider;
      } });
      var provider_1 = require_provider3();
      Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
        return provider_1.Provider;
      } });
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/utils.cjs
  var require_utils9 = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/utils.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.viewFunction = exports.viewState = exports.encodeJSContractArgs = exports.validateArgs = void 0;
      var types_1 = require_commonjs();
      var utils_1 = require_commonjs2();
      function parseJsonFromRawResponse2(response) {
        return JSON.parse(Buffer.from(response).toString());
      }
      function bytesJsonStringify2(input) {
        return Buffer.from(JSON.stringify(input));
      }
      function validateArgs2(args) {
        const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
        if (isUint8Array) {
          return;
        }
        if (Array.isArray(args) || typeof args !== "object") {
          throw new types_1.PositionalArgsError();
        }
      }
      exports.validateArgs = validateArgs2;
      function encodeJSContractArgs2(contractId, method, args) {
        return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);
      }
      exports.encodeJSContractArgs = encodeJSContractArgs2;
      async function viewState2(connection, accountId, prefix, blockQuery = { finality: "optimistic" }) {
        const { values } = await connection.provider.query({
          request_type: "view_state",
          ...blockQuery,
          account_id: accountId,
          prefix_base64: Buffer.from(prefix).toString("base64")
        });
        return values.map(({ key, value }) => ({
          key: Buffer.from(key, "base64"),
          value: Buffer.from(value, "base64")
        }));
      }
      exports.viewState = viewState2;
      async function viewFunction2(connection, { contractId, methodName, args = {}, parse: parse3 = parseJsonFromRawResponse2, stringify = bytesJsonStringify2, jsContract = false, blockQuery = { finality: "optimistic" } }) {
        let encodedArgs;
        validateArgs2(args);
        if (jsContract) {
          encodedArgs = encodeJSContractArgs2(contractId, methodName, Object.keys(args).length > 0 ? JSON.stringify(args) : "");
        } else {
          encodedArgs = stringify(args);
        }
        const result = await connection.provider.query({
          request_type: "call_function",
          ...blockQuery,
          account_id: jsContract ? connection.jsvmAccountId : contractId,
          method_name: jsContract ? "view_js_contract" : methodName,
          args_base64: encodedArgs.toString("base64")
        });
        if (result.logs) {
          (0, utils_1.printTxOutcomeLogs)({ contractId, logs: result.logs });
        }
        return result.result && result.result.length > 0 && parse3(Buffer.from(result.result));
      }
      exports.viewFunction = viewFunction2;
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/account.cjs
  var require_account = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/account.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Account = void 0;
      var crypto_1 = require_commonjs3();
      var providers_1 = require_commonjs5();
      var transactions_1 = require_commonjs4();
      var types_1 = require_commonjs();
      var utils_1 = require_commonjs2();
      var utils_2 = require_utils9();
      var { addKey: addKey5, createAccount: createAccount4, deleteAccount: deleteAccount4, deleteKey: deleteKey5, deployContract: deployContract6, fullAccessKey: fullAccessKey4, functionCall: functionCall6, functionCallAccessKey: functionCallAccessKey4, stake: stake4, transfer: transfer4 } = transactions_1.actionCreators;
      var TX_NONCE_RETRY_NUMBER2 = 12;
      var TX_NONCE_RETRY_WAIT2 = 500;
      var TX_NONCE_RETRY_WAIT_BACKOFF2 = 1.5;
      var Account2 = class _Account {
        connection;
        accountId;
        constructor(connection, accountId) {
          this.connection = connection;
          this.accountId = accountId;
        }
        getConnection() {
          return this.connection;
        }
        /**
         * Returns basic NEAR account information via the `view_account` RPC query method
         * @see [https://docs.near.org/api/rpc/contracts#view-account](https://docs.near.org/api/rpc/contracts#view-account)
         */
        async state() {
          return this.connection.provider.query({
            request_type: "view_account",
            account_id: this.accountId,
            finality: "optimistic"
          });
        }
        /**
         * Create a signed transaction which can be broadcast to the network
         * @param receiverId NEAR account receiving the transaction
         * @param actions list of actions to perform as part of the transaction
         * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}
         */
        async signTransaction(receiverId, actions) {
          const accessKeyInfo = await this.findAccessKey(receiverId, actions);
          if (!accessKeyInfo) {
            throw new types_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, "KeyNotFound");
          }
          const { accessKey } = accessKeyInfo;
          const block = await this.connection.provider.block({ finality: "final" });
          const blockHash = block.header.hash;
          const nonce = accessKey.nonce + 1n;
          return await (0, transactions_1.signTransaction)(receiverId, nonce, actions, (0, utils_1.baseDecode)(blockHash), this.connection.signer, this.accountId, this.connection.networkId);
        }
        /**
         * Sign a transaction to perform a list of actions and broadcast it using the RPC API.
         * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider | JsonRpcProvider }
         *
         * @param options The options for signing and sending the transaction.
         * @param options.receiverId The NEAR account ID of the transaction receiver.
         * @param options.actions The list of actions to be performed in the transaction.
         * @param options.returnError Whether to return an error if the transaction fails.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
         */
        async signAndSendTransaction({ receiverId, actions, returnError }) {
          let txHash, signedTx;
          const result = await (0, providers_1.exponentialBackoff)(TX_NONCE_RETRY_WAIT2, TX_NONCE_RETRY_NUMBER2, TX_NONCE_RETRY_WAIT_BACKOFF2, async () => {
            [txHash, signedTx] = await this.signTransaction(receiverId, actions);
            const publicKey = signedTx.transaction.publicKey;
            try {
              return await this.connection.provider.sendTransaction(signedTx);
            } catch (error) {
              if (error.type === "InvalidNonce") {
                utils_1.Logger.warn(`Retrying transaction ${receiverId}:${(0, utils_1.baseEncode)(txHash)} with new nonce.`);
                delete this.accessKeyByPublicKeyCache[publicKey.toString()];
                return null;
              }
              if (error.type === "Expired") {
                utils_1.Logger.warn(`Retrying transaction ${receiverId}:${(0, utils_1.baseEncode)(txHash)} due to expired block hash`);
                return null;
              }
              error.context = new types_1.ErrorContext((0, utils_1.baseEncode)(txHash));
              throw error;
            }
          });
          if (!result) {
            throw new types_1.TypedError("nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.", "RetriesExceeded");
          }
          (0, utils_1.printTxOutcomeLogsAndFailures)({ contractId: signedTx.transaction.receiverId, outcome: result });
          if (!returnError && typeof result.status === "object" && typeof result.status.Failure === "object" && result.status.Failure !== null) {
            if (result.status.Failure.error_message && result.status.Failure.error_type) {
              throw new types_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);
            } else {
              throw (0, utils_1.parseResultError)(result);
            }
          }
          return result;
        }
        /** @hidden */
        accessKeyByPublicKeyCache = {};
        /**
         * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link "@near-js/keystores".keystore.KeyStore | Keystore}.
         *
         * @todo Find matching access key based on transaction (i.e. receiverId and actions)
         *
         * @param receiverId currently unused (see todo)
         * @param actions currently unused (see todo)
         * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async findAccessKey(receiverId, actions) {
          const publicKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
          if (!publicKey) {
            throw new types_1.TypedError(`no matching key pair found in ${this.connection.signer}`, "PublicKeyNotFound");
          }
          const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];
          if (cachedAccessKey !== void 0) {
            return { publicKey, accessKey: cachedAccessKey };
          }
          try {
            const rawAccessKey = await this.connection.provider.query({
              request_type: "view_access_key",
              account_id: this.accountId,
              public_key: publicKey.toString(),
              finality: "optimistic"
            });
            const accessKey = {
              ...rawAccessKey,
              nonce: BigInt(rawAccessKey.nonce || 0)
            };
            if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {
              return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };
            }
            this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;
            return { publicKey, accessKey };
          } catch (e) {
            if (e.type == "AccessKeyDoesNotExist") {
              return null;
            }
            throw e;
          }
        }
        /**
         * Create a new account and deploy a contract to it
         *
         * @param contractId NEAR account where the contract is deployed
         * @param publicKey The public key to add to the created contract account
         * @param data The compiled contract code
         * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking
         */
        async createAndDeployContract(contractId, publicKey, data, amount) {
          const accessKey = fullAccessKey4();
          await this.signAndSendTransaction({
            receiverId: contractId,
            actions: [createAccount4(), transfer4(amount), addKey5(crypto_1.PublicKey.from(publicKey), accessKey), deployContract6(data)]
          });
          const contractAccount = new _Account(this.connection, contractId);
          return contractAccount;
        }
        /**
         * @param receiverId NEAR account receiving Ⓝ
         * @param amount Amount to send in yoctoⓃ
         */
        async sendMoney(receiverId, amount) {
          return this.signAndSendTransaction({
            receiverId,
            actions: [transfer4(amount)]
          });
        }
        /**
         * @param newAccountId NEAR account name to be created
         * @param publicKey A public key created from the masterAccount
         */
        async createAccount(newAccountId, publicKey, amount) {
          const accessKey = fullAccessKey4();
          return this.signAndSendTransaction({
            receiverId: newAccountId,
            actions: [createAccount4(), transfer4(amount), addKey5(crypto_1.PublicKey.from(publicKey), accessKey)]
          });
        }
        /**
         * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted
         */
        async deleteAccount(beneficiaryId) {
          utils_1.Logger.log("Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting.");
          return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [deleteAccount4(beneficiaryId)]
          });
        }
        /**
         * @param data The compiled contract code
         */
        async deployContract(data) {
          return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [deployContract6(data)]
          });
        }
        /** @hidden */
        encodeJSContractArgs(contractId, method, args) {
          return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);
        }
        /**
          * Execute a function call.
          * @param options The options for the function call.
          * @param options.contractId The NEAR account ID of the smart contract.
          * @param options.methodName The name of the method to be called on the smart contract.
          * @param options.args The arguments to be passed to the method.
          * @param options.gas The maximum amount of gas to be used for the function call.
          * @param options.attachedDeposit The amount of NEAR tokens to be attached to the function call.
          * @param options.walletMeta Metadata for wallet integration.
          * @param options.walletCallbackUrl The callback URL for wallet integration.
          * @param options.stringify A function to convert input arguments into bytes array
          * @param options.jsContract Whether the contract is from JS SDK, automatically encodes args from JS SDK to binary.
          * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the function call.
          */
        async functionCall({ contractId, methodName, args = {}, gas = utils_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify, jsContract }) {
          this.validateArgs(args);
          let functionCallArgs;
          if (jsContract) {
            const encodedArgs = this.encodeJSContractArgs(contractId, methodName, JSON.stringify(args));
            functionCallArgs = ["call_js_contract", encodedArgs, gas, attachedDeposit, null, true];
          } else {
            const stringifyArg = stringify === void 0 ? transactions_1.stringifyJsonOrBytes : stringify;
            functionCallArgs = [methodName, args, gas, attachedDeposit, stringifyArg, false];
          }
          return this.signAndSendTransaction({
            receiverId: jsContract ? this.connection.jsvmAccountId : contractId,
            // eslint-disable-next-line prefer-spread
            actions: [functionCall6.apply(void 0, functionCallArgs)],
            walletMeta,
            walletCallbackUrl
          });
        }
        /**
         * @see [https://docs.near.org/concepts/basics/accounts/access-keys](https://docs.near.org/concepts/basics/accounts/access-keys)
         * @todo expand this API to support more options.
         * @param publicKey A public key to be associated with the contract
         * @param contractId NEAR account where the contract is deployed
         * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.
         * @param amount Payment in yoctoⓃ that is sent to the contract during this function call
         */
        async addKey(publicKey, contractId, methodNames, amount) {
          if (!methodNames) {
            methodNames = [];
          }
          if (!Array.isArray(methodNames)) {
            methodNames = [methodNames];
          }
          let accessKey;
          if (!contractId) {
            accessKey = fullAccessKey4();
          } else {
            accessKey = functionCallAccessKey4(contractId, methodNames, amount);
          }
          return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [addKey5(crypto_1.PublicKey.from(publicKey), accessKey)]
          });
        }
        /**
         * @param publicKey The public key to be deleted
         * @returns {Promise<FinalExecutionOutcome>}
         */
        async deleteKey(publicKey) {
          return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [deleteKey5(crypto_1.PublicKey.from(publicKey))]
          });
        }
        /**
         * @see [https://near-nodes.io/validator/staking-and-delegation](https://near-nodes.io/validator/staking-and-delegation)
         *
         * @param publicKey The public key for the account that's staking
         * @param amount The account to stake in yoctoⓃ
         */
        async stake(publicKey, amount) {
          return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [stake4(amount, crypto_1.PublicKey.from(publicKey))]
          });
        }
        /**
         * Compose and sign a SignedDelegate action to be executed in a transaction on behalf of this Account instance
         *
         * @param options Options for the transaction.
         * @param options.actions Actions to be included in the meta transaction
         * @param options.blockHeightTtl Number of blocks past the current block height for which the SignedDelegate action may be included in a meta transaction
         * @param options.receiverId Receiver account of the meta transaction
         */
        async signedDelegate({ actions, blockHeightTtl, receiverId }) {
          const { provider, signer } = this.connection;
          const { header } = await provider.block({ finality: "final" });
          const { accessKey, publicKey } = await this.findAccessKey(null, null);
          const delegateAction = (0, transactions_1.buildDelegateAction)({
            actions,
            maxBlockHeight: BigInt(header.height) + BigInt(blockHeightTtl),
            nonce: BigInt(accessKey.nonce) + 1n,
            publicKey,
            receiverId,
            senderId: this.accountId
          });
          const { signedDelegateAction } = await (0, transactions_1.signDelegateAction)({
            delegateAction,
            signer: {
              sign: async (message) => {
                const { signature } = await signer.signMessage(message, delegateAction.senderId, this.connection.networkId);
                return signature;
              }
            }
          });
          return signedDelegateAction;
        }
        /** @hidden */
        validateArgs(args) {
          const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
          if (isUint8Array) {
            return;
          }
          if (Array.isArray(args) || typeof args !== "object") {
            throw new types_1.PositionalArgsError();
          }
        }
        /**
         * Invoke a contract view function using the RPC API.
         * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)
         *
         * @param options Function call options.
         * @param options.contractId NEAR account where the contract is deployed
         * @param options.methodName The view-only method (no state mutations) name on the contract as it is written in the contract code
         * @param options.args Any arguments to the view contract method, wrapped in JSON
         * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.
         * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.
         * @param options.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.
         * @param options.blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
         * @returns {Promise<any>}
         */
        async viewFunction(options) {
          return await (0, utils_2.viewFunction)(this.connection, options);
        }
        /**
         * Returns the state (key value pairs) of this account's contract based on the key prefix.
         * Pass an empty string for prefix if you would like to return the entire state.
         * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)
         *
         * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.
         * @param blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
         */
        async viewState(prefix, blockQuery = { finality: "optimistic" }) {
          return await (0, utils_2.viewState)(this.connection, this.accountId, prefix, blockQuery);
        }
        /**
         * Get all access keys for the account
         * @see [https://docs.near.org/api/rpc/access-keys#view-access-key-list](https://docs.near.org/api/rpc/access-keys#view-access-key-list)
         */
        async getAccessKeys() {
          const response = await this.connection.provider.query({
            request_type: "view_access_key_list",
            account_id: this.accountId,
            finality: "optimistic"
          });
          return response?.keys?.map((key) => ({ ...key, access_key: { ...key.access_key, nonce: BigInt(key.access_key.nonce) } }));
        }
        /**
         * Returns a list of authorized apps
         * @todo update the response value to return all the different keys, not just app keys.
         */
        async getAccountDetails() {
          const accessKeys = await this.getAccessKeys();
          const authorizedApps = accessKeys.filter((item) => item.access_key.permission !== "FullAccess").map((item) => {
            const perm = item.access_key.permission;
            return {
              contractId: perm.FunctionCall.receiver_id,
              amount: perm.FunctionCall.allowance,
              publicKey: item.public_key
            };
          });
          return { authorizedApps };
        }
        /**
         * Returns calculated account balance
         */
        async getAccountBalance() {
          const protocolConfig = await this.connection.provider.experimental_protocolConfig({ finality: "final" });
          const state = await this.state();
          const costPerByte = BigInt(protocolConfig.runtime_config.storage_amount_per_byte);
          const stateStaked = BigInt(state.storage_usage) * costPerByte;
          const staked = BigInt(state.locked);
          const totalBalance = BigInt(state.amount) + staked;
          const availableBalance = totalBalance - (staked > stateStaked ? staked : stateStaked);
          return {
            total: totalBalance.toString(),
            stateStaked: stateStaked.toString(),
            staked: staked.toString(),
            available: availableBalance.toString()
          };
        }
        /**
         * Returns the NEAR tokens balance and validators of a given account that is delegated to the staking pools that are part of the validators set in the current epoch.
         *
         * NOTE: If the tokens are delegated to a staking pool that is currently on pause or does not have enough tokens to participate in validation, they won't be accounted for.
         * @returns {Promise<ActiveDelegatedStakeBalance>}
         */
        async getActiveDelegatedStakeBalance() {
          const block = await this.connection.provider.block({ finality: "final" });
          const blockHash = block.header.hash;
          const epochId = block.header.epoch_id;
          const { current_validators, next_validators, current_proposals } = await this.connection.provider.validators(epochId);
          const pools = /* @__PURE__ */ new Set();
          [...current_validators, ...next_validators, ...current_proposals].forEach((validator) => pools.add(validator.account_id));
          const uniquePools = [...pools];
          const promises = uniquePools.map((validator) => this.viewFunction({
            contractId: validator,
            methodName: "get_account_total_balance",
            args: { account_id: this.accountId },
            blockQuery: { blockId: blockHash }
          }));
          const results = await Promise.allSettled(promises);
          const hasTimeoutError = results.some((result) => {
            if (result.status === "rejected" && result.reason.type === "TimeoutError") {
              return true;
            }
            return false;
          });
          if (hasTimeoutError) {
            throw new Error("Failed to get delegated stake balance");
          }
          const summary = results.reduce((result, state, index) => {
            const validatorId = uniquePools[index];
            if (state.status === "fulfilled") {
              const currentBN = BigInt(state.value);
              if (currentBN !== 0n) {
                return {
                  ...result,
                  stakedValidators: [...result.stakedValidators, { validatorId, amount: currentBN.toString() }],
                  total: result.total + currentBN
                };
              }
            }
            if (state.status === "rejected") {
              return {
                ...result,
                failedValidators: [...result.failedValidators, { validatorId, error: state.reason }]
              };
            }
            return result;
          }, { stakedValidators: [], failedValidators: [], total: 0n });
          return {
            ...summary,
            total: summary.total.toString()
          };
        }
      };
      exports.Account = Account2;
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/constants.cjs
  var require_constants3 = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/constants.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;
      var utils_1 = require_commonjs2();
      exports.MULTISIG_STORAGE_KEY = "__multisigRequest";
      exports.MULTISIG_ALLOWANCE = BigInt((0, utils_1.parseNearAmount)("1"));
      exports.MULTISIG_GAS = 100000000000000n;
      exports.MULTISIG_DEPOSIT = 0n;
      exports.MULTISIG_CHANGE_METHODS = ["add_request", "add_request_and_confirm", "delete_request", "confirm"];
      exports.MULTISIG_CONFIRM_METHODS = ["confirm"];
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/types.cjs
  var require_types2 = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/types.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = void 0;
      var MultisigDeleteRequestRejectionError2;
      (function(MultisigDeleteRequestRejectionError3) {
        MultisigDeleteRequestRejectionError3["CANNOT_DESERIALIZE_STATE"] = "Cannot deserialize the contract state";
        MultisigDeleteRequestRejectionError3["MULTISIG_NOT_INITIALIZED"] = "Smart contract panicked: Multisig contract should be initialized before usage";
        MultisigDeleteRequestRejectionError3["NO_SUCH_REQUEST"] = "Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'";
        MultisigDeleteRequestRejectionError3["REQUEST_COOLDOWN_ERROR"] = "Request cannot be deleted immediately after creation.";
        MultisigDeleteRequestRejectionError3["METHOD_NOT_FOUND"] = "Contract method is not found";
      })(MultisigDeleteRequestRejectionError2 || (exports.MultisigDeleteRequestRejectionError = MultisigDeleteRequestRejectionError2 = {}));
      var MultisigStateStatus2;
      (function(MultisigStateStatus3) {
        MultisigStateStatus3[MultisigStateStatus3["INVALID_STATE"] = 0] = "INVALID_STATE";
        MultisigStateStatus3[MultisigStateStatus3["STATE_NOT_INITIALIZED"] = 1] = "STATE_NOT_INITIALIZED";
        MultisigStateStatus3[MultisigStateStatus3["VALID_STATE"] = 2] = "VALID_STATE";
        MultisigStateStatus3[MultisigStateStatus3["UNKNOWN_STATE"] = 3] = "UNKNOWN_STATE";
      })(MultisigStateStatus2 || (exports.MultisigStateStatus = MultisigStateStatus2 = {}));
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/account_multisig.cjs
  var require_account_multisig = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/account_multisig.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AccountMultisig = void 0;
      var transactions_1 = require_commonjs4();
      var utils_1 = require_commonjs2();
      var account_1 = require_account();
      var constants_1 = require_constants3();
      var types_1 = require_types2();
      var { deployContract: deployContract6, functionCall: functionCall6 } = transactions_1.actionCreators;
      var MultisigCodeStatus2;
      (function(MultisigCodeStatus3) {
        MultisigCodeStatus3[MultisigCodeStatus3["INVALID_CODE"] = 0] = "INVALID_CODE";
        MultisigCodeStatus3[MultisigCodeStatus3["VALID_CODE"] = 1] = "VALID_CODE";
        MultisigCodeStatus3[MultisigCodeStatus3["UNKNOWN_CODE"] = 2] = "UNKNOWN_CODE";
      })(MultisigCodeStatus2 || (MultisigCodeStatus2 = {}));
      var storageFallback2 = {
        [constants_1.MULTISIG_STORAGE_KEY]: null
      };
      var AccountMultisig2 = class extends account_1.Account {
        storage;
        onAddRequestResult;
        /**
         * Constructs an instance of the `AccountMultisig` class.
         * @param connection The NEAR connection object.
         * @param accountId The NEAR account ID.
         * @param options Additional options for the multisig account.
         * @param options.storage Storage to store data related to multisig operations.
         * @param options.onAddRequestResult Callback function to handle the result of adding a request.
         */
        constructor(connection, accountId, options) {
          super(connection, accountId);
          this.storage = options.storage;
          this.onAddRequestResult = options.onAddRequestResult;
        }
        /**
         * Sign and send a transaction with the multisig account as the sender.
         * @param receiverId - The NEAR account ID of the transaction receiver.
         * @param actions - The list of actions to be included in the transaction.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
         */
        async signAndSendTransactionWithAccount(receiverId, actions) {
          return super.signAndSendTransaction({ receiverId, actions });
        }
        /**
         * Sign and send a multisig transaction to add a request and confirm it.
         * @param options Options for the multisig transaction.
         * @param options.receiverId The NEAR account ID of the transaction receiver.
         * @param options.actions The list of actions to be included in the transaction.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
         */
        async signAndSendTransaction({ receiverId, actions }) {
          const { accountId } = this;
          const args = Buffer.from(JSON.stringify({
            request: {
              receiver_id: receiverId,
              actions: convertActions(actions, accountId, receiverId)
            }
          }));
          let result;
          try {
            result = await super.signAndSendTransaction({
              receiverId: accountId,
              actions: [
                functionCall6("add_request_and_confirm", args, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)
              ]
            });
          } catch (e) {
            if (e.toString().includes("Account has too many active requests. Confirm or delete some")) {
              await this.deleteUnconfirmedRequests();
              return await this.signAndSendTransaction({ receiverId, actions });
            }
            throw e;
          }
          if (!result.status) {
            throw new Error("Request failed");
          }
          const status = { ...result.status };
          if (!status.SuccessValue || typeof status.SuccessValue !== "string") {
            throw new Error("Request failed");
          }
          this.setRequest({
            accountId,
            actions,
            requestId: parseInt(Buffer.from(status.SuccessValue, "base64").toString("ascii"), 10)
          });
          if (this.onAddRequestResult) {
            await this.onAddRequestResult(result);
          }
          this.deleteUnconfirmedRequests();
          return result;
        }
        /**
         * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state
         * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.
         * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.
         * @param contractBytes The bytecode of the multisig contract.
         * @returns {Promise<{ codeStatus: MultisigCodeStatus; stateStatus: MultisigStateStatus }>} A promise that resolves to the status of the code and state.
         */
        async checkMultisigCodeAndStateStatus(contractBytes) {
          const u32_max = 4294967295;
          const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus2.UNKNOWN_CODE : MultisigCodeStatus2.VALID_CODE;
          try {
            if (contractBytes) {
              await super.signAndSendTransaction({
                receiverId: this.accountId,
                actions: [
                  deployContract6(contractBytes),
                  functionCall6("delete_request", { request_id: u32_max }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)
                ]
              });
            } else {
              await this.deleteRequest(u32_max);
            }
            return { codeStatus: MultisigCodeStatus2.VALID_CODE, stateStatus: types_1.MultisigStateStatus.VALID_STATE };
          } catch (e) {
            if (new RegExp(types_1.MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {
              return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.INVALID_STATE };
            } else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {
              return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.STATE_NOT_INITIALIZED };
            } else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {
              return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.VALID_STATE };
            } else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {
              return { codeStatus: MultisigCodeStatus2.INVALID_CODE, stateStatus: types_1.MultisigStateStatus.UNKNOWN_STATE };
            }
            throw e;
          }
        }
        /**
         * Delete a multisig request by its ID.
         * @param request_id The ID of the multisig request to be deleted.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deletion.
         */
        deleteRequest(request_id) {
          return super.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [functionCall6("delete_request", { request_id }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]
          });
        }
        /**
         * Delete all multisig requests associated with the account.
         * @returns {Promise<void>} A promise that resolves when all requests are deleted.
         */
        async deleteAllRequests() {
          const request_ids = await this.getRequestIds();
          if (request_ids.length) {
            await Promise.all(request_ids.map((id) => this.deleteRequest(id)));
          }
        }
        /**
         * Delete unconfirmed multisig requests associated with the account.
         * @returns {Promise<void>} A promise that resolves when unconfirmed requests are deleted.
         */
        async deleteUnconfirmedRequests() {
          const request_ids = await this.getRequestIds();
          const { requestId } = this.getRequest();
          for (const requestIdToDelete of request_ids) {
            if (requestIdToDelete == requestId) {
              continue;
            }
            try {
              await super.signAndSendTransaction({
                receiverId: this.accountId,
                actions: [functionCall6("delete_request", { request_id: requestIdToDelete }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]
              });
            } catch (e) {
              utils_1.Logger.warn("Attempt to delete an earlier request before 15 minutes failed. Will try again.");
            }
          }
        }
        // helpers
        async getRequestIds() {
          return this.viewFunction({
            contractId: this.accountId,
            methodName: "list_request_ids"
          });
        }
        getRequest() {
          if (this.storage) {
            return JSON.parse(this.storage.getItem(constants_1.MULTISIG_STORAGE_KEY) || "{}");
          }
          return storageFallback2[constants_1.MULTISIG_STORAGE_KEY];
        }
        setRequest(data) {
          if (this.storage) {
            return this.storage.setItem(constants_1.MULTISIG_STORAGE_KEY, JSON.stringify(data));
          }
          storageFallback2[constants_1.MULTISIG_STORAGE_KEY] = data;
        }
      };
      exports.AccountMultisig = AccountMultisig2;
      var convertPKForContract = (pk) => pk.toString().replace("ed25519:", "");
      var convertActions = (actions, accountId, receiverId) => actions.map((a) => {
        const type = a.enum;
        const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];
        const action = {
          type: type[0].toUpperCase() + type.substr(1),
          gas: gas && gas.toString() || void 0,
          public_key: publicKey && convertPKForContract(publicKey) || void 0,
          method_name: methodName,
          args: args && Buffer.from(args).toString("base64") || void 0,
          code: code && Buffer.from(code).toString("base64") || void 0,
          amount: deposit && deposit.toString() || void 0,
          deposit: deposit && deposit.toString() || "0",
          permission: void 0
        };
        if (accessKey) {
          if (receiverId === accountId && accessKey.permission.enum !== "fullAccess") {
            action.permission = {
              receiver_id: accountId,
              allowance: constants_1.MULTISIG_ALLOWANCE.toString(),
              method_names: constants_1.MULTISIG_CHANGE_METHODS
            };
          }
          if (accessKey.permission.enum === "functionCall") {
            const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;
            action.permission = {
              receiver_id,
              allowance: allowance && allowance.toString() || void 0,
              method_names
            };
          }
        }
        return action;
      });
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/account_2fa.cjs
  var require_account_2fa = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/account_2fa.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Account2FA = void 0;
      var crypto_1 = require_commonjs3();
      var types_1 = require_commonjs();
      var transactions_1 = require_commonjs4();
      var utils_1 = require_commonjs2();
      var isomorphic_unfetch_1 = __importDefault(require_browser3());
      var account_multisig_1 = require_account_multisig();
      var constants_1 = require_constants3();
      var types_2 = require_types2();
      var { addKey: addKey5, deleteKey: deleteKey5, deployContract: deployContract6, fullAccessKey: fullAccessKey4, functionCall: functionCall6, functionCallAccessKey: functionCallAccessKey4 } = transactions_1.actionCreators;
      var Account2FA2 = class extends account_multisig_1.AccountMultisig {
        /********************************
        Account2FA has options object where you can provide callbacks for:
        - sendCode: how to send the 2FA code in case you don't use NEAR Contract Helper
        - getCode: how to get code from user (use this to provide custom UI/UX for prompt of 2FA code)
        - onResult: the tx result after it's been confirmed by NEAR Contract Helper
        ********************************/
        sendCode;
        getCode;
        verifyCode;
        onConfirmResult;
        helperUrl = "https://helper.testnet.near.org";
        constructor(connection, accountId, options) {
          super(connection, accountId, options);
          this.helperUrl = options.helperUrl || this.helperUrl;
          this.storage = options.storage;
          this.sendCode = options.sendCode || this.sendCodeDefault;
          this.getCode = options.getCode || this.getCodeDefault;
          this.verifyCode = options.verifyCode || this.verifyCodeDefault;
          this.onConfirmResult = options.onConfirmResult;
        }
        /**
         * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
         * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}
         *
         * @param options Options for the transaction.
         * @param options.receiverId The NEAR account ID of the transaction receiver.
         * @param options.actions The list of actions to be included in the transaction.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
         */
        async signAndSendTransaction({ receiverId, actions }) {
          await super.signAndSendTransaction({ receiverId, actions });
          await this.sendCode();
          const result = await this.promptAndVerify();
          if (this.onConfirmResult) {
            await this.onConfirmResult(result);
          }
          return result;
        }
        // default helpers for CH deployments of multisig
        /**
         * Deploy a multisig contract with 2FA and handle the deployment process.
         * @param contractBytes - The bytecode of the multisig contract.
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deployment.
         */
        async deployMultisig(contractBytes) {
          const { accountId } = this;
          const seedOrLedgerKey = (await this.getRecoveryMethods()).data.filter(({ kind, publicKey }) => (kind === "phrase" || kind === "ledger") && publicKey !== null).map((rm) => rm.publicKey);
          const fak2lak = (await this.getAccessKeys()).filter(({ public_key, access_key: { permission } }) => permission === "FullAccess" && !seedOrLedgerKey.includes(public_key)).map((ak) => ak.public_key).map(toPK);
          const confirmOnlyKey = toPK((await this.postSignedJson("/2fa/getAccessKey", { accountId })).publicKey);
          const newArgs = Buffer.from(JSON.stringify({ "num_confirmations": 2 }));
          const actions = [
            ...fak2lak.map((pk) => deleteKey5(pk)),
            ...fak2lak.map((pk) => addKey5(pk, functionCallAccessKey4(accountId, constants_1.MULTISIG_CHANGE_METHODS, null))),
            addKey5(confirmOnlyKey, functionCallAccessKey4(accountId, constants_1.MULTISIG_CONFIRM_METHODS, null)),
            deployContract6(contractBytes)
          ];
          const newFunctionCallActionBatch = actions.concat(functionCall6("new", newArgs, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT));
          utils_1.Logger.log("deploying multisig contract for", accountId);
          const { stateStatus: multisigStateStatus } = await this.checkMultisigCodeAndStateStatus(contractBytes);
          switch (multisigStateStatus) {
            case types_2.MultisigStateStatus.STATE_NOT_INITIALIZED:
              return await super.signAndSendTransactionWithAccount(accountId, newFunctionCallActionBatch);
            case types_2.MultisigStateStatus.VALID_STATE:
              return await super.signAndSendTransactionWithAccount(accountId, actions);
            case types_2.MultisigStateStatus.INVALID_STATE:
              throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState");
            default:
              throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
          }
        }
        /**
         * Disable 2FA with the option to clean up contract state.
         * @param options Options for disabling 2FA.
         * @param options.contractBytes The bytecode of the contract to deploy.
         * @param options.cleanupContractBytes The bytecode of the cleanup contract (optional).
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.
         */
        async disableWithFAK({ contractBytes, cleanupContractBytes }) {
          let cleanupActions = [];
          if (cleanupContractBytes) {
            await this.deleteAllRequests().catch((e) => e);
            cleanupActions = await this.get2faDisableCleanupActions(cleanupContractBytes);
          }
          const keyConversionActions = await this.get2faDisableKeyConversionActions();
          const actions = [
            ...cleanupActions,
            ...keyConversionActions,
            deployContract6(contractBytes)
          ];
          const accessKeyInfo = await this.findAccessKey(this.accountId, actions);
          if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== "FullAccess") {
            throw new types_1.TypedError("No full access key found in keystore. Unable to bypass multisig", "NoFAKFound");
          }
          return this.signAndSendTransactionWithAccount(this.accountId, actions);
        }
        /**
         * Retrieves cleanup actions for disabling 2FA.
         * @param cleanupContractBytes - The bytecode of the cleanup contract.
         * @returns {Promise<Action[]>} - A promise that resolves to an array of cleanup actions.
         */
        async get2faDisableCleanupActions(cleanupContractBytes) {
          const currentAccountState = await this.viewState("").catch((error) => {
            const cause = error.cause && error.cause.name;
            if (cause == "NO_CONTRACT_CODE") {
              return [];
            }
            throw cause == "TOO_LARGE_CONTRACT_STATE" ? new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState") : error;
          });
          const currentAccountStateKeys = currentAccountState.map(({ key }) => key.toString("base64"));
          return currentAccountState.length ? [
            deployContract6(cleanupContractBytes),
            functionCall6("clean", { keys: currentAccountStateKeys }, constants_1.MULTISIG_GAS, 0n)
          ] : [];
        }
        /**
         * Retrieves key conversion actions for disabling 2FA.
         * @returns {Promise<Action[]>} - A promise that resolves to an array of key conversion actions.
         */
        async get2faDisableKeyConversionActions() {
          const { accountId } = this;
          const accessKeys = await this.getAccessKeys();
          const lak2fak = accessKeys.filter(({ access_key }) => access_key.permission !== "FullAccess").filter(({ access_key }) => {
            const perm = access_key.permission.FunctionCall;
            return perm.receiver_id === accountId && perm.method_names.length === 4 && perm.method_names.includes("add_request_and_confirm");
          });
          const confirmOnlyKey = crypto_1.PublicKey.from((await this.postSignedJson("/2fa/getAccessKey", { accountId })).publicKey);
          return [
            deleteKey5(confirmOnlyKey),
            ...lak2fak.map(({ public_key }) => deleteKey5(crypto_1.PublicKey.from(public_key))),
            ...lak2fak.map(({ public_key }) => addKey5(crypto_1.PublicKey.from(public_key), fullAccessKey4()))
          ];
        }
        /**
         * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)
         * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}
         * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-manipulation/res/state_cleanup.wasm?raw=true}
         * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.
         */
        async disable(contractBytes, cleanupContractBytes) {
          const { stateStatus } = await this.checkMultisigCodeAndStateStatus();
          if (stateStatus !== types_2.MultisigStateStatus.VALID_STATE && stateStatus !== types_2.MultisigStateStatus.STATE_NOT_INITIALIZED) {
            throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
          }
          let deleteAllRequestsError;
          await this.deleteAllRequests().catch((e) => deleteAllRequestsError = e);
          const cleanupActions = await this.get2faDisableCleanupActions(cleanupContractBytes).catch((e) => {
            if (e.type === "ContractHasExistingState") {
              throw deleteAllRequestsError || e;
            }
            throw e;
          });
          const actions = [
            ...cleanupActions,
            ...await this.get2faDisableKeyConversionActions(),
            deployContract6(contractBytes)
          ];
          utils_1.Logger.log("disabling 2fa for", this.accountId);
          return await this.signAndSendTransaction({
            receiverId: this.accountId,
            actions
          });
        }
        /**
         * Default implementation for sending the 2FA code.
         * @returns {Promise<string>} - A promise that resolves to the request ID.
         */
        async sendCodeDefault() {
          const { accountId } = this;
          const { requestId } = this.getRequest();
          const method = await this.get2faMethod();
          await this.postSignedJson("/2fa/send", {
            accountId,
            method,
            requestId
          });
          return requestId;
        }
        async getCodeDefault() {
          throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is "email" or "phone".');
        }
        /**
         * Prompts the user to enter and verify the 2FA code.
         * @returns {Promise<any>} - A promise that resolves to the verification result.
         */
        async promptAndVerify() {
          const method = await this.get2faMethod();
          const securityCode = await this.getCode(method);
          try {
            const result = await this.verifyCode(securityCode);
            return result;
          } catch (e) {
            utils_1.Logger.warn("Error validating security code:", e);
            if (e.toString().includes("invalid 2fa code provided") || e.toString().includes("2fa code not valid")) {
              return await this.promptAndVerify();
            }
            throw e;
          }
        }
        /**
         * Verify the 2FA code using the default method.
         * @param securityCode - The security code to verify.
         * @returns {Promise<any>} A promise that resolves to the verification result.
         */
        async verifyCodeDefault(securityCode) {
          const { accountId } = this;
          const request = this.getRequest();
          if (!request) {
            throw new Error("no request pending");
          }
          const { requestId } = request;
          return await this.postSignedJson("/2fa/verify", {
            accountId,
            securityCode,
            requestId
          });
        }
        /**
         * Retrieves recovery methods for the account.
         * @returns {Promise<{ accountId: string, data: any }>} - A promise that resolves to recovery methods data.
         */
        async getRecoveryMethods() {
          const { accountId } = this;
          return {
            accountId,
            data: await this.postSignedJson("/account/recoveryMethods", { accountId })
          };
        }
        /**
         * Gets the 2FA method (kind and detail).
         * @returns {Promise<{ kind: string, detail: string }>} A promise that resolves to the 2FA method.
         */
        async get2faMethod() {
          let { data } = await this.getRecoveryMethods();
          if (data && data.length) {
            data = data.find((m) => m.kind.indexOf("2fa-") === 0);
          }
          if (!data)
            return null;
          const { kind, detail } = data;
          return { kind, detail };
        }
        /**
        * Generates a signature for the latest finalized block.
        * @returns {Promise<{ blockNumber: string, blockNumberSignature: string }>} - A promise that resolves to the signature information.
        */
        async signatureFor() {
          const { accountId } = this;
          const block = await this.connection.provider.block({ finality: "final" });
          const blockNumber = block.header.height.toString();
          const signed = await this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);
          const blockNumberSignature = Buffer.from(signed.signature).toString("base64");
          return { blockNumber, blockNumberSignature };
        }
        /**
        * Sends a signed JSON request to a specified path.
        * @param path - The path for the request.
        * @param body - The request body.
        * @returns {Promise<any>} - A promise that resolves to the response from the helper.
        */
        async postSignedJson(path, body) {
          return await (0, isomorphic_unfetch_1.default)(this.helperUrl + path, {
            body: JSON.stringify({
              ...body,
              ...await this.signatureFor()
            }),
            method: "POST"
          });
        }
      };
      exports.Account2FA = Account2FA2;
      var toPK = (pk) => crypto_1.PublicKey.from(pk);
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/account_creator.cjs
  var require_account_creator = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/account_creator.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = void 0;
      var isomorphic_unfetch_1 = __importDefault(require_browser3());
      var AccountCreator2 = class {
      };
      exports.AccountCreator = AccountCreator2;
      var LocalAccountCreator2 = class extends AccountCreator2 {
        masterAccount;
        initialBalance;
        constructor(masterAccount, initialBalance) {
          super();
          this.masterAccount = masterAccount;
          this.initialBalance = initialBalance;
        }
        /**
         * Creates an account using a masterAccount, meaning the new account is created from an existing account
         * @param newAccountId The name of the NEAR account to be created
         * @param publicKey The public key from the masterAccount used to create this account
         * @returns {Promise<void>}
         */
        async createAccount(newAccountId, publicKey) {
          await this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);
        }
      };
      exports.LocalAccountCreator = LocalAccountCreator2;
      var UrlAccountCreator2 = class extends AccountCreator2 {
        connection;
        helperUrl;
        constructor(connection, helperUrl) {
          super();
          this.connection = connection;
          this.helperUrl = helperUrl;
        }
        /**
         * Creates an account using a helperUrl
         * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository
         * @param newAccountId The name of the NEAR account to be created
         * @param publicKey The public key from the masterAccount used to create this account
         * @returns {Promise<void>}
         */
        async createAccount(newAccountId, publicKey) {
          await (0, isomorphic_unfetch_1.default)(`${this.helperUrl}/account`, {
            body: JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }),
            method: "POST"
          });
        }
      };
      exports.UrlAccountCreator = UrlAccountCreator2;
    }
  });

  // ../../node_modules/@near-js/keystores/lib/commonjs/keystore.cjs
  var require_keystore = __commonJS({
    "../../node_modules/@near-js/keystores/lib/commonjs/keystore.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyStore = void 0;
      var KeyStore2 = class {
      };
      exports.KeyStore = KeyStore2;
    }
  });

  // ../../node_modules/@near-js/keystores/lib/commonjs/in_memory_key_store.cjs
  var require_in_memory_key_store = __commonJS({
    "../../node_modules/@near-js/keystores/lib/commonjs/in_memory_key_store.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InMemoryKeyStore = void 0;
      var crypto_1 = require_commonjs3();
      var keystore_1 = require_keystore();
      var InMemoryKeyStore2 = class extends keystore_1.KeyStore {
        /** @hidden */
        keys;
        constructor() {
          super();
          this.keys = {};
        }
        /**
         * Stores a {@link KeyPair} in in-memory storage item
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         * @param accountId The NEAR account tied to the key pair
         * @param keyPair The key pair to store in local storage
         */
        async setKey(networkId, accountId, keyPair) {
          this.keys[`${accountId}:${networkId}`] = keyPair.toString();
        }
        /**
         * Gets a {@link KeyPair} from in-memory storage
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         * @param accountId The NEAR account tied to the key pair
         * @returns {Promise<KeyPair>}
         */
        async getKey(networkId, accountId) {
          const value = this.keys[`${accountId}:${networkId}`];
          if (!value) {
            return null;
          }
          return crypto_1.KeyPair.fromString(value);
        }
        /**
         * Removes a {@link KeyPair} from in-memory storage
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         * @param accountId The NEAR account tied to the key pair
         */
        async removeKey(networkId, accountId) {
          delete this.keys[`${accountId}:${networkId}`];
        }
        /**
         * Removes all {@link KeyPair} from in-memory storage
         */
        async clear() {
          this.keys = {};
        }
        /**
         * Get the network(s) from in-memory storage
         * @returns {Promise<string[]>}
         */
        async getNetworks() {
          const result = /* @__PURE__ */ new Set();
          Object.keys(this.keys).forEach((key) => {
            const parts = key.split(":");
            result.add(parts[1]);
          });
          return Array.from(result.values());
        }
        /**
         * Gets the account(s) from in-memory storage
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         */
        async getAccounts(networkId) {
          const result = new Array();
          Object.keys(this.keys).forEach((key) => {
            const parts = key.split(":");
            if (parts[parts.length - 1] === networkId) {
              result.push(parts.slice(0, parts.length - 1).join(":"));
            }
          });
          return result;
        }
        /** @hidden */
        toString() {
          return "InMemoryKeyStore";
        }
      };
      exports.InMemoryKeyStore = InMemoryKeyStore2;
    }
  });

  // ../../node_modules/@near-js/keystores/lib/commonjs/merge_key_store.cjs
  var require_merge_key_store = __commonJS({
    "../../node_modules/@near-js/keystores/lib/commonjs/merge_key_store.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MergeKeyStore = void 0;
      var keystore_1 = require_keystore();
      var MergeKeyStore2 = class extends keystore_1.KeyStore {
        options;
        keyStores;
        /**
         * @param keyStores read calls are attempted from start to end of array
         * @param options KeyStore options
         * @param options.writeKeyStoreIndex the keystore index that will receive all write calls
         */
        constructor(keyStores, options = { writeKeyStoreIndex: 0 }) {
          super();
          this.options = options;
          this.keyStores = keyStores;
        }
        /**
         * Store a {@link KeyPair} to the first index of a key store array
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         * @param accountId The NEAR account tied to the key pair
         * @param keyPair The key pair to store in local storage
         */
        async setKey(networkId, accountId, keyPair) {
          await this.keyStores[this.options.writeKeyStoreIndex].setKey(networkId, accountId, keyPair);
        }
        /**
         * Gets a {@link KeyPair} from the array of key stores
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         * @param accountId The NEAR account tied to the key pair
         * @returns {Promise<KeyPair>}
         */
        async getKey(networkId, accountId) {
          for (const keyStore of this.keyStores) {
            const keyPair = await keyStore.getKey(networkId, accountId);
            if (keyPair) {
              return keyPair;
            }
          }
          return null;
        }
        /**
         * Removes a {@link KeyPair} from the array of key stores
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         * @param accountId The NEAR account tied to the key pair
         */
        async removeKey(networkId, accountId) {
          for (const keyStore of this.keyStores) {
            await keyStore.removeKey(networkId, accountId);
          }
        }
        /**
         * Removes all items from each key store
         */
        async clear() {
          for (const keyStore of this.keyStores) {
            await keyStore.clear();
          }
        }
        /**
         * Get the network(s) from the array of key stores
         * @returns {Promise<string[]>}
         */
        async getNetworks() {
          const result = /* @__PURE__ */ new Set();
          for (const keyStore of this.keyStores) {
            for (const network of await keyStore.getNetworks()) {
              result.add(network);
            }
          }
          return Array.from(result);
        }
        /**
         * Gets the account(s) from the array of key stores
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         */
        async getAccounts(networkId) {
          const result = /* @__PURE__ */ new Set();
          for (const keyStore of this.keyStores) {
            for (const account of await keyStore.getAccounts(networkId)) {
              result.add(account);
            }
          }
          return Array.from(result);
        }
        /** @hidden */
        toString() {
          return `MergeKeyStore(${this.keyStores.join(", ")})`;
        }
      };
      exports.MergeKeyStore = MergeKeyStore2;
    }
  });

  // ../../node_modules/@near-js/keystores/lib/commonjs/multi_contract_keystore.cjs
  var require_multi_contract_keystore = __commonJS({
    "../../node_modules/@near-js/keystores/lib/commonjs/multi_contract_keystore.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MultiContractKeyStore = void 0;
      var MultiContractKeyStore2 = class {
      };
      exports.MultiContractKeyStore = MultiContractKeyStore2;
    }
  });

  // ../../node_modules/@near-js/keystores/lib/commonjs/index.cjs
  var require_commonjs6 = __commonJS({
    "../../node_modules/@near-js/keystores/lib/commonjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MultiContractKeyStore = exports.MergeKeyStore = exports.KeyStore = exports.InMemoryKeyStore = void 0;
      var in_memory_key_store_1 = require_in_memory_key_store();
      Object.defineProperty(exports, "InMemoryKeyStore", { enumerable: true, get: function() {
        return in_memory_key_store_1.InMemoryKeyStore;
      } });
      var keystore_1 = require_keystore();
      Object.defineProperty(exports, "KeyStore", { enumerable: true, get: function() {
        return keystore_1.KeyStore;
      } });
      var merge_key_store_1 = require_merge_key_store();
      Object.defineProperty(exports, "MergeKeyStore", { enumerable: true, get: function() {
        return merge_key_store_1.MergeKeyStore;
      } });
      var multi_contract_keystore_1 = require_multi_contract_keystore();
      Object.defineProperty(exports, "MultiContractKeyStore", { enumerable: true, get: function() {
        return multi_contract_keystore_1.MultiContractKeyStore;
      } });
    }
  });

  // ../../node_modules/@near-js/signers/node_modules/@noble/hashes/_assert.js
  var require_assert3 = __commonJS({
    "../../node_modules/@near-js/signers/node_modules/@noble/hashes/_assert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports.bool = bool;
      function isBytes4(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function bytes2(b, ...lengths) {
        if (!isBytes4(b))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports.bytes = bytes2;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports.hash = hash;
      function exists2(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports.exists = exists2;
      function output2(out, instance) {
        bytes2(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      exports.output = output2;
      var assert = { number, bool, bytes: bytes2, hash, exists: exists2, output: output2 };
      exports.default = assert;
    }
  });

  // ../../node_modules/@near-js/signers/node_modules/@noble/hashes/crypto.js
  var require_crypto3 = __commonJS({
    "../../node_modules/@near-js/signers/node_modules/@noble/hashes/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // ../../node_modules/@near-js/signers/node_modules/@noble/hashes/utils.js
  var require_utils10 = __commonJS({
    "../../node_modules/@near-js/signers/node_modules/@noble/hashes/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
      var crypto_1 = require_crypto3();
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports.u32 = u32;
      function isBytes4(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      var createView4 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.createView = createView4;
      var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
      exports.rotr = rotr2;
      exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex3(bytes2) {
        if (!isBytes4(bytes2))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes2.length; i++) {
          hex += hexes3[bytes2[i]];
        }
        return hex;
      }
      exports.bytesToHex = bytesToHex3;
      var asciis2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase162(char) {
        if (char >= asciis2._0 && char <= asciis2._9)
          return char - asciis2._0;
        if (char >= asciis2._A && char <= asciis2._F)
          return char - (asciis2._A - 10);
        if (char >= asciis2._a && char <= asciis2._f)
          return char - (asciis2._a - 10);
        return;
      }
      function hexToBytes3(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase162(hex.charCodeAt(hi));
          const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      exports.hexToBytes = hexToBytes3;
      var nextTick = async () => {
      };
      exports.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      exports.asyncLoop = asyncLoop;
      function utf8ToBytes4(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports.utf8ToBytes = utf8ToBytes4;
      function toBytes4(data) {
        if (typeof data === "string")
          data = utf8ToBytes4(data);
        if (!isBytes4(data))
          throw new Error(`expected Uint8Array, got ${typeof data}`);
        return data;
      }
      exports.toBytes = toBytes4;
      function concatBytes5(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          if (!isBytes4(a))
            throw new Error("Uint8Array expected");
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      exports.concatBytes = concatBytes5;
      var Hash4 = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports.Hash = Hash4;
      var toStr2 = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr2.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports.checkOpts = checkOpts;
      function wrapConstructor4(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports.wrapConstructor = wrapConstructor4;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes3(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports.randomBytes = randomBytes3;
    }
  });

  // ../../node_modules/@near-js/signers/node_modules/@noble/hashes/_sha2.js
  var require_sha23 = __commonJS({
    "../../node_modules/@near-js/signers/node_modules/@noble/hashes/_sha2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA2 = void 0;
      var _assert_js_1 = require_assert3();
      var utils_js_1 = require_utils10();
      function setBigUint644(view, byteOffset, value, isLE2) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE2);
        const _32n3 = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n3 & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE2 ? 4 : 0;
        const l = isLE2 ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE2);
        view.setUint32(byteOffset + l, wl, isLE2);
      }
      var SHA22 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE2) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE2;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE: isLE2 } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint644(view, blockLen - 8, BigInt(this.length * 8), isLE2);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE2);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports.SHA2 = SHA22;
    }
  });

  // ../../node_modules/@near-js/signers/node_modules/@noble/hashes/sha256.js
  var require_sha2562 = __commonJS({
    "../../node_modules/@near-js/signers/node_modules/@noble/hashes/sha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha224 = exports.sha256 = void 0;
      var _sha2_js_1 = require_sha23();
      var utils_js_1 = require_utils10();
      var Chi2 = (a, b, c) => a & b ^ ~a & c;
      var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
      var SHA256_K2 = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
      var SHA2562 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W2[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W2[i - 15];
            const W2 = SHA256_W2[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj2(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W2.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA224 = class extends SHA2562 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA2562());
      exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
    }
  });

  // ../../node_modules/@near-js/signers/lib/commonjs/signer.cjs
  var require_signer = __commonJS({
    "../../node_modules/@near-js/signers/lib/commonjs/signer.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signer = void 0;
      var Signer2 = class {
      };
      exports.Signer = Signer2;
    }
  });

  // ../../node_modules/@near-js/signers/lib/commonjs/in_memory_signer.cjs
  var require_in_memory_signer = __commonJS({
    "../../node_modules/@near-js/signers/lib/commonjs/in_memory_signer.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InMemorySigner = void 0;
      var crypto_1 = require_commonjs3();
      var keystores_1 = require_commonjs6();
      var sha256_1 = require_sha2562();
      var signer_1 = require_signer();
      var InMemorySigner2 = class _InMemorySigner extends signer_1.Signer {
        keyStore;
        constructor(keyStore) {
          super();
          this.keyStore = keyStore;
        }
        /**
         * Creates a single account Signer instance with account, network and keyPair provided.
         *
         * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).
         *
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         * @param accountId The NEAR account to assign the key pair to
         * @param keyPair The keyPair to use for signing
         */
        static async fromKeyPair(networkId, accountId, keyPair) {
          const keyStore = new keystores_1.InMemoryKeyStore();
          await keyStore.setKey(networkId, accountId, keyPair);
          return new _InMemorySigner(keyStore);
        }
        /**
         * Creates a public key for the account given
         * @param accountId The NEAR account to assign a public key to
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         * @returns {Promise<PublicKey>}
         */
        async createKey(accountId, networkId, keyType) {
          const keyPair = keyType === crypto_1.KeyType.SECP256K1 ? crypto_1.KeyPair.fromRandom("secp256k1") : crypto_1.KeyPair.fromRandom("ed25519");
          await this.keyStore.setKey(networkId, accountId, keyPair);
          return keyPair.getPublicKey();
        }
        /**
         * Gets the existing public key for a given account
         * @param accountId The NEAR account to assign a public key to
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         * @returns {Promise<PublicKey>} Returns the public key or null if not found
         */
        async getPublicKey(accountId, networkId) {
          const keyPair = await this.keyStore.getKey(networkId, accountId);
          if (keyPair === null) {
            return null;
          }
          return keyPair.getPublicKey();
        }
        /**
         * @param message A message to be signed, typically a serialized transaction
         * @param accountId the NEAR account signing the message
         * @param networkId The targeted network. (ex. default, betanet, etc…)
         * @returns {Promise<Signature>}
         */
        async signMessage(message, accountId, networkId) {
          const hash = new Uint8Array((0, sha256_1.sha256)(message));
          if (!accountId) {
            throw new Error("InMemorySigner requires provided account id");
          }
          const keyPair = await this.keyStore.getKey(networkId, accountId);
          if (keyPair === null) {
            throw new Error(`Key for ${accountId} not found in ${networkId}`);
          }
          return keyPair.sign(hash);
        }
        toString() {
          return `InMemorySigner(${this.keyStore})`;
        }
      };
      exports.InMemorySigner = InMemorySigner2;
    }
  });

  // ../../node_modules/@near-js/signers/lib/commonjs/index.cjs
  var require_commonjs7 = __commonJS({
    "../../node_modules/@near-js/signers/lib/commonjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signer = exports.InMemorySigner = void 0;
      var in_memory_signer_1 = require_in_memory_signer();
      Object.defineProperty(exports, "InMemorySigner", { enumerable: true, get: function() {
        return in_memory_signer_1.InMemorySigner;
      } });
      var signer_1 = require_signer();
      Object.defineProperty(exports, "Signer", { enumerable: true, get: function() {
        return signer_1.Signer;
      } });
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/connection.cjs
  var require_connection = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/connection.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Connection = void 0;
      var signers_1 = require_commonjs7();
      var providers_1 = require_commonjs5();
      function getProvider2(config) {
        switch (config.type) {
          case void 0:
            return config;
          case "JsonRpcProvider":
            return new providers_1.JsonRpcProvider({ ...config.args });
          case "FailoverRpcProvider": {
            const providers = (config?.args || []).map((arg) => new providers_1.JsonRpcProvider(arg));
            return new providers_1.FailoverRpcProvider(providers);
          }
          default:
            throw new Error(`Unknown provider type ${config.type}`);
        }
      }
      function getSigner2(config) {
        switch (config.type) {
          case void 0:
            return config;
          case "InMemorySigner": {
            return new signers_1.InMemorySigner(config.keyStore);
          }
          default:
            throw new Error(`Unknown signer type ${config.type}`);
        }
      }
      var Connection2 = class _Connection {
        networkId;
        provider;
        signer;
        jsvmAccountId;
        constructor(networkId, provider, signer, jsvmAccountId) {
          this.networkId = networkId;
          this.provider = provider;
          this.signer = signer;
          this.jsvmAccountId = jsvmAccountId;
        }
        getConnection() {
          return this;
        }
        /**
         * @param config Contains connection info details
         */
        static fromConfig(config) {
          const provider = getProvider2(config.provider);
          const signer = getSigner2(config.signer);
          return new _Connection(config.networkId, provider, signer, config.jsvmAccountId);
        }
      };
      exports.Connection = Connection2;
    }
  });

  // ../../node_modules/lru_map/dist/lru.js
  var require_lru = __commonJS({
    "../../node_modules/lru_map/dist/lru.js"(exports, module) {
      !function(g, c) {
        typeof exports == "object" && typeof module != "undefined" ? c(exports) : typeof define == "function" && define.amd ? define(["exports"], c) : c((g = g || self).lru_map = g.lru_map || {});
      }(exports, function(g) {
        const c = Symbol("newer"), e = Symbol("older");
        class n {
          constructor(a, b) {
            typeof a !== "number" && (b = a, a = 0), this.size = 0, this.limit = a, this.oldest = this.newest = void 0, this._keymap = /* @__PURE__ */ new Map(), b && (this.assign(b), a < 1 && (this.limit = this.size));
          }
          _markEntryAsUsed(a) {
            if (a === this.newest) return;
            a[c] && (a === this.oldest && (this.oldest = a[c]), a[c][e] = a[e]), a[e] && (a[e][c] = a[c]), a[c] = void 0, a[e] = this.newest, this.newest && (this.newest[c] = a), this.newest = a;
          }
          assign(a) {
            let b, d = this.limit || Number.MAX_VALUE;
            this._keymap.clear();
            let m = a[Symbol.iterator]();
            for (let h = m.next(); !h.done; h = m.next()) {
              let f = new l(h.value[0], h.value[1]);
              this._keymap.set(f.key, f), b ? (b[c] = f, f[e] = b) : this.oldest = f, b = f;
              if (d-- == 0) throw new Error("overflow");
            }
            this.newest = b, this.size = this._keymap.size;
          }
          get(a) {
            var b = this._keymap.get(a);
            return b ? (this._markEntryAsUsed(b), b.value) : void 0;
          }
          set(a, b) {
            var d = this._keymap.get(a);
            return d ? (d.value = b, this._markEntryAsUsed(d), this) : (this._keymap.set(a, d = new l(a, b)), this.newest ? (this.newest[c] = d, d[e] = this.newest) : this.oldest = d, this.newest = d, ++this.size, this.size > this.limit && this.shift(), this);
          }
          shift() {
            var a = this.oldest;
            if (a) return this.oldest[c] ? (this.oldest = this.oldest[c], this.oldest[e] = void 0) : (this.oldest = void 0, this.newest = void 0), a[c] = a[e] = void 0, this._keymap.delete(a.key), --this.size, [a.key, a.value];
          }
          find(a) {
            let b = this._keymap.get(a);
            return b ? b.value : void 0;
          }
          has(a) {
            return this._keymap.has(a);
          }
          delete(a) {
            var b = this._keymap.get(a);
            return b ? (this._keymap.delete(b.key), b[c] && b[e] ? (b[e][c] = b[c], b[c][e] = b[e]) : b[c] ? (b[c][e] = void 0, this.oldest = b[c]) : b[e] ? (b[e][c] = void 0, this.newest = b[e]) : this.oldest = this.newest = void 0, this.size--, b.value) : void 0;
          }
          clear() {
            this.oldest = this.newest = void 0, this.size = 0, this._keymap.clear();
          }
          keys() {
            return new j(this.oldest);
          }
          values() {
            return new k(this.oldest);
          }
          entries() {
            return this;
          }
          [Symbol.iterator]() {
            return new i(this.oldest);
          }
          forEach(a, b) {
            typeof b !== "object" && (b = this);
            let d = this.oldest;
            for (; d; ) a.call(b, d.value, d.key, this), d = d[c];
          }
          toJSON() {
            for (var a = new Array(this.size), b = 0, d = this.oldest; d; ) a[b++] = { key: d.key, value: d.value }, d = d[c];
            return a;
          }
          toString() {
            for (var a = "", b = this.oldest; b; ) a += String(b.key) + ":" + b.value, b = b[c], b && (a += " < ");
            return a;
          }
        }
        g.LRUMap = n;
        function l(a, b) {
          this.key = a, this.value = b, this[c] = void 0, this[e] = void 0;
        }
        function i(a) {
          this.entry = a;
        }
        i.prototype[Symbol.iterator] = function() {
          return this;
        }, i.prototype.next = function() {
          let a = this.entry;
          return a ? (this.entry = a[c], { done: false, value: [a.key, a.value] }) : { done: true, value: void 0 };
        };
        function j(a) {
          this.entry = a;
        }
        j.prototype[Symbol.iterator] = function() {
          return this;
        }, j.prototype.next = function() {
          let a = this.entry;
          return a ? (this.entry = a[c], { done: false, value: a.key }) : { done: true, value: void 0 };
        };
        function k(a) {
          this.entry = a;
        }
        k.prototype[Symbol.iterator] = function() {
          return this;
        }, k.prototype.next = function() {
          let a = this.entry;
          return a ? (this.entry = a[c], { done: false, value: a.value }) : { done: true, value: void 0 };
        };
      });
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/local-view-execution/storage.cjs
  var require_storage = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/local-view-execution/storage.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Storage = void 0;
      var lru_map_1 = require_lru();
      var Storage = class _Storage {
        cache;
        static MAX_ELEMENTS = 100;
        // map block hash to block height
        blockHeights;
        constructor(options = { max: _Storage.MAX_ELEMENTS }) {
          this.cache = new lru_map_1.LRUMap(options.max);
          this.blockHeights = /* @__PURE__ */ new Map();
        }
        load(blockRef) {
          const noBlockId = !("blockId" in blockRef);
          if (noBlockId)
            return void 0;
          let blockId = blockRef.blockId;
          if (blockId.toString().length == 44) {
            blockId = this.blockHeights.get(blockId.toString());
          }
          return this.cache.get(blockId);
        }
        save(blockHash, { blockHeight, blockTimestamp, contractCode, contractState }) {
          this.blockHeights.set(blockHash, blockHeight);
          this.cache.set(blockHeight, { blockHeight, blockTimestamp, contractCode, contractState });
        }
      };
      exports.Storage = Storage;
    }
  });

  // ../../node_modules/@near-js/accounts/node_modules/@noble/hashes/_assert.js
  var require_assert4 = __commonJS({
    "../../node_modules/@near-js/accounts/node_modules/@noble/hashes/_assert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports.bool = bool;
      function isBytes4(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      function bytes2(b, ...lengths) {
        if (!isBytes4(b))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports.bytes = bytes2;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports.hash = hash;
      function exists2(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports.exists = exists2;
      function output2(out, instance) {
        bytes2(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      exports.output = output2;
      var assert = { number, bool, bytes: bytes2, hash, exists: exists2, output: output2 };
      exports.default = assert;
    }
  });

  // ../../node_modules/@near-js/accounts/node_modules/@noble/hashes/crypto.js
  var require_crypto4 = __commonJS({
    "../../node_modules/@near-js/accounts/node_modules/@noble/hashes/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // ../../node_modules/@near-js/accounts/node_modules/@noble/hashes/utils.js
  var require_utils11 = __commonJS({
    "../../node_modules/@near-js/accounts/node_modules/@noble/hashes/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
      var crypto_1 = require_crypto4();
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports.u32 = u32;
      function isBytes4(a) {
        return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
      }
      var createView4 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.createView = createView4;
      var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
      exports.rotr = rotr2;
      exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex3(bytes2) {
        if (!isBytes4(bytes2))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes2.length; i++) {
          hex += hexes3[bytes2[i]];
        }
        return hex;
      }
      exports.bytesToHex = bytesToHex3;
      var asciis2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function asciiToBase162(char) {
        if (char >= asciis2._0 && char <= asciis2._9)
          return char - asciis2._0;
        if (char >= asciis2._A && char <= asciis2._F)
          return char - (asciis2._A - 10);
        if (char >= asciis2._a && char <= asciis2._f)
          return char - (asciis2._a - 10);
        return;
      }
      function hexToBytes3(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const hl = hex.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + hl);
        const array = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase162(hex.charCodeAt(hi));
          const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array[ai] = n1 * 16 + n2;
        }
        return array;
      }
      exports.hexToBytes = hexToBytes3;
      var nextTick = async () => {
      };
      exports.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      exports.asyncLoop = asyncLoop;
      function utf8ToBytes4(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports.utf8ToBytes = utf8ToBytes4;
      function toBytes4(data) {
        if (typeof data === "string")
          data = utf8ToBytes4(data);
        if (!isBytes4(data))
          throw new Error(`expected Uint8Array, got ${typeof data}`);
        return data;
      }
      exports.toBytes = toBytes4;
      function concatBytes5(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          if (!isBytes4(a))
            throw new Error("Uint8Array expected");
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      exports.concatBytes = concatBytes5;
      var Hash4 = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports.Hash = Hash4;
      var toStr2 = {}.toString;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && toStr2.call(opts) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports.checkOpts = checkOpts;
      function wrapConstructor4(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports.wrapConstructor = wrapConstructor4;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes3(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports.randomBytes = randomBytes3;
    }
  });

  // ../../node_modules/@near-js/accounts/node_modules/@noble/hashes/_sha2.js
  var require_sha24 = __commonJS({
    "../../node_modules/@near-js/accounts/node_modules/@noble/hashes/_sha2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA2 = void 0;
      var _assert_js_1 = require_assert4();
      var utils_js_1 = require_utils11();
      function setBigUint644(view, byteOffset, value, isLE2) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE2);
        const _32n3 = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n3 & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE2 ? 4 : 0;
        const l = isLE2 ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE2);
        view.setUint32(byteOffset + l, wl, isLE2);
      }
      var SHA22 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE2) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE2;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
          (0, _assert_js_1.exists)(this);
          const { view, buffer, blockLen } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.output)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE: isLE2 } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint644(view, blockLen - 8, BigInt(this.length * 8), isLE2);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE2);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports.SHA2 = SHA22;
    }
  });

  // ../../node_modules/@near-js/accounts/node_modules/@noble/hashes/sha256.js
  var require_sha2563 = __commonJS({
    "../../node_modules/@near-js/accounts/node_modules/@noble/hashes/sha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha224 = exports.sha256 = void 0;
      var _sha2_js_1 = require_sha24();
      var utils_js_1 = require_utils11();
      var Chi2 = (a, b, c) => a & b ^ ~a & c;
      var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
      var SHA256_K2 = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
      var SHA2562 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W2[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W2[i - 15];
            const W2 = SHA256_W2[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj2(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W2.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA224 = class extends SHA2562 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA2562());
      exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/local-view-execution/runtime.cjs
  var require_runtime = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/local-view-execution/runtime.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Runtime = void 0;
      var sha256_1 = require_sha2563();
      var notImplemented = (name) => () => {
        throw new Error("method not implemented: " + name);
      };
      var prohibitedInView = (name) => () => {
        throw new Error("method not available for view calls: " + name);
      };
      var Runtime = class {
        context;
        wasm;
        memory;
        registers;
        logs;
        result;
        constructor({ contractCode, ...context }) {
          this.context = context;
          this.wasm = this.prepareWASM(Buffer.from(contractCode, "base64"));
          this.memory = new WebAssembly.Memory({ initial: 1024, maximum: 2048 });
          this.registers = {};
          this.logs = [];
          this.result = Buffer.from([]);
        }
        readUTF16CStr(ptr) {
          const arr = [];
          const mem = new Uint16Array(this.memory.buffer);
          let key = Number(ptr) / 2;
          while (mem[key] != 0) {
            arr.push(mem[key]);
            key++;
          }
          return Buffer.from(Uint16Array.from(arr).buffer).toString("ucs2");
        }
        readUTF8CStr(len, ptr) {
          const arr = [];
          const mem = new Uint8Array(this.memory.buffer);
          let key = Number(ptr);
          for (let i = 0; i < len && mem[key] != 0; i++) {
            arr.push(mem[key]);
            key++;
          }
          return Buffer.from(arr).toString("utf8");
        }
        storageRead(keyLen, keyPtr) {
          const storageKey = Buffer.from(new Uint8Array(this.memory.buffer, Number(keyPtr), Number(keyLen)));
          const stateVal = this.context.contractState.filter((obj) => Buffer.compare(obj.key, storageKey) === 0).map((obj) => obj.value);
          if (stateVal.length === 0)
            return null;
          return stateVal.length > 1 ? stateVal : stateVal[0];
        }
        prepareWASM(input) {
          const parts = [];
          const magic = input.subarray(0, 4);
          if (magic.toString("utf8") !== "\0asm") {
            throw new Error("Invalid magic number");
          }
          const version = input.readUInt32LE(4);
          if (version != 1) {
            throw new Error("Invalid version: " + version);
          }
          let offset = 8;
          parts.push(input.subarray(0, offset));
          function decodeLEB128() {
            let result = 0;
            let shift = 0;
            let byte;
            do {
              byte = input[offset++];
              result |= (byte & 127) << shift;
              shift += 7;
            } while (byte & 128);
            return result;
          }
          function decodeLimits() {
            const flags = input[offset++];
            const hasMax = flags & 1;
            const initial = decodeLEB128();
            const max = hasMax ? decodeLEB128() : null;
            return { initial, max };
          }
          function decodeString() {
            const length = decodeLEB128();
            const result = input.subarray(offset, offset + length);
            offset += length;
            return result.toString("utf8");
          }
          function encodeLEB128(value) {
            const result = [];
            do {
              let byte = value & 127;
              value >>= 7;
              if (value !== 0) {
                byte |= 128;
              }
              result.push(byte);
            } while (value !== 0);
            return Buffer.from(result);
          }
          function encodeString(value) {
            const result = Buffer.from(value, "utf8");
            return Buffer.concat([encodeLEB128(result.length), result]);
          }
          do {
            const sectionStart = offset;
            const sectionId = input.readUInt8(offset);
            offset++;
            const sectionSize = decodeLEB128();
            const sectionEnd = offset + sectionSize;
            if (sectionId == 5) {
              parts.push(Buffer.from([5, 1, 0]));
            } else if (sectionId == 2) {
              const sectionParts = [];
              const numImports = decodeLEB128();
              for (let i = 0; i < numImports; i++) {
                const importStart = offset;
                decodeString();
                decodeString();
                const kind = input.readUInt8(offset);
                offset++;
                let skipImport = false;
                switch (kind) {
                  case 0:
                    decodeLEB128();
                    break;
                  case 1:
                    offset++;
                    decodeLimits();
                    break;
                  case 2:
                    decodeLimits();
                    skipImport = true;
                    break;
                  case 3:
                    offset++;
                    offset++;
                    break;
                  default:
                    throw new Error("Invalid import kind: " + kind);
                }
                if (!skipImport) {
                  sectionParts.push(input.subarray(importStart, offset));
                }
              }
              const importMemory = Buffer.concat([
                encodeString("env"),
                encodeString("memory"),
                Buffer.from([2]),
                // Memory import
                Buffer.from([0]),
                encodeLEB128(1)
              ]);
              sectionParts.push(importMemory);
              const sectionData = Buffer.concat([
                encodeLEB128(sectionParts.length),
                ...sectionParts
              ]);
              parts.push(Buffer.concat([
                Buffer.from([2]),
                // Import section
                encodeLEB128(sectionData.length),
                sectionData
              ]));
            } else if (sectionId == 7) {
              const sectionParts = [];
              const numExports = decodeLEB128();
              for (let i = 0; i < numExports; i++) {
                const exportStart = offset;
                decodeString();
                const kind = input.readUInt8(offset);
                offset++;
                decodeLEB128();
                if (kind !== 2) {
                  sectionParts.push(input.subarray(exportStart, offset));
                }
              }
              const sectionData = Buffer.concat([
                encodeLEB128(sectionParts.length),
                ...sectionParts
              ]);
              parts.push(Buffer.concat([
                Buffer.from([7]),
                // Export section
                encodeLEB128(sectionData.length),
                sectionData
              ]));
            } else {
              parts.push(input.subarray(sectionStart, sectionEnd));
            }
            offset = sectionEnd;
          } while (offset < input.length);
          return Buffer.concat(parts);
        }
        // Host functions
        getRegisterLength(registerId) {
          return BigInt(this.registers[registerId.toString()] ? this.registers[registerId.toString()].length : Number.MAX_SAFE_INTEGER);
        }
        readFromRegister(registerId, ptr) {
          const mem = new Uint8Array(this.memory.buffer);
          mem.set(this.registers[registerId.toString()] || Buffer.from([]), Number(ptr));
        }
        getCurrentAccountId(registerId) {
          this.registers[registerId.toString()] = Buffer.from(this.context.contractId);
        }
        inputMethodArgs(registerId) {
          this.registers[registerId.toString()] = Buffer.from(this.context.methodArgs);
        }
        getBlockHeight() {
          return BigInt(this.context.blockHeight);
        }
        getBlockTimestamp() {
          return BigInt(this.context.blockTimestamp);
        }
        sha256(valueLen, valuePtr, registerId) {
          const value = new Uint8Array(this.memory.buffer, Number(valuePtr), Number(valueLen));
          this.registers[registerId.toString()] = (0, sha256_1.sha256)(value);
        }
        returnValue(valueLen, valuePtr) {
          this.result = Buffer.from(new Uint8Array(this.memory.buffer, Number(valuePtr), Number(valueLen)));
        }
        panic(message) {
          throw new Error("panic: " + message);
        }
        abort(msg_ptr, filename_ptr, line, col) {
          const msg = this.readUTF16CStr(msg_ptr);
          const filename = this.readUTF16CStr(filename_ptr);
          const message = `${msg} ${filename}:${line}:${col}`;
          if (!msg || !filename) {
            throw new Error("abort: String encoding is bad UTF-16 sequence.");
          }
          throw new Error("abort: " + message);
        }
        appendToLog(len, ptr) {
          this.logs.push(this.readUTF8CStr(len, ptr));
        }
        readStorage(key_len, key_ptr, register_id) {
          const result = this.storageRead(key_len, key_ptr);
          if (result == null) {
            return 0n;
          }
          this.registers[register_id] = result;
          return 1n;
        }
        hasStorageKey(key_len, key_ptr) {
          const result = this.storageRead(key_len, key_ptr);
          if (result == null) {
            return 0n;
          }
          return 1n;
        }
        getHostImports() {
          return {
            register_len: this.getRegisterLength.bind(this),
            read_register: this.readFromRegister.bind(this),
            current_account_id: this.getCurrentAccountId.bind(this),
            input: this.inputMethodArgs.bind(this),
            block_index: this.getBlockHeight.bind(this),
            block_timestamp: this.getBlockTimestamp.bind(this),
            sha256: this.sha256.bind(this),
            value_return: this.returnValue.bind(this),
            abort: this.abort.bind(this),
            log_utf8: this.appendToLog.bind(this),
            log_utf16: this.appendToLog.bind(this),
            storage_read: this.readStorage.bind(this),
            storage_has_key: this.hasStorageKey.bind(this),
            panic: () => this.panic("explicit guest panic"),
            panic_utf8: (len, ptr) => this.panic(this.readUTF8CStr(len, ptr)),
            // Not implemented
            epoch_height: notImplemented("epoch_height"),
            storage_usage: notImplemented("storage_usage"),
            account_balance: notImplemented("account_balance"),
            account_locked_balance: notImplemented("account_locked_balance"),
            random_seed: notImplemented("random_seed"),
            ripemd160: notImplemented("ripemd160"),
            keccak256: notImplemented("keccak256"),
            keccak512: notImplemented("keccak512"),
            ecrecover: notImplemented("ecrecover"),
            validator_stake: notImplemented("validator_stake"),
            validator_total_stake: notImplemented("validator_total_stake"),
            // Prohibited
            write_register: prohibitedInView("write_register"),
            signer_account_id: prohibitedInView("signer_account_id"),
            signer_account_pk: prohibitedInView("signer_account_pk"),
            predecessor_account_id: prohibitedInView("predecessor_account_id"),
            attached_deposit: prohibitedInView("attached_deposit"),
            prepaid_gas: prohibitedInView("prepaid_gas"),
            used_gas: prohibitedInView("used_gas"),
            promise_create: prohibitedInView("promise_create"),
            promise_then: prohibitedInView("promise_then"),
            promise_and: prohibitedInView("promise_and"),
            promise_batch_create: prohibitedInView("promise_batch_create"),
            promise_batch_then: prohibitedInView("promise_batch_then"),
            promise_batch_action_create_account: prohibitedInView("promise_batch_action_create_account"),
            promise_batch_action_deploy_contract: prohibitedInView("promise_batch_action_deploy_contract"),
            promise_batch_action_function_call: prohibitedInView("promise_batch_action_function_call"),
            promise_batch_action_function_call_weight: prohibitedInView("promise_batch_action_function_call_weight"),
            promise_batch_action_transfer: prohibitedInView("promise_batch_action_transfer"),
            promise_batch_action_stake: prohibitedInView("promise_batch_action_stake"),
            promise_batch_action_add_key_with_full_access: prohibitedInView("promise_batch_action_add_key_with_full_access"),
            promise_batch_action_add_key_with_function_call: prohibitedInView("promise_batch_action_add_key_with_function_call"),
            promise_batch_action_delete_key: prohibitedInView("promise_batch_action_delete_key"),
            promise_batch_action_delete_account: prohibitedInView("promise_batch_action_delete_account"),
            promise_results_count: prohibitedInView("promise_results_count"),
            promise_result: prohibitedInView("promise_result"),
            promise_return: prohibitedInView("promise_return"),
            storage_write: prohibitedInView("storage_write"),
            storage_remove: prohibitedInView("storage_remove")
          };
        }
        async execute(methodName) {
          const module2 = await WebAssembly.compile(this.wasm);
          const instance = await WebAssembly.instantiate(module2, { env: { ...this.getHostImports(), memory: this.memory } });
          const callMethod = instance.exports[methodName];
          if (callMethod == void 0) {
            throw new Error(`Contract method '${methodName}' does not exists in contract ${this.context.contractId} for block id ${this.context.blockHeight}`);
          }
          callMethod();
          return {
            result: this.result,
            logs: this.logs
          };
        }
      };
      exports.Runtime = Runtime;
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/local-view-execution/index.cjs
  var require_local_view_execution = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/local-view-execution/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocalViewExecution = void 0;
      var utils_1 = require_commonjs2();
      var storage_1 = require_storage();
      var runtime_1 = require_runtime();
      var utils_2 = require_utils9();
      var LocalViewExecution = class {
        connection;
        storage;
        constructor(connection) {
          this.connection = connection.getConnection();
          this.storage = new storage_1.Storage();
        }
        async fetchContractCode(contractId, blockQuery) {
          const result = await this.connection.provider.query({
            request_type: "view_code",
            account_id: contractId,
            ...blockQuery
          });
          return result.code_base64;
        }
        async fetchContractState(contractId, blockQuery) {
          return (0, utils_2.viewState)(this.connection, contractId, "", blockQuery);
        }
        async fetch(contractId, blockQuery) {
          const block = await this.connection.provider.block(blockQuery);
          const blockHash = block.header.hash;
          const blockHeight = block.header.height;
          const blockTimestamp = block.header.timestamp;
          const contractCode = await this.fetchContractCode(contractId, blockQuery);
          const contractState = await this.fetchContractState(contractId, blockQuery);
          return {
            blockHash,
            blockHeight,
            blockTimestamp,
            contractCode,
            contractState
          };
        }
        async loadOrFetch(contractId, blockQuery) {
          const stored = this.storage.load(blockQuery);
          if (stored) {
            return stored;
          }
          const { blockHash, ...fetched } = await this.fetch(contractId, blockQuery);
          this.storage.save(blockHash, fetched);
          return fetched;
        }
        /**
         * Calls a view function on a contract, fetching the contract code and state if needed.
         * @param options Options for calling the view function.
         * @param options.contractId The contract account ID.
         * @param options.methodName The name of the view function to call.
         * @param options.args The arguments to pass to the view function.
         * @param options.blockQuery The block query options.
         * @returns {Promise<any>} - A promise that resolves to the result of the view function.
         */
        async viewFunction({ contractId, methodName, args = {}, blockQuery = { finality: "optimistic" } }) {
          const methodArgs = JSON.stringify(args);
          const { contractCode, contractState, blockHeight, blockTimestamp } = await this.loadOrFetch(contractId, blockQuery);
          const runtime = new runtime_1.Runtime({ contractId, contractCode, contractState, blockHeight, blockTimestamp, methodArgs });
          const { result, logs } = await runtime.execute(methodName);
          if (logs) {
            (0, utils_1.printTxOutcomeLogs)({ contractId, logs });
          }
          return JSON.parse(Buffer.from(result).toString());
        }
      };
      exports.LocalViewExecution = LocalViewExecution;
    }
  });

  // ../../node_modules/is-property/is-property.js
  var require_is_property = __commonJS({
    "../../node_modules/is-property/is-property.js"(exports, module) {
      "use strict";
      function isProperty(str) {
        return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str);
      }
      module.exports = isProperty;
    }
  });

  // ../../node_modules/generate-object-property/index.js
  var require_generate_object_property = __commonJS({
    "../../node_modules/generate-object-property/index.js"(exports, module) {
      var isProperty = require_is_property();
      var gen = function(obj, prop) {
        return isProperty(prop) ? obj + "." + prop : obj + "[" + JSON.stringify(prop) + "]";
      };
      gen.valid = isProperty;
      gen.property = function(prop) {
        return isProperty(prop) ? prop : JSON.stringify(prop);
      };
      module.exports = gen;
    }
  });

  // ../../node_modules/generate-function/index.js
  var require_generate_function = __commonJS({
    "../../node_modules/generate-function/index.js"(exports, module) {
      var util = __require("util");
      var isProperty = require_is_property();
      var INDENT_START = /[\{\[]/;
      var INDENT_END = /[\}\]]/;
      var RESERVED = [
        "do",
        "if",
        "in",
        "for",
        "let",
        "new",
        "try",
        "var",
        "case",
        "else",
        "enum",
        "eval",
        "null",
        "this",
        "true",
        "void",
        "with",
        "await",
        "break",
        "catch",
        "class",
        "const",
        "false",
        "super",
        "throw",
        "while",
        "yield",
        "delete",
        "export",
        "import",
        "public",
        "return",
        "static",
        "switch",
        "typeof",
        "default",
        "extends",
        "finally",
        "package",
        "private",
        "continue",
        "debugger",
        "function",
        "arguments",
        "interface",
        "protected",
        "implements",
        "instanceof",
        "NaN",
        "undefined"
      ];
      var RESERVED_MAP = {};
      for (i = 0; i < RESERVED.length; i++) {
        RESERVED_MAP[RESERVED[i]] = true;
      }
      var i;
      var isVariable = function(name) {
        return isProperty(name) && !RESERVED_MAP.hasOwnProperty(name);
      };
      var formats = {
        s: function(s) {
          return "" + s;
        },
        d: function(d) {
          return "" + Number(d);
        },
        o: function(o) {
          return JSON.stringify(o);
        }
      };
      var genfun = function() {
        var lines = [];
        var indent = 0;
        var vars = {};
        var push2 = function(str) {
          var spaces = "";
          while (spaces.length < indent * 2) spaces += "  ";
          lines.push(spaces + str);
        };
        var pushLine = function(line2) {
          if (INDENT_END.test(line2.trim()[0]) && INDENT_START.test(line2[line2.length - 1])) {
            indent--;
            push2(line2);
            indent++;
            return;
          }
          if (INDENT_START.test(line2[line2.length - 1])) {
            push2(line2);
            indent++;
            return;
          }
          if (INDENT_END.test(line2.trim()[0])) {
            indent--;
            push2(line2);
            return;
          }
          push2(line2);
        };
        var line = function(fmt) {
          if (!fmt) return line;
          if (arguments.length === 1 && fmt.indexOf("\n") > -1) {
            var lines2 = fmt.trim().split("\n");
            for (var i2 = 0; i2 < lines2.length; i2++) {
              pushLine(lines2[i2].trim());
            }
          } else {
            pushLine(util.format.apply(util, arguments));
          }
          return line;
        };
        line.scope = {};
        line.formats = formats;
        line.sym = function(name) {
          if (!name || !isVariable(name)) name = "tmp";
          if (!vars[name]) vars[name] = 0;
          return name + (vars[name]++ || "");
        };
        line.property = function(obj, name) {
          if (arguments.length === 1) {
            name = obj;
            obj = "";
          }
          name = name + "";
          if (isProperty(name)) return obj ? obj + "." + name : name;
          return obj ? obj + "[" + JSON.stringify(name) + "]" : JSON.stringify(name);
        };
        line.toString = function() {
          return lines.join("\n");
        };
        line.toFunction = function(scope) {
          if (!scope) scope = {};
          var src = "return (" + line.toString() + ")";
          Object.keys(line.scope).forEach(function(key) {
            if (!scope[key]) scope[key] = line.scope[key];
          });
          var keys = Object.keys(scope).map(function(key) {
            return key;
          });
          var vals = keys.map(function(key) {
            return scope[key];
          });
          return Function.apply(null, keys.concat(src)).apply(null, vals);
        };
        if (arguments.length) line.apply(null, arguments);
        return line;
      };
      genfun.formats = formats;
      module.exports = genfun;
    }
  });

  // ../../node_modules/jsonpointer/jsonpointer.js
  var require_jsonpointer = __commonJS({
    "../../node_modules/jsonpointer/jsonpointer.js"(exports) {
      var hasExcape = /~/;
      var escapeMatcher = /~[01]/g;
      function escapeReplacer(m) {
        switch (m) {
          case "~1":
            return "/";
          case "~0":
            return "~";
        }
        throw new Error("Invalid tilde escape: " + m);
      }
      function untilde(str) {
        if (!hasExcape.test(str)) return str;
        return str.replace(escapeMatcher, escapeReplacer);
      }
      function setter(obj, pointer, value) {
        var part;
        var hasNextPart;
        for (var p = 1, len = pointer.length; p < len; ) {
          if (pointer[p] === "constructor" || pointer[p] === "prototype" || pointer[p] === "__proto__") return obj;
          part = untilde(pointer[p++]);
          hasNextPart = len > p;
          if (typeof obj[part] === "undefined") {
            if (Array.isArray(obj) && part === "-") {
              part = obj.length;
            }
            if (hasNextPart) {
              if (pointer[p] !== "" && pointer[p] < Infinity || pointer[p] === "-") obj[part] = [];
              else obj[part] = {};
            }
          }
          if (!hasNextPart) break;
          obj = obj[part];
        }
        var oldValue = obj[part];
        if (value === void 0) delete obj[part];
        else obj[part] = value;
        return oldValue;
      }
      function compilePointer(pointer) {
        if (typeof pointer === "string") {
          pointer = pointer.split("/");
          if (pointer[0] === "") return pointer;
          throw new Error("Invalid JSON pointer.");
        } else if (Array.isArray(pointer)) {
          for (const part of pointer) {
            if (typeof part !== "string" && typeof part !== "number") {
              throw new Error("Invalid JSON pointer. Must be of type string or number.");
            }
          }
          return pointer;
        }
        throw new Error("Invalid JSON pointer.");
      }
      function get(obj, pointer) {
        if (typeof obj !== "object") throw new Error("Invalid input object.");
        pointer = compilePointer(pointer);
        var len = pointer.length;
        if (len === 1) return obj;
        for (var p = 1; p < len; ) {
          obj = obj[untilde(pointer[p++])];
          if (len === p) return obj;
          if (typeof obj !== "object" || obj === null) return void 0;
        }
      }
      function set(obj, pointer, value) {
        if (typeof obj !== "object") throw new Error("Invalid input object.");
        pointer = compilePointer(pointer);
        if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
        return setter(obj, pointer, value);
      }
      function compile(pointer) {
        var compiled = compilePointer(pointer);
        return {
          get: function(object) {
            return get(object, compiled);
          },
          set: function(object, value) {
            return set(object, compiled, value);
          }
        };
      }
      exports.get = get;
      exports.set = set;
      exports.compile = compile;
    }
  });

  // ../../node_modules/xtend/immutable.js
  var require_immutable = __commonJS({
    "../../node_modules/xtend/immutable.js"(exports, module) {
      module.exports = extend;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }
    }
  });

  // ../../node_modules/is-my-ip-valid/index.js
  var require_is_my_ip_valid = __commonJS({
    "../../node_modules/is-my-ip-valid/index.js"(exports, module) {
      var reIpv4FirstPass = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
      var reSubnetString = /\/\d{1,3}(?=%|$)/;
      var reForwardSlash = /\//;
      var reZone = /%.*$/;
      var reBadCharacters = /([^0-9a-f:/%])/i;
      var reBadAddress = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/i;
      function validate4(input) {
        if (!reIpv4FirstPass.test(input)) return false;
        var parts = input.split(".");
        if (parts.length !== 4) return false;
        if (parts[0][0] === "0" && parts[0].length > 1) return false;
        if (parts[1][0] === "0" && parts[1].length > 1) return false;
        if (parts[2][0] === "0" && parts[2].length > 1) return false;
        if (parts[3][0] === "0" && parts[3].length > 1) return false;
        var n0 = Number(parts[0]);
        var n1 = Number(parts[1]);
        var n2 = Number(parts[2]);
        var n3 = Number(parts[3]);
        return n0 >= 0 && n0 < 256 && n1 >= 0 && n1 < 256 && n2 >= 0 && n2 < 256 && n3 >= 0 && n3 < 256;
      }
      function validate6(input) {
        var withoutSubnet = input.replace(reSubnetString, "");
        var hasSubnet = input.length !== withoutSubnet.length;
        if (hasSubnet) return false;
        if (!hasSubnet) {
          if (reForwardSlash.test(input)) return false;
        }
        var withoutZone = withoutSubnet.replace(reZone, "");
        var lastPartSeparator = withoutZone.lastIndexOf(":");
        if (lastPartSeparator === -1) return false;
        var lastPart = withoutZone.substring(lastPartSeparator + 1);
        var hasV4Part = validate4(lastPart);
        var address = hasV4Part ? withoutZone.substring(0, lastPartSeparator + 1) + "1234:5678" : withoutZone;
        if (reBadCharacters.test(address)) return false;
        if (reBadAddress.test(address)) return false;
        var halves = address.split("::");
        if (halves.length > 2) return false;
        if (halves.length === 2) {
          var first = halves[0] === "" ? [] : halves[0].split(":");
          var last = halves[1] === "" ? [] : halves[1].split(":");
          var remainingLength = 8 - (first.length + last.length);
          if (remainingLength <= 0) return false;
        } else {
          if (address.split(":").length !== 8) return false;
        }
        return true;
      }
      function validate(input) {
        return validate4(input) || validate6(input);
      }
      module.exports = function validator(options) {
        if (!options) options = {};
        if (options.version === 4) return validate4;
        if (options.version === 6) return validate6;
        if (options.version == null) return validate;
        throw new Error("Unknown version: " + options.version);
      };
      module.exports["__all_regexes__"] = [
        reIpv4FirstPass,
        reSubnetString,
        reForwardSlash,
        reZone,
        reBadCharacters,
        reBadAddress
      ];
    }
  });

  // ../../node_modules/is-my-json-valid/formats.js
  var require_formats = __commonJS({
    "../../node_modules/is-my-json-valid/formats.js"(exports) {
      var createIpValidator = require_is_my_ip_valid();
      var reEmailWhitespace = /\s/;
      var reHostnameFirstPass = /^[a-zA-Z0-9.-]+$/;
      var reHostnamePart = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/;
      var rePhoneFirstPass = /^\+[0-9][0-9 ]{5,27}[0-9]$/;
      var rePhoneDoubleSpace = / {2}/;
      var rePhoneGlobalSpace = / /g;
      exports["date-time"] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(?:\.\d+|)([zZ]|[+-]\d{2}:\d{2})$/;
      exports["date"] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/;
      exports["time"] = /^\d{2}:\d{2}:\d{2}$/;
      exports["email"] = function(input) {
        return input.indexOf("@") !== -1 && !reEmailWhitespace.test(input);
      };
      exports["ip-address"] = exports["ipv4"] = createIpValidator({ version: 4 });
      exports["ipv6"] = createIpValidator({ version: 6 });
      exports["uri"] = /^[a-zA-Z][a-zA-Z0-9+\-.]*:[^\s]*$/;
      exports["color"] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/;
      exports["hostname"] = function(input) {
        if (!reHostnameFirstPass.test(input)) return false;
        var parts = input.split(".");
        for (var i = 0; i < parts.length; i++) {
          if (!reHostnamePart.test(parts[i])) return false;
        }
        return true;
      };
      exports["alpha"] = /^[a-zA-Z]+$/;
      exports["alphanumeric"] = /^[a-zA-Z0-9]+$/;
      exports["style"] = /.:\s*[^;]/g;
      exports["phone"] = function(input) {
        if (!rePhoneFirstPass.test(input)) return false;
        if (rePhoneDoubleSpace.test(input)) return false;
        var digits = input.substring(1).replace(rePhoneGlobalSpace, "").length;
        return digits >= 7 && digits <= 15;
      };
      exports["utc-millisec"] = /^[0-9]{1,15}\.?[0-9]{0,15}$/;
    }
  });

  // ../../node_modules/is-my-json-valid/index.js
  var require_is_my_json_valid = __commonJS({
    "../../node_modules/is-my-json-valid/index.js"(exports, module) {
      var genobj = require_generate_object_property();
      var genfun = require_generate_function();
      var jsonpointer = require_jsonpointer();
      var xtend = require_immutable();
      var formats = require_formats();
      var get = function(obj, additionalSchemas, ptr) {
        var visit = function(sub) {
          if (sub && sub.id === ptr) return sub;
          if (typeof sub !== "object" || !sub) return null;
          return Object.keys(sub).reduce(function(res2, k) {
            return res2 || visit(sub[k]);
          }, null);
        };
        var res = visit(obj);
        if (res) return res;
        ptr = ptr.replace(/^#/, "");
        ptr = ptr.replace(/\/$/, "");
        try {
          return jsonpointer.get(obj, decodeURI(ptr));
        } catch (err) {
          var end = ptr.indexOf("#");
          var other;
          if (end !== 0) {
            if (end === -1) {
              other = additionalSchemas[ptr];
            } else {
              var ext = ptr.slice(0, end);
              other = additionalSchemas[ext];
              var fragment = ptr.slice(end).replace(/^#/, "");
              try {
                return jsonpointer.get(other, fragment);
              } catch (err2) {
              }
            }
          } else {
            other = additionalSchemas[ptr];
          }
          return other || null;
        }
      };
      var types = {};
      types.any = function() {
        return "true";
      };
      types.null = function(name) {
        return name + " === null";
      };
      types.boolean = function(name) {
        return "typeof " + name + ' === "boolean"';
      };
      types.array = function(name) {
        return "Array.isArray(" + name + ")";
      };
      types.object = function(name) {
        return "typeof " + name + ' === "object" && ' + name + " && !Array.isArray(" + name + ")";
      };
      types.number = function(name) {
        return "typeof " + name + ' === "number" && isFinite(' + name + ")";
      };
      types.integer = function(name) {
        return "typeof " + name + ' === "number" && (Math.floor(' + name + ") === " + name + " || " + name + " > 9007199254740992 || " + name + " < -9007199254740992)";
      };
      types.string = function(name) {
        return "typeof " + name + ' === "string"';
      };
      var unique = function(array, len) {
        len = Math.min(len === -1 ? array.length : len, array.length);
        var list = [];
        for (var i = 0; i < len; i++) {
          list.push(typeof array[i] === "object" ? JSON.stringify(array[i]) : array[i]);
        }
        for (var i = 1; i < list.length; i++) {
          if (list.indexOf(list[i]) !== i) return false;
        }
        return true;
      };
      var isMultipleOf = function(name, multipleOf) {
        var res;
        var factor = (multipleOf | 0) !== multipleOf ? Math.pow(10, multipleOf.toString().split(".").pop().length) : 1;
        if (factor > 1) {
          var factorName = (name | 0) !== name ? Math.pow(10, name.toString().split(".").pop().length) : 1;
          if (factorName > factor) res = true;
          else res = Math.round(factor * name) % (factor * multipleOf);
        } else res = name % multipleOf;
        return !res;
      };
      var testLimitedRegex = function(r, s, maxLength) {
        if (maxLength > -1 && s.length > maxLength) return true;
        return r.test(s);
      };
      var compile = function(schema, cache, root, reporter, opts) {
        var fmts = opts ? xtend(formats, opts.formats) : formats;
        var scope = { unique, formats: fmts, isMultipleOf, testLimitedRegex };
        var verbose = opts ? !!opts.verbose : false;
        var greedy = opts && opts.greedy !== void 0 ? opts.greedy : false;
        var syms = {};
        var allocated = [];
        var gensym = function(name) {
          var res = name + (syms[name] = (syms[name] || 0) + 1);
          allocated.push(res);
          return res;
        };
        var formatName = function(field) {
          var s = JSON.stringify(field);
          try {
            var pattern = /\[([^\[\]"]+)\]/;
            while (pattern.test(s)) s = s.replace(pattern, replacer);
            return s;
          } catch (_) {
            return JSON.stringify(field);
          }
          function replacer(match, v) {
            if (allocated.indexOf(v) === -1) throw new Error("Unreplaceable");
            return '." + ' + v + ' + "';
          }
        };
        var reversePatterns = {};
        var patterns = function(p) {
          if (reversePatterns[p]) return reversePatterns[p];
          var n = gensym("pattern");
          scope[n] = new RegExp(p);
          reversePatterns[p] = n;
          return n;
        };
        var vars = ["i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z"];
        var genloop = function() {
          var v = vars.shift();
          vars.push(v + v[0]);
          allocated.push(v);
          return v;
        };
        var visit = function(name, node, reporter2, filter, schemaPath) {
          var properties = node.properties;
          var type = node.type;
          var tuple = false;
          if (Array.isArray(node.items)) {
            properties = {};
            node.items.forEach(function(item, i2) {
              properties[i2] = item;
            });
            type = "array";
            tuple = true;
          }
          var indent = 0;
          var error = function(msg, prop, value) {
            validate("errors++");
            if (reporter2 === true) {
              validate("if (validate.errors === null) validate.errors = []");
              if (verbose) {
                validate(
                  "validate.errors.push({field:%s,message:%s,value:%s,type:%s,schemaPath:%s})",
                  formatName(prop || name),
                  JSON.stringify(msg),
                  value || name,
                  JSON.stringify(type),
                  JSON.stringify(schemaPath)
                );
              } else {
                validate("validate.errors.push({field:%s,message:%s})", formatName(prop || name), JSON.stringify(msg));
              }
            }
          };
          if (node.required === true) {
            indent++;
            validate("if (%s === undefined) {", name);
            error("is required");
            validate("} else {");
          } else {
            indent++;
            validate("if (%s !== undefined) {", name);
          }
          var valid2 = [].concat(type).map(function(t) {
            if (t && !types.hasOwnProperty(t)) {
              throw new Error("Unknown type: " + t);
            }
            return types[t || "any"](name);
          }).join(" || ") || "true";
          if (valid2 !== "true") {
            indent++;
            validate("if (!(%s)) {", valid2);
            error("is the wrong type");
            validate("} else {");
          }
          if (tuple) {
            if (node.additionalItems === false) {
              validate("if (%s.length > %d) {", name, node.items.length);
              error("has additional items");
              validate("}");
            } else if (node.additionalItems) {
              var i = genloop();
              validate("for (var %s = %d; %s < %s.length; %s++) {", i, node.items.length, i, name, i);
              visit(name + "[" + i + "]", node.additionalItems, reporter2, filter, schemaPath.concat("additionalItems"));
              validate("}");
            }
          }
          if (node.format && fmts[node.format]) {
            if (type !== "string" && formats[node.format]) validate("if (%s) {", types.string(name));
            var n = gensym("format");
            scope[n] = fmts[node.format];
            if (typeof scope[n] === "function") validate("if (!%s(%s)) {", n, name);
            else validate("if (!testLimitedRegex(%s, %s, %d)) {", n, name, typeof node.maxLength === "undefined" ? -1 : node.maxLength);
            error("must be " + node.format + " format");
            validate("}");
            if (type !== "string" && formats[node.format]) validate("}");
          }
          if (Array.isArray(node.required)) {
            var n = gensym("missing");
            validate("var %s = 0", n);
            var checkRequired = function(req) {
              var prop = genobj(name, req);
              validate("if (%s === undefined) {", prop);
              error("is required", prop);
              validate("%s++", n);
              validate("}");
            };
            validate("if ((%s)) {", type !== "object" ? types.object(name) : "true");
            node.required.map(checkRequired);
            validate("}");
            if (!greedy) {
              validate("if (%s === 0) {", n);
              indent++;
            }
          }
          if (node.uniqueItems) {
            if (type !== "array") validate("if (%s) {", types.array(name));
            validate("if (!(unique(%s, %d))) {", name, node.maxItems || -1);
            error("must be unique");
            validate("}");
            if (type !== "array") validate("}");
          }
          if (node.enum) {
            var complex = node.enum.some(function(e) {
              return typeof e === "object";
            });
            var compare = complex ? function(e) {
              return "JSON.stringify(" + name + ") !== JSON.stringify(" + JSON.stringify(e) + ")";
            } : function(e) {
              return name + " !== " + JSON.stringify(e);
            };
            validate("if (%s) {", node.enum.map(compare).join(" && ") || "false");
            error("must be an enum value");
            validate("}");
          }
          if (node.dependencies) {
            if (type !== "object") validate("if (%s) {", types.object(name));
            Object.keys(node.dependencies).forEach(function(key) {
              var deps = node.dependencies[key];
              if (typeof deps === "string") deps = [deps];
              var exists2 = function(k) {
                return genobj(name, k) + " !== undefined";
              };
              if (Array.isArray(deps)) {
                validate("if (%s !== undefined && !(%s)) {", genobj(name, key), deps.map(exists2).join(" && ") || "true");
                error("dependencies not set");
                validate("}");
              }
              if (typeof deps === "object") {
                validate("if (%s !== undefined) {", genobj(name, key));
                visit(name, deps, reporter2, filter, schemaPath.concat(["dependencies", key]));
                validate("}");
              }
            });
            if (type !== "object") validate("}");
          }
          if (node.additionalProperties || node.additionalProperties === false) {
            if (type !== "object") validate("if (%s) {", types.object(name));
            var i = genloop();
            var keys = gensym("keys");
            var toCompare = function(p2) {
              return keys + "[" + i + "] !== " + JSON.stringify(p2);
            };
            var toTest = function(p2) {
              return "!" + patterns(p2) + ".test(" + keys + "[" + i + "])";
            };
            var additionalProp = Object.keys(properties || {}).map(toCompare).concat(Object.keys(node.patternProperties || {}).map(toTest)).join(" && ") || "true";
            validate("var %s = Object.keys(%s)", keys, name)("for (var %s = 0; %s < %s.length; %s++) {", i, i, keys, i)("if (%s) {", additionalProp);
            if (node.additionalProperties === false) {
              if (filter) validate("delete %s", name + "[" + keys + "[" + i + "]]");
              error("has additional properties", null, JSON.stringify(name + ".") + " + " + keys + "[" + i + "]");
            } else {
              visit(name + "[" + keys + "[" + i + "]]", node.additionalProperties, reporter2, filter, schemaPath.concat(["additionalProperties"]));
            }
            validate("}")("}");
            if (type !== "object") validate("}");
          }
          if (node.$ref) {
            var sub = get(root, opts && opts.schemas || {}, node.$ref);
            if (sub) {
              var fn = cache[node.$ref];
              if (!fn) {
                cache[node.$ref] = function proxy(data) {
                  return fn(data);
                };
                fn = compile(sub, cache, root, false, opts);
              }
              var n = gensym("ref");
              scope[n] = fn;
              validate("if (!(%s(%s))) {", n, name);
              error("referenced schema does not match");
              validate("}");
            }
          }
          if (node.not) {
            var prev = gensym("prev");
            validate("var %s = errors", prev);
            visit(name, node.not, false, filter, schemaPath.concat("not"));
            validate("if (%s === errors) {", prev);
            error("negative schema matches");
            validate("} else {")("errors = %s", prev)("}");
          }
          if (node.items && !tuple) {
            if (type !== "array") validate("if (%s) {", types.array(name));
            var i = genloop();
            validate("for (var %s = 0; %s < %s.length; %s++) {", i, i, name, i);
            visit(name + "[" + i + "]", node.items, reporter2, filter, schemaPath.concat("items"));
            validate("}");
            if (type !== "array") validate("}");
          }
          if (node.patternProperties) {
            if (type !== "object") validate("if (%s) {", types.object(name));
            var keys = gensym("keys");
            var i = genloop();
            validate("var %s = Object.keys(%s)", keys, name)("for (var %s = 0; %s < %s.length; %s++) {", i, i, keys, i);
            Object.keys(node.patternProperties).forEach(function(key) {
              var p2 = patterns(key);
              validate("if (%s.test(%s)) {", p2, keys + "[" + i + "]");
              visit(name + "[" + keys + "[" + i + "]]", node.patternProperties[key], reporter2, filter, schemaPath.concat(["patternProperties", key]));
              validate("}");
            });
            validate("}");
            if (type !== "object") validate("}");
          }
          if (node.pattern) {
            var p = patterns(node.pattern);
            if (type !== "string") validate("if (%s) {", types.string(name));
            validate("if (!(testLimitedRegex(%s, %s, %d))) {", p, name, typeof node.maxLength === "undefined" ? -1 : node.maxLength);
            error("pattern mismatch");
            validate("}");
            if (type !== "string") validate("}");
          }
          if (node.allOf) {
            node.allOf.forEach(function(sch, key) {
              visit(name, sch, reporter2, filter, schemaPath.concat(["allOf", key]));
            });
          }
          if (node.anyOf && node.anyOf.length) {
            var prev = gensym("prev");
            node.anyOf.forEach(function(sch, i2) {
              if (i2 === 0) {
                validate("var %s = errors", prev);
              } else {
                validate("if (errors !== %s) {", prev)("errors = %s", prev);
              }
              visit(name, sch, false, false, schemaPath);
            });
            node.anyOf.forEach(function(sch, i2) {
              if (i2) validate("}");
            });
            validate("if (%s !== errors) {", prev);
            error("no schemas match");
            validate("}");
          }
          if (node.oneOf && node.oneOf.length) {
            var prev = gensym("prev");
            var passes = gensym("passes");
            validate("var %s = errors", prev)("var %s = 0", passes);
            node.oneOf.forEach(function(sch, i2) {
              visit(name, sch, false, false, schemaPath);
              validate("if (%s === errors) {", prev)("%s++", passes)("} else {")("errors = %s", prev)("}");
            });
            validate("if (%s !== 1) {", passes);
            error("no (or more than one) schemas match");
            validate("}");
          }
          if (node.multipleOf !== void 0) {
            if (type !== "number" && type !== "integer") validate("if (%s) {", types.number(name));
            validate("if (!isMultipleOf(%s, %d)) {", name, node.multipleOf);
            error("has a remainder");
            validate("}");
            if (type !== "number" && type !== "integer") validate("}");
          }
          if (node.maxProperties !== void 0) {
            if (type !== "object") validate("if (%s) {", types.object(name));
            validate("if (Object.keys(%s).length > %d) {", name, node.maxProperties);
            error("has more properties than allowed");
            validate("}");
            if (type !== "object") validate("}");
          }
          if (node.minProperties !== void 0) {
            if (type !== "object") validate("if (%s) {", types.object(name));
            validate("if (Object.keys(%s).length < %d) {", name, node.minProperties);
            error("has less properties than allowed");
            validate("}");
            if (type !== "object") validate("}");
          }
          if (node.maxItems !== void 0) {
            if (type !== "array") validate("if (%s) {", types.array(name));
            validate("if (%s.length > %d) {", name, node.maxItems);
            error("has more items than allowed");
            validate("}");
            if (type !== "array") validate("}");
          }
          if (node.minItems !== void 0) {
            if (type !== "array") validate("if (%s) {", types.array(name));
            validate("if (%s.length < %d) {", name, node.minItems);
            error("has less items than allowed");
            validate("}");
            if (type !== "array") validate("}");
          }
          if (node.maxLength !== void 0) {
            if (type !== "string") validate("if (%s) {", types.string(name));
            validate("if (%s.length > %d) {", name, node.maxLength);
            error("has longer length than allowed");
            validate("}");
            if (type !== "string") validate("}");
          }
          if (node.minLength !== void 0) {
            if (type !== "string") validate("if (%s) {", types.string(name));
            validate("if (%s.length < %d) {", name, node.minLength);
            error("has less length than allowed");
            validate("}");
            if (type !== "string") validate("}");
          }
          if (node.minimum !== void 0) {
            if (type !== "number" && type !== "integer") validate("if (%s) {", types.number(name));
            validate("if (%s %s %d) {", name, node.exclusiveMinimum ? "<=" : "<", node.minimum);
            error("is less than minimum");
            validate("}");
            if (type !== "number" && type !== "integer") validate("}");
          }
          if (node.maximum !== void 0) {
            if (type !== "number" && type !== "integer") validate("if (%s) {", types.number(name));
            validate("if (%s %s %d) {", name, node.exclusiveMaximum ? ">=" : ">", node.maximum);
            error("is more than maximum");
            validate("}");
            if (type !== "number" && type !== "integer") validate("}");
          }
          if (properties) {
            Object.keys(properties).forEach(function(p2) {
              if (Array.isArray(type) && type.indexOf("null") !== -1) validate("if (%s !== null) {", name);
              visit(
                genobj(name, p2),
                properties[p2],
                reporter2,
                filter,
                schemaPath.concat(tuple ? p2 : ["properties", p2])
              );
              if (Array.isArray(type) && type.indexOf("null") !== -1) validate("}");
            });
          }
          while (indent--) validate("}");
        };
        var validate = genfun("function validate(data) {")("if (data === undefined) data = null")("validate.errors = null")("var errors = 0");
        visit("data", schema, reporter, opts && opts.filter, []);
        validate("return errors === 0")("}");
        validate = validate.toFunction(scope);
        validate.errors = null;
        if (Object.defineProperty) {
          Object.defineProperty(validate, "error", {
            get: function() {
              if (!validate.errors) return "";
              return validate.errors.map(function(err) {
                return err.field + " " + err.message;
              }).join("\n");
            }
          });
        }
        validate.toJSON = function() {
          return schema;
        };
        return validate;
      };
      module.exports = function(schema, opts) {
        if (typeof schema === "string") schema = JSON.parse(schema);
        return compile(schema, {}, schema, true, opts);
      };
      module.exports.filter = function(schema, opts) {
        var validate = module.exports(schema, xtend(opts, { filter: true }));
        return function(sch) {
          validate(sch);
          return sch;
        };
      };
    }
  });

  // ../../node_modules/near-abi/lib/index.js
  var require_lib2 = __commonJS({
    "../../node_modules/near-abi/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbiSerializationType = exports.AbiFunctionModifier = exports.AbiFunctionKind = exports.SCHEMA_VERSION = void 0;
      exports.SCHEMA_VERSION = "0.3.0";
      var AbiFunctionKind;
      (function(AbiFunctionKind2) {
        AbiFunctionKind2["View"] = "view";
        AbiFunctionKind2["Call"] = "call";
      })(AbiFunctionKind = exports.AbiFunctionKind || (exports.AbiFunctionKind = {}));
      var AbiFunctionModifier;
      (function(AbiFunctionModifier2) {
        AbiFunctionModifier2["Init"] = "init";
        AbiFunctionModifier2["Private"] = "private";
        AbiFunctionModifier2["Payable"] = "payable";
      })(AbiFunctionModifier = exports.AbiFunctionModifier || (exports.AbiFunctionModifier = {}));
      var AbiSerializationType;
      (function(AbiSerializationType2) {
        AbiSerializationType2["Json"] = "json";
        AbiSerializationType2["Borsh"] = "borsh";
      })(AbiSerializationType = exports.AbiSerializationType || (exports.AbiSerializationType = {}));
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/errors.cjs
  var require_errors4 = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/errors.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConflictingOptions = exports.ArgumentSchemaError = exports.UnknownArgumentError = exports.UnsupportedSerializationError = void 0;
      var UnsupportedSerializationError2 = class extends Error {
        constructor(methodName, serializationType) {
          super(`Contract method '${methodName}' is using an unsupported serialization type ${serializationType}`);
        }
      };
      exports.UnsupportedSerializationError = UnsupportedSerializationError2;
      var UnknownArgumentError2 = class extends Error {
        constructor(actualArgName, expectedArgNames) {
          super(`Unrecognized argument '${actualArgName}', expected '${JSON.stringify(expectedArgNames)}'`);
        }
      };
      exports.UnknownArgumentError = UnknownArgumentError2;
      var ArgumentSchemaError2 = class extends Error {
        constructor(argName, errors) {
          super(`Argument '${argName}' does not conform to the specified ABI schema: '${JSON.stringify(errors)}'`);
        }
      };
      exports.ArgumentSchemaError = ArgumentSchemaError2;
      var ConflictingOptions2 = class extends Error {
        constructor() {
          super("Conflicting contract method options have been passed. You can either specify ABI or a list of view/call methods.");
        }
      };
      exports.ConflictingOptions = ConflictingOptions2;
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/contract.cjs
  var require_contract = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/contract.cjs"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Contract = void 0;
      var utils_1 = require_commonjs2();
      var types_1 = require_commonjs();
      var local_view_execution_1 = require_local_view_execution();
      var is_my_json_valid_1 = __importDefault(require_is_my_json_valid());
      var depd_1 = __importDefault(require_browser());
      var near_abi_1 = require_lib2();
      var account_1 = require_account();
      var errors_1 = require_errors4();
      var utils_2 = require_utils9();
      function nameFunction(name, body) {
        return {
          [name](...args) {
            return body(...args);
          }
        }[name];
      }
      function validateArguments(args, abiFunction, abiRoot) {
        if (!isObject2(args))
          return;
        if (abiFunction.params && abiFunction.params.serialization_type !== near_abi_1.AbiSerializationType.Json) {
          throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.params.serialization_type);
        }
        if (abiFunction.result && abiFunction.result.serialization_type !== near_abi_1.AbiSerializationType.Json) {
          throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.result.serialization_type);
        }
        const params2 = abiFunction.params?.args || [];
        for (const p of params2) {
          const arg = args[p.name];
          const typeSchema = p.type_schema;
          typeSchema.definitions = abiRoot.body.root_schema.definitions;
          const validate = (0, is_my_json_valid_1.default)(typeSchema);
          const valid2 = validate(arg);
          if (!valid2) {
            throw new errors_1.ArgumentSchemaError(p.name, validate.errors);
          }
        }
        for (const argName of Object.keys(args)) {
          const param = params2.find((p) => p.name === argName);
          if (!param) {
            throw new errors_1.UnknownArgumentError(argName, params2.map((p) => p.name));
          }
        }
      }
      var isUint8Array = (x) => x && x.byteLength !== void 0 && x.byteLength === x.length;
      var isObject2 = (x) => Object.prototype.toString.call(x) === "[object Object]";
      var Contract = class {
        /** @deprecated */
        account;
        connection;
        contractId;
        lve;
        /**
         * @param account NEAR account to sign change method transactions
         * @param contractId NEAR account id where the contract is deployed
         * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`
         */
        constructor(connection, contractId, options) {
          this.connection = connection.getConnection();
          if (connection instanceof account_1.Account) {
            const deprecate = (0, depd_1.default)("new Contract(account, contractId, options)");
            deprecate("use `new Contract(connection, contractId, options)` instead");
            this.account = connection;
          }
          this.contractId = contractId;
          this.lve = new local_view_execution_1.LocalViewExecution(connection);
          const { viewMethods = [], changeMethods = [], abi: abiRoot, useLocalViewExecution } = options;
          let viewMethodsWithAbi = viewMethods.map((name) => ({
            name,
            abi: null
          }));
          let changeMethodsWithAbi = changeMethods.map((name) => ({
            name,
            abi: null
          }));
          if (abiRoot) {
            if (viewMethodsWithAbi.length > 0 || changeMethodsWithAbi.length > 0) {
              throw new errors_1.ConflictingOptions();
            }
            viewMethodsWithAbi = abiRoot.body.functions.filter((m) => m.kind === near_abi_1.AbiFunctionKind.View).map((m) => ({ name: m.name, abi: m }));
            changeMethodsWithAbi = abiRoot.body.functions.filter((methodAbi) => methodAbi.kind === near_abi_1.AbiFunctionKind.Call).map((methodAbi) => ({ name: methodAbi.name, abi: methodAbi }));
          }
          viewMethodsWithAbi.forEach(({ name, abi }) => {
            Object.defineProperty(this, name, {
              writable: false,
              enumerable: true,
              value: nameFunction(name, async (args = {}, options2 = {}, ...ignored) => {
                if (ignored.length || !(isObject2(args) || isUint8Array(args)) || !isObject2(options2)) {
                  throw new types_1.PositionalArgsError();
                }
                if (abi) {
                  validateArguments(args, abi, abiRoot);
                }
                if (useLocalViewExecution) {
                  try {
                    return await this.lve.viewFunction({
                      contractId: this.contractId,
                      methodName: name,
                      args,
                      ...options2
                    });
                  } catch (error) {
                    utils_1.Logger.warn(`Local view execution failed with: "${error.message}"`);
                    utils_1.Logger.warn(`Fallback to normal RPC call`);
                  }
                }
                if (this.account) {
                  return this.account.viewFunction({
                    contractId: this.contractId,
                    methodName: name,
                    args,
                    ...options2
                  });
                }
                return (0, utils_2.viewFunction)(this.connection, {
                  contractId: this.contractId,
                  methodName: name,
                  args,
                  ...options2
                });
              })
            });
          });
          changeMethodsWithAbi.forEach(({ name, abi }) => {
            Object.defineProperty(this, name, {
              writable: false,
              enumerable: true,
              value: nameFunction(name, async (...args) => {
                if (args.length && (args.length > 3 || !(isObject2(args[0]) || isUint8Array(args[0])))) {
                  throw new types_1.PositionalArgsError();
                }
                if (args.length > 1 || !(args[0] && args[0].args)) {
                  const deprecate = (0, depd_1.default)("contract.methodName(args, gas, amount)");
                  deprecate("use `contract.methodName({ signerAccount, args, gas?, amount?, callbackUrl?, meta? })` instead");
                  args[0] = {
                    args: args[0],
                    gas: args[1],
                    amount: args[2]
                  };
                }
                if (abi) {
                  validateArguments(args[0].args, abi, abiRoot);
                }
                return this._changeMethod({ methodName: name, ...args[0] });
              })
            });
          });
        }
        async _changeMethod({ signerAccount, args, methodName, gas, amount, meta, callbackUrl }) {
          validateBNLike({ gas, amount });
          const account = this.account || signerAccount;
          if (!account)
            throw new Error(`signerAccount must be specified`);
          const rawResult = await account.functionCall({
            contractId: this.contractId,
            methodName,
            args,
            gas,
            attachedDeposit: amount,
            walletMeta: meta,
            walletCallbackUrl: callbackUrl
          });
          return (0, utils_1.getTransactionLastResult)(rawResult);
        }
      };
      exports.Contract = Contract;
      function validateBNLike(argMap) {
        const bnLike = "number, decimal string or BigInt";
        for (const argName of Object.keys(argMap)) {
          const argValue = argMap[argName];
          if (argValue && typeof argValue !== "bigint" && isNaN(argValue)) {
            throw new types_1.ArgumentTypeError(argName, bnLike, argValue);
          }
        }
      }
    }
  });

  // ../../node_modules/@near-js/accounts/lib/commonjs/index.cjs
  var require_commonjs8 = __commonJS({
    "../../node_modules/@near-js/accounts/lib/commonjs/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.UnsupportedSerializationError = exports.UnknownArgumentError = exports.ConflictingOptions = exports.ArgumentSchemaError = exports.Contract = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = exports.Connection = exports.AccountMultisig = exports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = exports.Account2FA = exports.Account = void 0;
      var account_1 = require_account();
      Object.defineProperty(exports, "Account", { enumerable: true, get: function() {
        return account_1.Account;
      } });
      var account_2fa_1 = require_account_2fa();
      Object.defineProperty(exports, "Account2FA", { enumerable: true, get: function() {
        return account_2fa_1.Account2FA;
      } });
      var account_creator_1 = require_account_creator();
      Object.defineProperty(exports, "AccountCreator", { enumerable: true, get: function() {
        return account_creator_1.AccountCreator;
      } });
      Object.defineProperty(exports, "LocalAccountCreator", { enumerable: true, get: function() {
        return account_creator_1.LocalAccountCreator;
      } });
      Object.defineProperty(exports, "UrlAccountCreator", { enumerable: true, get: function() {
        return account_creator_1.UrlAccountCreator;
      } });
      var account_multisig_1 = require_account_multisig();
      Object.defineProperty(exports, "AccountMultisig", { enumerable: true, get: function() {
        return account_multisig_1.AccountMultisig;
      } });
      var connection_1 = require_connection();
      Object.defineProperty(exports, "Connection", { enumerable: true, get: function() {
        return connection_1.Connection;
      } });
      var constants_1 = require_constants3();
      Object.defineProperty(exports, "MULTISIG_STORAGE_KEY", { enumerable: true, get: function() {
        return constants_1.MULTISIG_STORAGE_KEY;
      } });
      Object.defineProperty(exports, "MULTISIG_ALLOWANCE", { enumerable: true, get: function() {
        return constants_1.MULTISIG_ALLOWANCE;
      } });
      Object.defineProperty(exports, "MULTISIG_GAS", { enumerable: true, get: function() {
        return constants_1.MULTISIG_GAS;
      } });
      Object.defineProperty(exports, "MULTISIG_DEPOSIT", { enumerable: true, get: function() {
        return constants_1.MULTISIG_DEPOSIT;
      } });
      Object.defineProperty(exports, "MULTISIG_CHANGE_METHODS", { enumerable: true, get: function() {
        return constants_1.MULTISIG_CHANGE_METHODS;
      } });
      Object.defineProperty(exports, "MULTISIG_CONFIRM_METHODS", { enumerable: true, get: function() {
        return constants_1.MULTISIG_CONFIRM_METHODS;
      } });
      var contract_1 = require_contract();
      Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
        return contract_1.Contract;
      } });
      var errors_1 = require_errors4();
      Object.defineProperty(exports, "ArgumentSchemaError", { enumerable: true, get: function() {
        return errors_1.ArgumentSchemaError;
      } });
      Object.defineProperty(exports, "ConflictingOptions", { enumerable: true, get: function() {
        return errors_1.ConflictingOptions;
      } });
      Object.defineProperty(exports, "UnknownArgumentError", { enumerable: true, get: function() {
        return errors_1.UnknownArgumentError;
      } });
      Object.defineProperty(exports, "UnsupportedSerializationError", { enumerable: true, get: function() {
        return errors_1.UnsupportedSerializationError;
      } });
      var types_1 = require_types2();
      Object.defineProperty(exports, "MultisigDeleteRequestRejectionError", { enumerable: true, get: function() {
        return types_1.MultisigDeleteRequestRejectionError;
      } });
      Object.defineProperty(exports, "MultisigStateStatus", { enumerable: true, get: function() {
        return types_1.MultisigStateStatus;
      } });
    }
  });

  // ../../node_modules/js-sha256/src/sha256.js
  var require_sha2564 = __commonJS({
    "../../node_modules/js-sha256/src/sha256.js"(exports, module) {
      (function() {
        "use strict";
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA256_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, is224) {
          return function(message) {
            return new Sha256(is224, true).update(message)[outputType]();
          };
        };
        var createMethod = function(is224) {
          var method = createOutputMethod("hex", is224);
          if (NODE_JS) {
            method = nodeWrap(method, is224);
          }
          method.create = function() {
            return new Sha256(is224);
          };
          method.update = function(message) {
            return method.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method[type] = createOutputMethod(type, is224);
          }
          return method;
        };
        var nodeWrap = function(method, is224) {
          var crypto4 = __require("crypto");
          var Buffer2 = __require("buffer").Buffer;
          var algorithm = is224 ? "sha224" : "sha256";
          var bufferFrom;
          if (Buffer2.from && !root.JS_SHA256_NO_BUFFER_FROM) {
            bufferFrom = Buffer2.from;
          } else {
            bufferFrom = function(message) {
              return new Buffer2(message);
            };
          }
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto4.createHash(algorithm).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer2) {
              return crypto4.createHash(algorithm).update(bufferFrom(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        var createHmacOutputMethod = function(outputType, is224) {
          return function(key, message) {
            return new HmacSha256(key, is224, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(is224) {
          var method = createHmacOutputMethod("hex", is224);
          method.create = function(key) {
            return new HmacSha256(key, is224);
          };
          method.update = function(key, message) {
            return method.create(key).update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method[type] = createHmacOutputMethod(type, is224);
          }
          return method;
        };
        function Sha256(is224, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is224) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is224;
        }
        Sha256.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
            notString = true;
          }
          var code, index = 0, i, length = message.length, blocks2 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              this.block = blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >>> 2] |= message[index] << SHIFT[i++ & 3];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >>> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >>> 2] |= (192 | code >>> 6) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >>> 2] |= (224 | code >>> 12) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >>> 2] |= (240 | code >>> 18) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 64) {
              this.block = blocks2[16];
              this.start = i - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha256.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i = this.lastByteIndex;
          blocks2[16] = this.block;
          blocks2[i >>> 2] |= EXTRA[i & 3];
          this.block = blocks2[16];
          if (i >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[15] = this.bytes << 3;
          this.hash();
        };
        Sha256.prototype.hash = function() {
          var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
          for (j = 16; j < 64; ++j) {
            t1 = blocks2[j - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks2[j - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
          }
          bc = b & c;
          for (j = 0; j < 64; j += 4) {
            if (this.first) {
              if (this.is224) {
                ab = 300032;
                t1 = blocks2[0] - 1413257819;
                h = t1 - 150054599 << 0;
                d = t1 + 24177077 << 0;
              } else {
                ab = 704751109;
                t1 = blocks2[0] - 210244248;
                h = t1 - 1521486534 << 0;
                d = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ab = a & b;
              maj = ab ^ a & c ^ bc;
              ch = e & f ^ ~e & g;
              t1 = h + s1 + ch + K[j] + blocks2[j];
              t2 = s0 + maj;
              h = d + t1 << 0;
              d = t1 + t2 << 0;
            }
            s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
            s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
            da = d & a;
            maj = da ^ d & b ^ ab;
            ch = h & e ^ ~h & f;
            t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
            t2 = s0 + maj;
            g = c + t1 << 0;
            c = t1 + t2 << 0;
            s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
            s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
            cd = c & d;
            maj = cd ^ c & a ^ da;
            ch = g & h ^ ~g & e;
            t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
            t2 = s0 + maj;
            f = b + t1 << 0;
            b = t1 + t2 << 0;
            s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
            s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
            bc = b & c;
            maj = bc ^ b & d ^ cd;
            ch = f & g ^ ~f & h;
            t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
            t2 = s0 + maj;
            e = a + t1 << 0;
            a = t1 + t2 << 0;
            this.chromeBugWorkAround = true;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
          this.h4 = this.h4 + e << 0;
          this.h5 = this.h5 + f << 0;
          this.h6 = this.h6 + g << 0;
          this.h7 = this.h7 + h << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >>> 28 & 15] + HEX_CHARS[h5 >>> 24 & 15] + HEX_CHARS[h5 >>> 20 & 15] + HEX_CHARS[h5 >>> 16 & 15] + HEX_CHARS[h5 >>> 12 & 15] + HEX_CHARS[h5 >>> 8 & 15] + HEX_CHARS[h5 >>> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >>> 28 & 15] + HEX_CHARS[h6 >>> 24 & 15] + HEX_CHARS[h6 >>> 20 & 15] + HEX_CHARS[h6 >>> 16 & 15] + HEX_CHARS[h6 >>> 12 & 15] + HEX_CHARS[h6 >>> 8 & 15] + HEX_CHARS[h6 >>> 4 & 15] + HEX_CHARS[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS[h7 >>> 28 & 15] + HEX_CHARS[h7 >>> 24 & 15] + HEX_CHARS[h7 >>> 20 & 15] + HEX_CHARS[h7 >>> 16 & 15] + HEX_CHARS[h7 >>> 12 & 15] + HEX_CHARS[h7 >>> 8 & 15] + HEX_CHARS[h7 >>> 4 & 15] + HEX_CHARS[h7 & 15];
          }
          return hex;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >>> 24 & 255,
            h0 >>> 16 & 255,
            h0 >>> 8 & 255,
            h0 & 255,
            h1 >>> 24 & 255,
            h1 >>> 16 & 255,
            h1 >>> 8 & 255,
            h1 & 255,
            h2 >>> 24 & 255,
            h2 >>> 16 & 255,
            h2 >>> 8 & 255,
            h2 & 255,
            h3 >>> 24 & 255,
            h3 >>> 16 & 255,
            h3 >>> 8 & 255,
            h3 & 255,
            h4 >>> 24 & 255,
            h4 >>> 16 & 255,
            h4 >>> 8 & 255,
            h4 & 255,
            h5 >>> 24 & 255,
            h5 >>> 16 & 255,
            h5 >>> 8 & 255,
            h5 & 255,
            h6 >>> 24 & 255,
            h6 >>> 16 & 255,
            h6 >>> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer;
        };
        function HmacSha256(key, is224, sharedMemory) {
          var i, type = typeof key;
          if (type === "string") {
            var bytes2 = [], length = key.length, index = 0, code;
            for (i = 0; i < length; ++i) {
              code = key.charCodeAt(i);
              if (code < 128) {
                bytes2[index++] = code;
              } else if (code < 2048) {
                bytes2[index++] = 192 | code >>> 6;
                bytes2[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes2[index++] = 224 | code >>> 12;
                bytes2[index++] = 128 | code >>> 6 & 63;
                bytes2[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
                bytes2[index++] = 240 | code >>> 18;
                bytes2[index++] = 128 | code >>> 12 & 63;
                bytes2[index++] = 128 | code >>> 6 & 63;
                bytes2[index++] = 128 | code & 63;
              }
            }
            key = bytes2;
          } else {
            if (type === "object") {
              if (key === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
          }
          if (key.length > 64) {
            key = new Sha256(is224, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i = 0; i < 64; ++i) {
            var b = key[i] || 0;
            oKeyPad[i] = 92 ^ b;
            iKeyPad[i] = 54 ^ b;
          }
          Sha256.call(this, is224, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports2 = createMethod();
        exports2.sha256 = exports2;
        exports2.sha224 = createMethod(true);
        exports2.sha256.hmac = createHmacMethod();
        exports2.sha224.hmac = createHmacMethod(true);
        if (COMMON_JS) {
          module.exports = exports2;
        } else {
          root.sha256 = exports2.sha256;
          root.sha224 = exports2.sha224;
          if (AMD) {
            define(function() {
              return exports2;
            });
          }
        }
      })();
    }
  });

  // ../../node_modules/@here-wallet/core/build/helpers/actions.js
  var require_actions2 = __commonJS({
    "../../node_modules/@here-wallet/core/build/helpers/actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createAction = exports.parseArgs = void 0;
      var crypto_1 = require_commonjs3();
      var transactions_1 = require_commonjs4();
      var getAccessKey = (permission) => {
        if (permission === "FullAccess") {
          return transactions_1.actionCreators.fullAccessKey();
        }
        const { receiverId, methodNames = [] } = permission;
        const allowance = permission.allowance ? BigInt(permission.allowance) : void 0;
        return transactions_1.actionCreators.functionCallAccessKey(receiverId, methodNames, allowance);
      };
      var parseArgs = (data) => {
        if (typeof data === "string")
          return Buffer.from(data, "base64");
        return data;
      };
      exports.parseArgs = parseArgs;
      var createAction = (action) => {
        switch (action.type) {
          case "CreateAccount":
            return transactions_1.actionCreators.createAccount();
          case "DeployContract": {
            const { code } = action.params;
            return transactions_1.actionCreators.deployContract(code);
          }
          case "FunctionCall": {
            const { methodName, args, gas, deposit } = action.params;
            return transactions_1.actionCreators.functionCall(methodName, (0, exports.parseArgs)(args), BigInt(gas), BigInt(deposit));
          }
          case "Transfer": {
            const { deposit } = action.params;
            return transactions_1.actionCreators.transfer(BigInt(deposit));
          }
          case "Stake": {
            const { stake: stake4, publicKey } = action.params;
            return transactions_1.actionCreators.stake(BigInt(stake4), crypto_1.PublicKey.from(publicKey));
          }
          case "AddKey": {
            const { publicKey, accessKey } = action.params;
            return transactions_1.actionCreators.addKey(
              crypto_1.PublicKey.from(publicKey),
              // TODO: Use accessKey.nonce? near-api-js seems to think 0 is fine?
              getAccessKey(accessKey.permission)
            );
          }
          case "DeleteKey": {
            const { publicKey } = action.params;
            return transactions_1.actionCreators.deleteKey(crypto_1.PublicKey.from(publicKey));
          }
          case "DeleteAccount": {
            const { beneficiaryId } = action.params;
            return transactions_1.actionCreators.deleteAccount(beneficiaryId);
          }
          default:
            throw new Error("Invalid action type");
        }
      };
      exports.createAction = createAction;
    }
  });

  // ../../node_modules/@here-wallet/core/build/helpers/nep0314.js
  var require_nep0314 = __commonJS({
    "../../node_modules/@here-wallet/core/build/helpers/nep0314.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule) return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifySignature = exports.authPayloadSchema = exports.AuthPayload = void 0;
      var borsh = __importStar(require_cjs());
      var js_sha256_1 = __importDefault(require_sha2564());
      var crypto_1 = require_commonjs3();
      var AuthPayload = class {
        constructor({ message, nonce, recipient, callbackUrl }) {
          this.tag = 2147484061;
          this.message = message;
          this.nonce = nonce;
          this.recipient = recipient;
          if (callbackUrl) {
            this.callbackUrl = callbackUrl;
          }
        }
      };
      exports.AuthPayload = AuthPayload;
      exports.authPayloadSchema = {
        struct: {
          tag: "u32",
          message: "string",
          nonce: { array: { type: "u8", len: 32 } },
          recipient: "string",
          callbackUrl: { option: "string" }
        }
      };
      function verifySignature2(request, result) {
        const payload = new AuthPayload(request);
        const borsh_payload = borsh.serialize(exports.authPayloadSchema, payload);
        const to_sign = Uint8Array.from(js_sha256_1.default.sha256.array(borsh_payload));
        let real_signature = new Uint8Array(Buffer.from(result.signature, "base64"));
        const myPK = crypto_1.PublicKey.from(result.publicKey);
        return myPK.verify(to_sign, real_signature);
      }
      exports.verifySignature = verifySignature2;
    }
  });

  // ../../node_modules/uuid4/browser.mjs
  var browser_exports = {};
  __export(browser_exports, {
    default: () => browser_default,
    uuid4: () => uuid4,
    valid: () => valid
  });
  function valid(uuid) {
    return uuidPattern.test(uuid);
  }
  function uuid4() {
    var temp_url = URL.createObjectURL(new Blob());
    var uuid = temp_url.toString();
    URL.revokeObjectURL(temp_url);
    return uuid.split(/[:\/]/g).pop().toLowerCase();
  }
  var uuidPattern, browser_default;
  var init_browser = __esm({
    "../../node_modules/uuid4/browser.mjs"() {
      uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      uuid4.valid = valid;
      browser_default = uuid4;
    }
  });

  // ../../node_modules/@here-wallet/core/build/types.js
  var require_types3 = __commonJS({
    "../../node_modules/@here-wallet/core/build/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HereProviderError = exports.HereProviderStatus = void 0;
      var HereProviderStatus;
      (function(HereProviderStatus2) {
        HereProviderStatus2[HereProviderStatus2["APPROVING"] = 1] = "APPROVING";
        HereProviderStatus2[HereProviderStatus2["FAILED"] = 2] = "FAILED";
        HereProviderStatus2[HereProviderStatus2["SUCCESS"] = 3] = "SUCCESS";
      })(HereProviderStatus = exports.HereProviderStatus || (exports.HereProviderStatus = {}));
      var HereProviderError = class extends Error {
        constructor(payload, parentError) {
          super(payload !== null && payload !== void 0 ? payload : parentError === null || parentError === void 0 ? void 0 : parentError.message);
          this.payload = payload;
          this.parentError = parentError;
        }
      };
      exports.HereProviderError = HereProviderError;
    }
  });

  // ../../node_modules/@here-wallet/core/build/helpers/utils.js
  var require_utils12 = __commonJS({
    "../../node_modules/@here-wallet/core/build/helpers/utils.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isValidAccessKey = exports.internalThrow = exports.getPublicKeys = exports.serializeActions = exports.isMobile = exports.getDeviceId = void 0;
      var uuid4_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
      var types_1 = require_types3();
      var getDeviceId = () => {
        const topicId = (window === null || window === void 0 ? void 0 : window.localStorage.getItem("herewallet-topic")) || (0, uuid4_1.default)();
        window === null || window === void 0 ? void 0 : window.localStorage.setItem("herewallet-topic", topicId);
        return topicId;
      };
      exports.getDeviceId = getDeviceId;
      var isMobile = () => {
        return (window === null || window === void 0 ? void 0 : window.matchMedia("(any-pointer:coarse)").matches) || false;
      };
      exports.isMobile = isMobile;
      var serializeActions = (actions) => {
        return actions.map((act) => {
          if (act.type !== "FunctionCall")
            return act;
          let { args, deposit, gas, methodName } = act.params;
          if (ArrayBuffer.isView(args)) {
            args = Buffer.from(args.buffer, args.byteOffset, args.byteLength);
          }
          if (args instanceof Buffer) {
            args = args.toString("base64");
          }
          return {
            type: act.type,
            params: { args, deposit, gas, methodName }
          };
        });
      };
      exports.serializeActions = serializeActions;
      var getPublicKeys = (rpc, accountId) => __awaiter(void 0, void 0, void 0, function* () {
        const res = yield fetch(rpc, {
          method: "POST",
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: "dontcare",
            method: "query",
            params: {
              request_type: "view_access_key_list",
              finality: "final",
              account_id: accountId
            }
          }),
          headers: {
            "content-type": "application/json"
          }
        });
        if (res.ok === false) {
          return [];
        }
        const data = yield res.json();
        return data.result.keys;
      });
      exports.getPublicKeys = getPublicKeys;
      var internalThrow = (error, strategy, selector) => {
        if (error instanceof types_1.HereProviderError) {
          throw error;
        }
        const result = {
          payload: error instanceof Error ? error.message : "UNKNOWN",
          status: types_1.HereProviderStatus.FAILED,
          type: (selector === null || selector === void 0 ? void 0 : selector.type) || "web",
          account_id: (selector === null || selector === void 0 ? void 0 : selector.id) || ""
        };
        strategy.onFailed(result);
        throw error;
      };
      exports.internalThrow = internalThrow;
      var isValidAccessKey = (accountId, accessKey, call) => {
        const { permission } = accessKey.access_key;
        if (permission === "FullAccess") {
          return true;
        }
        if (permission.FunctionCall) {
          const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
          if (allowedReceiverId === accountId && allowedMethods.includes("add_request_and_confirm")) {
            return true;
          }
          if (allowedReceiverId === call.receiverId) {
            if (call.actions.length !== 1)
              return false;
            return call.actions.every((action) => {
              if (action.type !== "FunctionCall")
                return false;
              return (!action.params.deposit || action.params.deposit.toString() === "0") && (allowedMethods.length === 0 || allowedMethods.includes(action.params.methodName));
            });
          }
        }
        return false;
      };
      exports.isValidAccessKey = isValidAccessKey;
    }
  });

  // ../../node_modules/@here-wallet/core/build/storage/JSONStorage.js
  var require_JSONStorage = __commonJS({
    "../../node_modules/@here-wallet/core/build/storage/JSONStorage.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StateStorage = void 0;
      var mockStorage = {
        getItem(k) {
          return null;
        },
        setItem(k, v) {
        },
        removeItem(k) {
        }
      };
      var StateStorage = class {
        constructor() {
          this.dataKey = `herewallet:keystore`;
          this.storage = typeof window !== "undefined" ? window.localStorage : mockStorage;
        }
        setState(network, state) {
          return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.getFullState();
            data[network] = state;
            this.storage.setItem(this.dataKey, JSON.stringify(data));
          });
        }
        getFullState() {
          return __awaiter(this, void 0, void 0, function* () {
            try {
              return JSON.parse(this.storage.getItem(this.dataKey)) || {};
            } catch (_a) {
              return {};
            }
          });
        }
        getState(network) {
          return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.getFullState();
            return json[network] || { activeAccount: null, accounts: {} };
          });
        }
        clear() {
          return __awaiter(this, void 0, void 0, function* () {
            this.storage.removeItem(this.dataKey);
          });
        }
      };
      exports.StateStorage = StateStorage;
    }
  });

  // ../../node_modules/@here-wallet/core/build/storage/HereKeyStore.js
  var require_HereKeyStore = __commonJS({
    "../../node_modules/@here-wallet/core/build/storage/HereKeyStore.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HereKeyStore = void 0;
      var crypto_1 = require_commonjs3();
      var JSONStorage_1 = require_JSONStorage();
      var HereKeyStore = class {
        constructor(storage = new JSONStorage_1.StateStorage()) {
          this.storage = storage;
        }
        setActiveAccount(network, id) {
          return __awaiter(this, void 0, void 0, function* () {
            const state = yield this.storage.getState(network);
            state.activeAccount = id;
            this.storage.setState(network, state);
          });
        }
        setKey(networkId, accountId, keyPair) {
          return __awaiter(this, void 0, void 0, function* () {
            const state = yield this.storage.getState(networkId);
            state.accounts[accountId] = keyPair.toString();
            this.storage.setState(networkId, state);
          });
        }
        getAccounts(network) {
          return __awaiter(this, void 0, void 0, function* () {
            const state = yield this.storage.getState(network);
            return Object.keys(state.accounts);
          });
        }
        getActiveAccount(network) {
          return __awaiter(this, void 0, void 0, function* () {
            const state = yield this.storage.getState(network);
            return state.activeAccount;
          });
        }
        getKey(networkId, accountId) {
          return __awaiter(this, void 0, void 0, function* () {
            const state = yield this.storage.getState(networkId);
            const privateKey = state.accounts[accountId];
            if (privateKey == null)
              throw Error(`For ${accountId} in ${networkId} network key not found`);
            const keyPair = crypto_1.KeyPair.fromString(privateKey);
            return keyPair;
          });
        }
        removeKey(networkId, accountId) {
          return __awaiter(this, void 0, void 0, function* () {
            let state = yield this.storage.getState(networkId);
            if (state.activeAccount === accountId) {
              state.activeAccount = null;
            }
            delete state.accounts[accountId];
            this.storage.setState(networkId, state);
          });
        }
        getNetworks() {
          return __awaiter(this, void 0, void 0, function* () {
            let state = yield this.storage.getFullState();
            return Object.keys(state.accounts);
          });
        }
        clear() {
          return __awaiter(this, void 0, void 0, function* () {
            yield this.storage.clear();
          });
        }
      };
      exports.HereKeyStore = HereKeyStore;
    }
  });

  // ../../node_modules/crypt/crypt.js
  var require_crypt = __commonJS({
    "../../node_modules/crypt/crypt.js"(exports, module) {
      (function() {
        var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
          // Bit-wise rotation left
          rotl: function(n, b) {
            return n << b | n >>> 32 - b;
          },
          // Bit-wise rotation right
          rotr: function(n, b) {
            return n << 32 - b | n >>> b;
          },
          // Swap big-endian to little-endian and vice versa
          endian: function(n) {
            if (n.constructor == Number) {
              return crypt.rotl(n, 8) & 16711935 | crypt.rotl(n, 24) & 4278255360;
            }
            for (var i = 0; i < n.length; i++)
              n[i] = crypt.endian(n[i]);
            return n;
          },
          // Generate an array of any length of random bytes
          randomBytes: function(n) {
            for (var bytes2 = []; n > 0; n--)
              bytes2.push(Math.floor(Math.random() * 256));
            return bytes2;
          },
          // Convert a byte array to big-endian 32-bit words
          bytesToWords: function(bytes2) {
            for (var words = [], i = 0, b = 0; i < bytes2.length; i++, b += 8)
              words[b >>> 5] |= bytes2[i] << 24 - b % 32;
            return words;
          },
          // Convert big-endian 32-bit words to a byte array
          wordsToBytes: function(words) {
            for (var bytes2 = [], b = 0; b < words.length * 32; b += 8)
              bytes2.push(words[b >>> 5] >>> 24 - b % 32 & 255);
            return bytes2;
          },
          // Convert a byte array to a hex string
          bytesToHex: function(bytes2) {
            for (var hex = [], i = 0; i < bytes2.length; i++) {
              hex.push((bytes2[i] >>> 4).toString(16));
              hex.push((bytes2[i] & 15).toString(16));
            }
            return hex.join("");
          },
          // Convert a hex string to a byte array
          hexToBytes: function(hex) {
            for (var bytes2 = [], c = 0; c < hex.length; c += 2)
              bytes2.push(parseInt(hex.substr(c, 2), 16));
            return bytes2;
          },
          // Convert a byte array to a base-64 string
          bytesToBase64: function(bytes2) {
            for (var base64 = [], i = 0; i < bytes2.length; i += 3) {
              var triplet = bytes2[i] << 16 | bytes2[i + 1] << 8 | bytes2[i + 2];
              for (var j = 0; j < 4; j++)
                if (i * 8 + j * 6 <= bytes2.length * 8)
                  base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
                else
                  base64.push("=");
            }
            return base64.join("");
          },
          // Convert a base-64 string to a byte array
          base64ToBytes: function(base64) {
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
            for (var bytes2 = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
              if (imod4 == 0) continue;
              bytes2.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
            }
            return bytes2;
          }
        };
        module.exports = crypt;
      })();
    }
  });

  // ../../node_modules/charenc/charenc.js
  var require_charenc = __commonJS({
    "../../node_modules/charenc/charenc.js"(exports, module) {
      var charenc = {
        // UTF-8 encoding
        utf8: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
          },
          // Convert a byte array to a string
          bytesToString: function(bytes2) {
            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes2)));
          }
        },
        // Binary encoding
        bin: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            for (var bytes2 = [], i = 0; i < str.length; i++)
              bytes2.push(str.charCodeAt(i) & 255);
            return bytes2;
          },
          // Convert a byte array to a string
          bytesToString: function(bytes2) {
            for (var str = [], i = 0; i < bytes2.length; i++)
              str.push(String.fromCharCode(bytes2[i]));
            return str.join("");
          }
        }
      };
      module.exports = charenc;
    }
  });

  // ../../node_modules/sha1/sha1.js
  var require_sha1 = __commonJS({
    "../../node_modules/sha1/sha1.js"(exports, module) {
      (function() {
        var crypt = require_crypt(), utf8 = require_charenc().utf8, bin = require_charenc().bin, sha1 = function(message) {
          if (message.constructor == String)
            message = utf8.stringToBytes(message);
          else if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(message))
            message = Array.prototype.slice.call(message, 0);
          else if (!Array.isArray(message))
            message = message.toString();
          var m = crypt.bytesToWords(message), l = message.length * 8, w = [], H0 = 1732584193, H1 = -271733879, H2 = -1732584194, H3 = 271733878, H4 = -1009589776;
          m[l >> 5] |= 128 << 24 - l % 32;
          m[(l + 64 >>> 9 << 4) + 15] = l;
          for (var i = 0; i < m.length; i += 16) {
            var a = H0, b = H1, c = H2, d = H3, e = H4;
            for (var j = 0; j < 80; j++) {
              if (j < 16)
                w[j] = m[i + j];
              else {
                var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
                w[j] = n << 1 | n >>> 31;
              }
              var t = (H0 << 5 | H0 >>> 27) + H4 + (w[j] >>> 0) + (j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 : j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 : j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 : (H1 ^ H2 ^ H3) - 899497514);
              H4 = H3;
              H3 = H2;
              H2 = H1 << 30 | H1 >>> 2;
              H1 = H0;
              H0 = t;
            }
            H0 += a;
            H1 += b;
            H2 += c;
            H3 += d;
            H4 += e;
          }
          return [H0, H1, H2, H3, H4];
        }, api = function(message, options) {
          var digestbytes = crypt.wordsToBytes(sha1(message));
          return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
        };
        api._blocksize = 16;
        api._digestsize = 20;
        module.exports = api;
      })();
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/constants.js
  var require_constants4 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DEFAULT_FUNCTION_CALL_GAS = void 0;
      exports.DEFAULT_FUNCTION_CALL_GAS = BigInt("30000000000000");
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/logger/console.logger.js
  var require_console_logger2 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/logger/console.logger.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConsoleLogger = void 0;
      var ConsoleLogger3 = class {
        constructor(logLevels) {
          this.logLevels = logLevels;
          this.isLevelEnabled = (level) => {
            return this.logLevels.includes(level);
          };
        }
        print(level, message, ...optionalParams) {
          switch (level) {
            case "error":
            case "fatal":
              return console.error(message, ...optionalParams);
            case "warn":
              return console.warn(message, ...optionalParams);
            case "log":
              return console.log(message, ...optionalParams);
            case "debug":
            case "verbose":
              return console.debug(message, ...optionalParams);
          }
        }
        verbose(message, ...optionalParams) {
          if (!this.isLevelEnabled("verbose"))
            return;
          this.print("verbose", message, ...optionalParams);
        }
        debug(message, ...optionalParams) {
          if (!this.isLevelEnabled("debug"))
            return;
          this.print("debug", message, ...optionalParams);
        }
        log(message, ...optionalParams) {
          if (!this.isLevelEnabled("log"))
            return;
          this.print("log", message, ...optionalParams);
        }
        warn(message, ...optionalParams) {
          if (!this.isLevelEnabled("warn"))
            return;
          this.print("warn", message, ...optionalParams);
        }
        error(message, ...optionalParams) {
          if (!this.isLevelEnabled("error"))
            return;
          this.print("error", message, ...optionalParams);
        }
        fatal(message, ...optionalParams) {
          if (!this.isLevelEnabled("fatal"))
            return;
          this.print("fatal", message, ...optionalParams);
        }
      };
      exports.ConsoleLogger = ConsoleLogger3;
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/logger/logger.js
  var require_logger3 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/logger/logger.js"(exports) {
      "use strict";
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var console_logger_1 = require_console_logger2();
      var DEFAULT_LOG_LEVELS3 = [
        "verbose",
        "debug",
        "log",
        "warn",
        "error",
        "fatal"
      ];
      var DEFAULT_LOGGER3 = typeof process === "object" && process.env.NEAR_NO_LOGS ? void 0 : new console_logger_1.ConsoleLogger(DEFAULT_LOG_LEVELS3);
      var Logger3 = class {
        static error(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.error(message, ...optionalParams);
        }
        /**
         * Write a 'log' level log.
         */
        static log(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.log(message, ...optionalParams);
        }
        /**
         * Write a 'warn' level log.
         */
        static warn(message, ...optionalParams) {
          var _b;
          (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.warn(message, ...optionalParams);
        }
        /**
         * Write a 'debug' level log.
         */
        static debug(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        /**
         * Write a 'verbose' level log.
         */
        static verbose(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.verbose) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
        static fatal(message, ...optionalParams) {
          var _b, _c;
          (_c = (_b = this.instanceRef) === null || _b === void 0 ? void 0 : _b.fatal) === null || _c === void 0 ? void 0 : _c.call(_b, message, ...optionalParams);
        }
      };
      exports.Logger = Logger3;
      _a = Logger3;
      Logger3.instanceRef = DEFAULT_LOGGER3;
      Logger3.overrideLogger = (logger) => {
        _a.instanceRef = logger;
      };
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/logger/index.js
  var require_logger4 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/logger/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var logger_1 = require_logger3();
      Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/errors/errors.js
  var require_errors5 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/errors/errors.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.logWarning = void 0;
      var logger_1 = require_logger4();
      function logWarning(...args) {
        const [message, ...optionalParams] = args;
        logger_1.Logger.warn(message, ...optionalParams);
      }
      exports.logWarning = logWarning;
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/assignable.js
  var require_assignable2 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/assignable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Assignable = void 0;
      var Assignable2 = class {
        constructor(properties) {
          Object.keys(properties).map((key) => {
            this[key] = properties[key];
          });
        }
      };
      exports.Assignable = Assignable2;
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/errors.js
  var require_errors6 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/errors.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorContext = exports.TypedError = exports.ArgumentTypeError = exports.PositionalArgsError = void 0;
      var PositionalArgsError2 = class extends Error {
        constructor() {
          super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
        }
      };
      exports.PositionalArgsError = PositionalArgsError2;
      var ArgumentTypeError2 = class extends Error {
        constructor(argName, argType, argValue) {
          super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
        }
      };
      exports.ArgumentTypeError = ArgumentTypeError2;
      var TypedError3 = class extends Error {
        constructor(message, type, context) {
          super(message);
          this.type = type || "UntypedError";
          this.context = context;
        }
      };
      exports.TypedError = TypedError3;
      var ErrorContext2 = class {
        constructor(transactionHash) {
          this.transactionHash = transactionHash;
        }
      };
      exports.ErrorContext = ErrorContext2;
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/provider/light_client.js
  var require_light_client2 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/provider/light_client.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IdType = void 0;
      var IdType3;
      (function(IdType4) {
        IdType4["Transaction"] = "transaction";
        IdType4["Receipt"] = "receipt";
      })(IdType3 = exports.IdType || (exports.IdType = {}));
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/provider/response.js
  var require_response2 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/provider/response.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FinalExecutionStatusBasic = exports.ExecutionStatusBasic = void 0;
      var ExecutionStatusBasic3;
      (function(ExecutionStatusBasic4) {
        ExecutionStatusBasic4["Unknown"] = "Unknown";
        ExecutionStatusBasic4["Pending"] = "Pending";
        ExecutionStatusBasic4["Failure"] = "Failure";
      })(ExecutionStatusBasic3 = exports.ExecutionStatusBasic || (exports.ExecutionStatusBasic = {}));
      var FinalExecutionStatusBasic3;
      (function(FinalExecutionStatusBasic4) {
        FinalExecutionStatusBasic4["NotStarted"] = "NotStarted";
        FinalExecutionStatusBasic4["Started"] = "Started";
        FinalExecutionStatusBasic4["Failure"] = "Failure";
      })(FinalExecutionStatusBasic3 = exports.FinalExecutionStatusBasic || (exports.FinalExecutionStatusBasic = {}));
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/provider/index.js
  var require_provider4 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/provider/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FinalExecutionStatusBasic = exports.ExecutionStatusBasic = exports.IdType = void 0;
      var light_client_1 = require_light_client2();
      Object.defineProperty(exports, "IdType", { enumerable: true, get: function() {
        return light_client_1.IdType;
      } });
      var response_1 = require_response2();
      Object.defineProperty(exports, "ExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.ExecutionStatusBasic;
      } });
      Object.defineProperty(exports, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
        return response_1.FinalExecutionStatusBasic;
      } });
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/index.js
  var require_lib3 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/types/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_assignable2(), exports);
      __exportStar(require_errors6(), exports);
      __exportStar(require_provider4(), exports);
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/format.js
  var require_format2 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/format.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.baseDecode = exports.baseEncode = exports.parseNearAmount = exports.formatNearAmount = exports.NEAR_NOMINATION = exports.NEAR_NOMINATION_EXP = void 0;
      var bs58_1 = __importDefault(require_bs58());
      exports.NEAR_NOMINATION_EXP = 24;
      exports.NEAR_NOMINATION = BigInt(10) ** BigInt(exports.NEAR_NOMINATION_EXP);
      var ROUNDING_OFFSETS3 = [];
      var BN103 = BigInt(10);
      for (let i = 0, offset = BigInt(5); i < exports.NEAR_NOMINATION_EXP; i++, offset = offset * BN103) {
        ROUNDING_OFFSETS3[i] = offset;
      }
      function formatNearAmount3(balance, fracDigits = exports.NEAR_NOMINATION_EXP) {
        let balanceBN = BigInt(balance);
        if (fracDigits !== exports.NEAR_NOMINATION_EXP) {
          const roundingExp = exports.NEAR_NOMINATION_EXP - fracDigits - 1;
          if (roundingExp > 0) {
            balanceBN += ROUNDING_OFFSETS3[roundingExp];
          }
        }
        balance = balanceBN.toString();
        const wholeStr = balance.substring(0, balance.length - exports.NEAR_NOMINATION_EXP) || "0";
        const fractionStr = balance.substring(balance.length - exports.NEAR_NOMINATION_EXP).padStart(exports.NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
        return trimTrailingZeroes2(`${formatWithCommas2(wholeStr)}.${fractionStr}`);
      }
      exports.formatNearAmount = formatNearAmount3;
      function parseNearAmount2(amt) {
        if (!amt) {
          return null;
        }
        amt = cleanupAmount2(amt);
        const split3 = amt.split(".");
        const wholePart = split3[0];
        const fracPart = split3[1] || "";
        if (split3.length > 2 || fracPart.length > exports.NEAR_NOMINATION_EXP) {
          throw new Error(`Cannot parse '${amt}' as NEAR amount`);
        }
        return trimLeadingZeroes2(wholePart + fracPart.padEnd(exports.NEAR_NOMINATION_EXP, "0"));
      }
      exports.parseNearAmount = parseNearAmount2;
      function cleanupAmount2(amount) {
        return amount.replace(/,/g, "").trim();
      }
      function trimTrailingZeroes2(value) {
        return value.replace(/\.?0*$/, "");
      }
      function trimLeadingZeroes2(value) {
        value = value.replace(/^0+/, "");
        if (value === "") {
          return "0";
        }
        return value;
      }
      function formatWithCommas2(value) {
        const pattern = /(-?\d+)(\d{3})/;
        while (pattern.test(value)) {
          value = value.replace(pattern, "$1,$2");
        }
        return value;
      }
      function baseEncode3(value) {
        if (typeof value === "string") {
          const bytes2 = [];
          for (let c = 0; c < value.length; c++) {
            bytes2.push(value.charCodeAt(c));
          }
          value = new Uint8Array(bytes2);
        }
        return bs58_1.default.encode(value);
      }
      exports.baseEncode = baseEncode3;
      function baseDecode3(value) {
        return new Uint8Array(bs58_1.default.decode(value));
      }
      exports.baseDecode = baseDecode3;
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/errors/error_messages.json
  var require_error_messages2 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/errors/error_messages.json"(exports, module) {
      module.exports = {
        GasLimitExceeded: "Exceeded the maximum amount of gas allowed to burn per contract",
        MethodEmptyName: "Method name is empty",
        WasmerCompileError: "Wasmer compilation error: {{msg}}",
        GuestPanic: "Smart contract panicked: {{panic_msg}}",
        Memory: "Error creating Wasm memory",
        GasExceeded: "Exceeded the prepaid gas",
        MethodUTF8Error: "Method name is not valid UTF8 string",
        BadUTF16: "String encoding is bad UTF-16 sequence",
        WasmTrap: "WebAssembly trap: {{msg}}",
        GasInstrumentation: "Gas instrumentation failed or contract has denied instructions.",
        InvalidPromiseIndex: "{{promise_idx}} does not correspond to existing promises",
        InvalidPromiseResultIndex: "Accessed invalid promise result index: {{result_idx}}",
        Deserialization: "Error happened while deserializing the module",
        MethodNotFound: "Contract method is not found",
        InvalidRegisterId: "Accessed invalid register id: {{register_id}}",
        InvalidReceiptIndex: "VM Logic returned an invalid receipt index: {{receipt_index}}",
        EmptyMethodName: "Method name is empty in contract call",
        CannotReturnJointPromise: "Returning joint promise is currently prohibited",
        StackHeightInstrumentation: "Stack instrumentation failed",
        CodeDoesNotExist: "Cannot find contract code for account {{account_id}}",
        MethodInvalidSignature: "Invalid method signature",
        IntegerOverflow: "Integer overflow happened during contract execution",
        MemoryAccessViolation: "MemoryAccessViolation",
        InvalidIteratorIndex: "Iterator index {{iterator_index}} does not exist",
        IteratorWasInvalidated: "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
        InvalidAccountId: "VM Logic returned an invalid account id",
        Serialization: "Error happened while serializing the module",
        CannotAppendActionToJointPromise: "Actions can only be appended to non-joint promise.",
        InternalMemoryDeclared: "Internal memory declaration has been found in the module",
        Instantiate: "Error happened during instantiation",
        ProhibitedInView: "{{method_name}} is not allowed in view calls",
        InvalidMethodName: "VM Logic returned an invalid method name",
        BadUTF8: "String encoding is bad UTF-8 sequence",
        BalanceExceeded: "Exceeded the account balance",
        LinkError: "Wasm contract link error: {{msg}}",
        InvalidPublicKey: "VM Logic provided an invalid public key",
        ActorNoPermission: "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
        LackBalanceForState: "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
        ReceiverMismatch: "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
        CostOverflow: "Transaction gas or balance cost is too high",
        InvalidSignature: "Transaction is not signed with the given public key",
        AccessKeyNotFound: `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
        NotEnoughBalance: "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
        NotEnoughAllowance: "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
        Expired: "Transaction has expired",
        DeleteAccountStaking: "Account {{account_id}} is staking and can not be deleted",
        SignerDoesNotExist: "Signer {{signer_id}} does not exist",
        TriesToStake: "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
        AddKeyAlreadyExists: "The public key {{public_key}} is already used for an existing access key",
        InvalidSigner: "Invalid signer account ID {{signer_id}} according to requirements",
        CreateAccountNotAllowed: "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
        RequiresFullAccess: "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
        TriesToUnstake: "Account {{account_id}} is not yet staked, but tried to unstake",
        InvalidNonce: "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
        AccountAlreadyExists: "Can't create a new account {{account_id}}, because it already exists",
        InvalidChain: "Transaction parent block hash doesn't belong to the current chain",
        AccountDoesNotExist: "Can't complete the action because account {{account_id}} doesn't exist",
        AccessKeyDoesNotExist: "Can't complete the action because access key {{public_key}} doesn't exist",
        MethodNameMismatch: "Transaction method name {{method_name}} isn't allowed by the access key",
        DeleteAccountHasRent: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
        DeleteAccountHasEnoughBalance: "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
        InvalidReceiver: "Invalid receiver account ID {{receiver_id}} according to requirements",
        DeleteKeyDoesNotExist: "Account {{account_id}} tries to remove an access key that doesn't exist",
        Timeout: "Timeout exceeded",
        Closed: "Connection closed"
      };
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json
  var require_rpc_error_schema2 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/errors/rpc_error_schema.json"(exports, module) {
      module.exports = {
        schema: {
          AccessKeyNotFound: {
            name: "AccessKeyNotFound",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AccountAlreadyExists: {
            name: "AccountAlreadyExists",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          AccountDoesNotExist: {
            name: "AccountDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          ActionError: {
            name: "ActionError",
            subtypes: [
              "AccountAlreadyExists",
              "AccountDoesNotExist",
              "CreateAccountOnlyByRegistrar",
              "CreateAccountNotAllowed",
              "ActorNoPermission",
              "DeleteKeyDoesNotExist",
              "AddKeyAlreadyExists",
              "DeleteAccountStaking",
              "LackBalanceForState",
              "TriesToUnstake",
              "TriesToStake",
              "InsufficientStake",
              "FunctionCallError",
              "NewReceiptValidationError",
              "OnlyImplicitAccountCreationAllowed",
              "DeleteAccountWithLargeState",
              "DelegateActionInvalidSignature",
              "DelegateActionSenderDoesNotMatchTxReceiver",
              "DelegateActionExpired",
              "DelegateActionAccessKeyError",
              "DelegateActionInvalidNonce",
              "DelegateActionNonceTooLarge"
            ],
            props: {
              index: ""
            }
          },
          ActionsValidationError: {
            name: "ActionsValidationError",
            subtypes: [
              "DeleteActionMustBeFinal",
              "TotalPrepaidGasExceeded",
              "TotalNumberOfActionsExceeded",
              "AddKeyMethodNamesNumberOfBytesExceeded",
              "AddKeyMethodNameLengthExceeded",
              "IntegerOverflow",
              "InvalidAccountId",
              "ContractSizeExceeded",
              "FunctionCallMethodNameLengthExceeded",
              "FunctionCallArgumentsLengthExceeded",
              "UnsuitableStakingKey",
              "FunctionCallZeroAttachedGas",
              "DelegateActionMustBeOnlyOne",
              "UnsupportedProtocolFeature"
            ],
            props: {}
          },
          ActorNoPermission: {
            name: "ActorNoPermission",
            subtypes: [],
            props: {
              account_id: "",
              actor_id: ""
            }
          },
          AddKeyAlreadyExists: {
            name: "AddKeyAlreadyExists",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          AddKeyMethodNameLengthExceeded: {
            name: "AddKeyMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          AddKeyMethodNamesNumberOfBytesExceeded: {
            name: "AddKeyMethodNamesNumberOfBytesExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_bytes: ""
            }
          },
          AltBn128InvalidInput: {
            name: "AltBn128InvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          BadUTF16: {
            name: "BadUTF16",
            subtypes: [],
            props: {}
          },
          BadUTF8: {
            name: "BadUTF8",
            subtypes: [],
            props: {}
          },
          BalanceExceeded: {
            name: "BalanceExceeded",
            subtypes: [],
            props: {}
          },
          BalanceMismatchError: {
            name: "BalanceMismatchError",
            subtypes: [],
            props: {
              final_accounts_balance: "",
              final_postponed_receipts_balance: "",
              incoming_receipts_balance: "",
              incoming_validator_rewards: "",
              initial_accounts_balance: "",
              initial_postponed_receipts_balance: "",
              new_delayed_receipts_balance: "",
              other_burnt_amount: "",
              outgoing_receipts_balance: "",
              processed_delayed_receipts_balance: "",
              slashed_burnt_amount: "",
              tx_burnt_amount: ""
            }
          },
          CallIndirectOOB: {
            name: "CallIndirectOOB",
            subtypes: [],
            props: {}
          },
          CannotAppendActionToJointPromise: {
            name: "CannotAppendActionToJointPromise",
            subtypes: [],
            props: {}
          },
          CannotReturnJointPromise: {
            name: "CannotReturnJointPromise",
            subtypes: [],
            props: {}
          },
          CodeDoesNotExist: {
            name: "CodeDoesNotExist",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          CompilationError: {
            name: "CompilationError",
            subtypes: [
              "CodeDoesNotExist",
              "PrepareError",
              "WasmerCompileError"
            ],
            props: {}
          },
          ContractSizeExceeded: {
            name: "ContractSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          CostOverflow: {
            name: "CostOverflow",
            subtypes: [],
            props: {}
          },
          CreateAccountNotAllowed: {
            name: "CreateAccountNotAllowed",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: ""
            }
          },
          CreateAccountOnlyByRegistrar: {
            name: "CreateAccountOnlyByRegistrar",
            subtypes: [],
            props: {
              account_id: "",
              predecessor_id: "",
              registrar_account_id: ""
            }
          },
          DelegateActionExpired: {
            name: "DelegateActionExpired",
            subtypes: [],
            props: {}
          },
          DelegateActionInvalidNonce: {
            name: "DelegateActionInvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              delegate_nonce: ""
            }
          },
          DelegateActionInvalidSignature: {
            name: "DelegateActionInvalidSignature",
            subtypes: [],
            props: {}
          },
          DelegateActionMustBeOnlyOne: {
            name: "DelegateActionMustBeOnlyOne",
            subtypes: [],
            props: {}
          },
          DelegateActionNonceTooLarge: {
            name: "DelegateActionNonceTooLarge",
            subtypes: [],
            props: {
              delegate_nonce: "",
              upper_bound: ""
            }
          },
          DelegateActionSenderDoesNotMatchTxReceiver: {
            name: "DelegateActionSenderDoesNotMatchTxReceiver",
            subtypes: [],
            props: {
              receiver_id: "",
              sender_id: ""
            }
          },
          DeleteAccountStaking: {
            name: "DeleteAccountStaking",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteAccountWithLargeState: {
            name: "DeleteAccountWithLargeState",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          DeleteActionMustBeFinal: {
            name: "DeleteActionMustBeFinal",
            subtypes: [],
            props: {}
          },
          DeleteKeyDoesNotExist: {
            name: "DeleteKeyDoesNotExist",
            subtypes: [],
            props: {
              account_id: "",
              public_key: ""
            }
          },
          DepositWithFunctionCall: {
            name: "DepositWithFunctionCall",
            subtypes: [],
            props: {}
          },
          Deprecated: {
            name: "Deprecated",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          Deserialization: {
            name: "Deserialization",
            subtypes: [],
            props: {}
          },
          ECRecoverError: {
            name: "ECRecoverError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Ed25519VerifyInvalidInput: {
            name: "Ed25519VerifyInvalidInput",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          EmptyMethodName: {
            name: "EmptyMethodName",
            subtypes: [],
            props: {}
          },
          Expired: {
            name: "Expired",
            subtypes: [],
            props: {}
          },
          FunctionCallArgumentsLengthExceeded: {
            name: "FunctionCallArgumentsLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallMethodNameLengthExceeded: {
            name: "FunctionCallMethodNameLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          FunctionCallZeroAttachedGas: {
            name: "FunctionCallZeroAttachedGas",
            subtypes: [],
            props: {}
          },
          GasExceeded: {
            name: "GasExceeded",
            subtypes: [],
            props: {}
          },
          GasInstrumentation: {
            name: "GasInstrumentation",
            subtypes: [],
            props: {}
          },
          GasLimitExceeded: {
            name: "GasLimitExceeded",
            subtypes: [],
            props: {}
          },
          GenericTrap: {
            name: "GenericTrap",
            subtypes: [],
            props: {}
          },
          GuestPanic: {
            name: "GuestPanic",
            subtypes: [],
            props: {
              panic_msg: ""
            }
          },
          HostError: {
            name: "HostError",
            subtypes: [
              "BadUTF16",
              "BadUTF8",
              "GasExceeded",
              "GasLimitExceeded",
              "BalanceExceeded",
              "EmptyMethodName",
              "GuestPanic",
              "IntegerOverflow",
              "InvalidPromiseIndex",
              "CannotAppendActionToJointPromise",
              "CannotReturnJointPromise",
              "InvalidPromiseResultIndex",
              "InvalidRegisterId",
              "IteratorWasInvalidated",
              "MemoryAccessViolation",
              "InvalidReceiptIndex",
              "InvalidIteratorIndex",
              "InvalidAccountId",
              "InvalidMethodName",
              "InvalidPublicKey",
              "ProhibitedInView",
              "NumberOfLogsExceeded",
              "KeyLengthExceeded",
              "ValueLengthExceeded",
              "TotalLogLengthExceeded",
              "NumberPromisesExceeded",
              "NumberInputDataDependenciesExceeded",
              "ReturnedValueLengthExceeded",
              "ContractSizeExceeded",
              "Deprecated",
              "ECRecoverError",
              "AltBn128InvalidInput",
              "Ed25519VerifyInvalidInput"
            ],
            props: {}
          },
          IllegalArithmetic: {
            name: "IllegalArithmetic",
            subtypes: [],
            props: {}
          },
          IncorrectCallIndirectSignature: {
            name: "IncorrectCallIndirectSignature",
            subtypes: [],
            props: {}
          },
          IndirectCallToNull: {
            name: "IndirectCallToNull",
            subtypes: [],
            props: {}
          },
          Instantiate: {
            name: "Instantiate",
            subtypes: [],
            props: {}
          },
          InsufficientStake: {
            name: "InsufficientStake",
            subtypes: [],
            props: {
              account_id: "",
              minimum_stake: "",
              stake: ""
            }
          },
          IntegerOverflow: {
            name: "IntegerOverflow",
            subtypes: [],
            props: {}
          },
          InternalMemoryDeclared: {
            name: "InternalMemoryDeclared",
            subtypes: [],
            props: {}
          },
          InvalidAccessKeyError: {
            name: "InvalidAccessKeyError",
            subtypes: [
              "AccessKeyNotFound",
              "ReceiverMismatch",
              "MethodNameMismatch",
              "RequiresFullAccess",
              "NotEnoughAllowance",
              "DepositWithFunctionCall"
            ],
            props: {}
          },
          InvalidAccountId: {
            name: "InvalidAccountId",
            subtypes: [],
            props: {}
          },
          InvalidChain: {
            name: "InvalidChain",
            subtypes: [],
            props: {}
          },
          InvalidDataReceiverId: {
            name: "InvalidDataReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidIteratorIndex: {
            name: "InvalidIteratorIndex",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          InvalidMethodName: {
            name: "InvalidMethodName",
            subtypes: [],
            props: {}
          },
          InvalidNonce: {
            name: "InvalidNonce",
            subtypes: [],
            props: {
              ak_nonce: "",
              tx_nonce: ""
            }
          },
          InvalidPredecessorId: {
            name: "InvalidPredecessorId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidPromiseIndex: {
            name: "InvalidPromiseIndex",
            subtypes: [],
            props: {
              promise_idx: ""
            }
          },
          InvalidPromiseResultIndex: {
            name: "InvalidPromiseResultIndex",
            subtypes: [],
            props: {
              result_idx: ""
            }
          },
          InvalidPublicKey: {
            name: "InvalidPublicKey",
            subtypes: [],
            props: {}
          },
          InvalidReceiptIndex: {
            name: "InvalidReceiptIndex",
            subtypes: [],
            props: {
              receipt_index: ""
            }
          },
          InvalidReceiverId: {
            name: "InvalidReceiverId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidRegisterId: {
            name: "InvalidRegisterId",
            subtypes: [],
            props: {
              register_id: ""
            }
          },
          InvalidSignature: {
            name: "InvalidSignature",
            subtypes: [],
            props: {}
          },
          InvalidSignerId: {
            name: "InvalidSignerId",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          InvalidTxError: {
            name: "InvalidTxError",
            subtypes: [
              "InvalidAccessKeyError",
              "InvalidSignerId",
              "SignerDoesNotExist",
              "InvalidNonce",
              "NonceTooLarge",
              "InvalidReceiverId",
              "InvalidSignature",
              "NotEnoughBalance",
              "LackBalanceForState",
              "CostOverflow",
              "InvalidChain",
              "Expired",
              "ActionsValidation",
              "TransactionSizeExceeded"
            ],
            props: {}
          },
          IteratorWasInvalidated: {
            name: "IteratorWasInvalidated",
            subtypes: [],
            props: {
              iterator_index: ""
            }
          },
          KeyLengthExceeded: {
            name: "KeyLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          LackBalanceForState: {
            name: "LackBalanceForState",
            subtypes: [],
            props: {
              account_id: "",
              amount: ""
            }
          },
          Memory: {
            name: "Memory",
            subtypes: [],
            props: {}
          },
          MemoryAccessViolation: {
            name: "MemoryAccessViolation",
            subtypes: [],
            props: {}
          },
          MemoryOutOfBounds: {
            name: "MemoryOutOfBounds",
            subtypes: [],
            props: {}
          },
          MethodEmptyName: {
            name: "MethodEmptyName",
            subtypes: [],
            props: {}
          },
          MethodInvalidSignature: {
            name: "MethodInvalidSignature",
            subtypes: [],
            props: {}
          },
          MethodNameMismatch: {
            name: "MethodNameMismatch",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          MethodNotFound: {
            name: "MethodNotFound",
            subtypes: [],
            props: {}
          },
          MethodResolveError: {
            name: "MethodResolveError",
            subtypes: [
              "MethodEmptyName",
              "MethodNotFound",
              "MethodInvalidSignature"
            ],
            props: {}
          },
          MisalignedAtomicAccess: {
            name: "MisalignedAtomicAccess",
            subtypes: [],
            props: {}
          },
          NonceTooLarge: {
            name: "NonceTooLarge",
            subtypes: [],
            props: {
              tx_nonce: "",
              upper_bound: ""
            }
          },
          NotEnoughAllowance: {
            name: "NotEnoughAllowance",
            subtypes: [],
            props: {
              account_id: "",
              allowance: "",
              cost: "",
              public_key: ""
            }
          },
          NotEnoughBalance: {
            name: "NotEnoughBalance",
            subtypes: [],
            props: {
              balance: "",
              cost: "",
              signer_id: ""
            }
          },
          NumberInputDataDependenciesExceeded: {
            name: "NumberInputDataDependenciesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_input_data_dependencies: ""
            }
          },
          NumberOfLogsExceeded: {
            name: "NumberOfLogsExceeded",
            subtypes: [],
            props: {
              limit: ""
            }
          },
          NumberPromisesExceeded: {
            name: "NumberPromisesExceeded",
            subtypes: [],
            props: {
              limit: "",
              number_of_promises: ""
            }
          },
          OnlyImplicitAccountCreationAllowed: {
            name: "OnlyImplicitAccountCreationAllowed",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          PrepareError: {
            name: "PrepareError",
            subtypes: [
              "Serialization",
              "Deserialization",
              "InternalMemoryDeclared",
              "GasInstrumentation",
              "StackHeightInstrumentation",
              "Instantiate",
              "Memory",
              "TooManyFunctions",
              "TooManyLocals"
            ],
            props: {}
          },
          ProhibitedInView: {
            name: "ProhibitedInView",
            subtypes: [],
            props: {
              method_name: ""
            }
          },
          ReceiptValidationError: {
            name: "ReceiptValidationError",
            subtypes: [
              "InvalidPredecessorId",
              "InvalidReceiverId",
              "InvalidSignerId",
              "InvalidDataReceiverId",
              "ReturnedValueLengthExceeded",
              "NumberInputDataDependenciesExceeded",
              "ActionsValidation"
            ],
            props: {}
          },
          ReceiverMismatch: {
            name: "ReceiverMismatch",
            subtypes: [],
            props: {
              ak_receiver: "",
              tx_receiver: ""
            }
          },
          RequiresFullAccess: {
            name: "RequiresFullAccess",
            subtypes: [],
            props: {}
          },
          ReturnedValueLengthExceeded: {
            name: "ReturnedValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          Serialization: {
            name: "Serialization",
            subtypes: [],
            props: {}
          },
          SignerDoesNotExist: {
            name: "SignerDoesNotExist",
            subtypes: [],
            props: {
              signer_id: ""
            }
          },
          StackHeightInstrumentation: {
            name: "StackHeightInstrumentation",
            subtypes: [],
            props: {}
          },
          StackOverflow: {
            name: "StackOverflow",
            subtypes: [],
            props: {}
          },
          TooManyFunctions: {
            name: "TooManyFunctions",
            subtypes: [],
            props: {}
          },
          TooManyLocals: {
            name: "TooManyLocals",
            subtypes: [],
            props: {}
          },
          TotalLogLengthExceeded: {
            name: "TotalLogLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          TotalNumberOfActionsExceeded: {
            name: "TotalNumberOfActionsExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_number_of_actions: ""
            }
          },
          TotalPrepaidGasExceeded: {
            name: "TotalPrepaidGasExceeded",
            subtypes: [],
            props: {
              limit: "",
              total_prepaid_gas: ""
            }
          },
          TransactionSizeExceeded: {
            name: "TransactionSizeExceeded",
            subtypes: [],
            props: {
              limit: "",
              size: ""
            }
          },
          TriesToStake: {
            name: "TriesToStake",
            subtypes: [],
            props: {
              account_id: "",
              balance: "",
              locked: "",
              stake: ""
            }
          },
          TriesToUnstake: {
            name: "TriesToUnstake",
            subtypes: [],
            props: {
              account_id: ""
            }
          },
          TxExecutionError: {
            name: "TxExecutionError",
            subtypes: [
              "ActionError",
              "InvalidTxError"
            ],
            props: {}
          },
          Unreachable: {
            name: "Unreachable",
            subtypes: [],
            props: {}
          },
          UnsuitableStakingKey: {
            name: "UnsuitableStakingKey",
            subtypes: [],
            props: {
              public_key: ""
            }
          },
          UnsupportedProtocolFeature: {
            name: "UnsupportedProtocolFeature",
            subtypes: [],
            props: {
              protocol_feature: "",
              version: ""
            }
          },
          ValueLengthExceeded: {
            name: "ValueLengthExceeded",
            subtypes: [],
            props: {
              length: "",
              limit: ""
            }
          },
          WasmTrap: {
            name: "WasmTrap",
            subtypes: [
              "Unreachable",
              "IncorrectCallIndirectSignature",
              "MemoryOutOfBounds",
              "CallIndirectOOB",
              "IllegalArithmetic",
              "MisalignedAtomicAccess",
              "IndirectCallToNull",
              "StackOverflow",
              "GenericTrap"
            ],
            props: {}
          },
          WasmerCompileError: {
            name: "WasmerCompileError",
            subtypes: [],
            props: {
              msg: ""
            }
          },
          Closed: {
            name: "Closed",
            subtypes: [],
            props: {}
          },
          ServerError: {
            name: "ServerError",
            subtypes: [
              "TxExecutionError",
              "Timeout",
              "Closed"
            ],
            props: {}
          },
          Timeout: {
            name: "Timeout",
            subtypes: [],
            props: {}
          }
        }
      };
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/errors/rpc_errors.js
  var require_rpc_errors2 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/errors/rpc_errors.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getErrorTypeFromErrorMessage = exports.formatError = exports.parseResultError = exports.parseRpcError = exports.ServerError = void 0;
      var types_1 = require_lib3();
      var mustache_1 = __importDefault(require_mustache());
      var format_1 = require_format2();
      var error_messages_json_1 = __importDefault(require_error_messages2());
      var rpc_error_schema_json_1 = __importDefault(require_rpc_error_schema2());
      var mustacheHelpers2 = {
        formatNear: () => (n, render3) => (0, format_1.formatNearAmount)(render3(n))
      };
      var ServerError3 = class extends types_1.TypedError {
      };
      exports.ServerError = ServerError3;
      var ServerTransactionError2 = class extends ServerError3 {
      };
      function parseRpcError3(errorObj) {
        const result = {};
        const errorClassName = walkSubtype2(errorObj, rpc_error_schema_json_1.default.schema, result, "");
        const error = new ServerError3(formatError3(errorClassName, result), errorClassName);
        Object.assign(error, result);
        return error;
      }
      exports.parseRpcError = parseRpcError3;
      function parseResultError3(result) {
        const server_error = parseRpcError3(result.status.Failure);
        const server_tx_error = new ServerTransactionError2();
        Object.assign(server_tx_error, server_error);
        server_tx_error.type = server_error.type;
        server_tx_error.message = server_error.message;
        server_tx_error.transaction_outcome = result.transaction_outcome;
        return server_tx_error;
      }
      exports.parseResultError = parseResultError3;
      function formatError3(errorClassName, errorData) {
        if (typeof error_messages_json_1.default[errorClassName] === "string") {
          return mustache_1.default.render(error_messages_json_1.default[errorClassName], Object.assign(Object.assign({}, errorData), mustacheHelpers2));
        }
        return JSON.stringify(errorData);
      }
      exports.formatError = formatError3;
      function walkSubtype2(errorObj, schema, result, typeName) {
        let error;
        let type;
        let errorTypeName;
        for (const errorName in schema) {
          if (isString2(errorObj[errorName])) {
            return errorObj[errorName];
          }
          if (isObject2(errorObj[errorName])) {
            error = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else if (isObject2(errorObj.kind) && isObject2(errorObj.kind[errorName])) {
            error = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
          } else {
            continue;
          }
        }
        if (error && type) {
          for (const prop of Object.keys(type.props)) {
            result[prop] = error[prop];
          }
          return walkSubtype2(error, schema, result, errorTypeName);
        } else {
          result.kind = errorObj;
          return typeName;
        }
      }
      function getErrorTypeFromErrorMessage3(errorMessage, errorType) {
        switch (true) {
          case /^account .*? does not exist while viewing$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^Account .*? doesn't exist$/.test(errorMessage):
            return "AccountDoesNotExist";
          case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return "AccessKeyDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return "CodeDoesNotExist";
          case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
            return "MethodNotFound";
          case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return "InvalidNonce";
          default:
            return errorType;
        }
      }
      exports.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage3;
      function isObject2(n) {
        return Object.prototype.toString.call(n) === "[object Object]";
      }
      function isString2(n) {
        return Object.prototype.toString.call(n) === "[object String]";
      }
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/errors/index.js
  var require_errors7 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/errors/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseRpcError = exports.parseResultError = exports.getErrorTypeFromErrorMessage = exports.formatError = exports.ServerError = exports.logWarning = void 0;
      var errors_1 = require_errors5();
      Object.defineProperty(exports, "logWarning", { enumerable: true, get: function() {
        return errors_1.logWarning;
      } });
      var rpc_errors_1 = require_rpc_errors2();
      Object.defineProperty(exports, "ServerError", { enumerable: true, get: function() {
        return rpc_errors_1.ServerError;
      } });
      Object.defineProperty(exports, "formatError", { enumerable: true, get: function() {
        return rpc_errors_1.formatError;
      } });
      Object.defineProperty(exports, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
        return rpc_errors_1.getErrorTypeFromErrorMessage;
      } });
      Object.defineProperty(exports, "parseResultError", { enumerable: true, get: function() {
        return rpc_errors_1.parseResultError;
      } });
      Object.defineProperty(exports, "parseRpcError", { enumerable: true, get: function() {
        return rpc_errors_1.parseRpcError;
      } });
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/logging.js
  var require_logging2 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/logging.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.printTxOutcomeLogs = exports.printTxOutcomeLogsAndFailures = void 0;
      var errors_1 = require_errors7();
      var logger_1 = require_logger4();
      function printTxOutcomeLogsAndFailures2({ contractId, outcome }) {
        const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
          const isFailure = typeof it.outcome.status === "object" && typeof it.outcome.status.Failure === "object";
          if (it.outcome.logs.length || isFailure) {
            return acc.concat({
              receiptIds: it.outcome.receipt_ids,
              logs: it.outcome.logs,
              failure: typeof it.outcome.status === "object" && it.outcome.status.Failure !== void 0 ? (0, errors_1.parseRpcError)(it.outcome.status.Failure) : null
            });
          } else {
            return acc;
          }
        }, []);
        for (const result of flatLogs) {
          logger_1.Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
          printTxOutcomeLogs2({
            contractId,
            logs: result.logs,
            prefix: "	"
          });
          if (result.failure) {
            logger_1.Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
          }
        }
      }
      exports.printTxOutcomeLogsAndFailures = printTxOutcomeLogsAndFailures2;
      function printTxOutcomeLogs2({ contractId, logs, prefix = "" }) {
        for (const log of logs) {
          logger_1.Logger.log(`${prefix}Log [${contractId}]: ${log}`);
        }
      }
      exports.printTxOutcomeLogs = printTxOutcomeLogs2;
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/provider.js
  var require_provider5 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/provider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTransactionLastResult = void 0;
      function getTransactionLastResult2(txResult) {
        if (typeof txResult.status === "object" && typeof txResult.status.SuccessValue === "string") {
          const value = Buffer.from(txResult.status.SuccessValue, "base64").toString();
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return null;
      }
      exports.getTransactionLastResult = getTransactionLastResult2;
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/utils.js
  var require_utils13 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sortBigIntAsc = void 0;
      function sortBigIntAsc3(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      exports.sortBigIntAsc = sortBigIntAsc3;
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/validators.js
  var require_validators2 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/validators.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.diffEpochValidators = exports.findSeatPrice = void 0;
      var depd_1 = __importDefault(require_browser());
      var utils_1 = require_utils13();
      function findSeatPrice2(validators, maxNumberOfSeats, minimumStakeRatio, protocolVersion) {
        if (protocolVersion && protocolVersion < 49) {
          return findSeatPriceForProtocolBefore49(validators, maxNumberOfSeats);
        }
        if (!minimumStakeRatio) {
          const deprecate = (0, depd_1.default)("findSeatPrice(validators, maxNumberOfSeats)");
          deprecate("`use `findSeatPrice(validators, maxNumberOfSeats, minimumStakeRatio)` instead");
          minimumStakeRatio = [1, 6250];
        }
        return findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio);
      }
      exports.findSeatPrice = findSeatPrice2;
      function findSeatPriceForProtocolBefore49(validators, numSeats) {
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const num = BigInt(numSeats);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (stakesSum < num) {
          throw new Error("Stakes are below seats");
        }
        let left = BigInt(1), right = stakesSum + BigInt(1);
        while (left !== right - BigInt(1)) {
          const mid = (left + right) / BigInt(2);
          let found = false;
          let currentSum = BigInt(0);
          for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum + stakes[i] / mid;
            if (currentSum >= num) {
              left = mid;
              found = true;
              break;
            }
          }
          if (!found) {
            right = mid;
          }
        }
        return left;
      }
      function findSeatPriceForProtocolAfter49(validators, maxNumberOfSeats, minimumStakeRatio) {
        if (minimumStakeRatio.length != 2) {
          throw Error("minimumStakeRatio should have 2 elements");
        }
        const stakes = validators.map((v) => BigInt(v.stake)).sort(utils_1.sortBigIntAsc);
        const stakesSum = stakes.reduce((a, b) => a + b);
        if (validators.length < maxNumberOfSeats) {
          return stakesSum * BigInt(minimumStakeRatio[0]) / BigInt(minimumStakeRatio[1]);
        } else {
          return stakes[0] + BigInt(1);
        }
      }
      function diffEpochValidators2(currentValidators, nextValidators) {
        const validatorsMap = /* @__PURE__ */ new Map();
        currentValidators.forEach((v) => validatorsMap.set(v.account_id, v));
        const nextValidatorsSet = new Set(nextValidators.map((v) => v.account_id));
        return {
          newValidators: nextValidators.filter((v) => !validatorsMap.has(v.account_id)),
          removedValidators: currentValidators.filter((v) => !nextValidatorsSet.has(v.account_id)),
          changedValidators: nextValidators.filter((v) => validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake).map((v) => ({ current: validatorsMap.get(v.account_id), next: v }))
        };
      }
      exports.diffEpochValidators = diffEpochValidators2;
    }
  });

  // ../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/index.js
  var require_lib4 = __commonJS({
    "../../node_modules/@here-wallet/core/node_modules/@near-js/utils/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_constants4(), exports);
      __exportStar(require_errors7(), exports);
      __exportStar(require_format2(), exports);
      __exportStar(require_logging2(), exports);
      __exportStar(require_provider5(), exports);
      __exportStar(require_validators2(), exports);
      __exportStar(require_logger4(), exports);
      __exportStar(require_utils13(), exports);
    }
  });

  // ../../node_modules/@here-wallet/core/build/helpers/proxyMethods.js
  var require_proxyMethods = __commonJS({
    "../../node_modules/@here-wallet/core/build/helpers/proxyMethods.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createRequest = exports.computeRequestId = exports.deleteRequest = exports.getResponse = exports.getRequest = exports.proxyApi = void 0;
      var sha1_1 = __importDefault(require_sha1());
      var uuid4_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
      var utils_1 = require_lib4();
      var utils_2 = require_utils12();
      exports.proxyApi = "https://h4n.app";
      var getRequest = (id, signal) => __awaiter(void 0, void 0, void 0, function* () {
        const res = yield fetch(`${exports.proxyApi}/${id}/request`, {
          signal,
          headers: { "content-type": "application/json" },
          method: "GET"
        });
        if (res.ok === false) {
          throw Error(yield res.text());
        }
        const { data } = yield res.json();
        return JSON.parse(Buffer.from((0, utils_1.baseDecode)(data)).toString("utf8"));
      });
      exports.getRequest = getRequest;
      var getResponse = (id) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const res = yield fetch(`${exports.proxyApi}/${id}/response`, {
          headers: { "content-type": "application/json" },
          method: "GET"
        });
        if (res.ok === false) {
          throw Error(yield res.text());
        }
        const { data } = yield res.json();
        const result = (_a = JSON.parse(data)) !== null && _a !== void 0 ? _a : {};
        return Object.assign({ type: "here", public_key: "", account_id: "", payload: "", status: -1, path: "" }, result);
      });
      exports.getResponse = getResponse;
      var deleteRequest = (id) => __awaiter(void 0, void 0, void 0, function* () {
        const res = yield fetch(`${exports.proxyApi}/${id}`, {
          headers: { "content-type": "application/json" },
          method: "DELETE"
        });
        if (res.ok === false) {
          throw Error(yield res.text());
        }
      });
      exports.deleteRequest = deleteRequest;
      var computeRequestId = (request) => __awaiter(void 0, void 0, void 0, function* () {
        const query = (0, utils_1.baseEncode)(JSON.stringify(Object.assign(Object.assign({}, request), { _id: (0, uuid4_1.default)() })));
        const hashsum = (0, sha1_1.default)(query);
        const id = Buffer.from(hashsum, "hex").toString("base64");
        const requestId = id.replaceAll("/", "_").replaceAll("-", "+").slice(0, 13);
        return { requestId, query };
      });
      exports.computeRequestId = computeRequestId;
      var createRequest = (request, signal) => __awaiter(void 0, void 0, void 0, function* () {
        const { query, requestId } = yield (0, exports.computeRequestId)(request);
        const res = yield fetch(`${exports.proxyApi}/${requestId}/request`, {
          method: "POST",
          body: JSON.stringify({ topic_id: (0, utils_2.getDeviceId)(), data: query }),
          headers: { "content-type": "application/json" },
          signal
        });
        if (res.ok === false) {
          throw Error(yield res.text());
        }
        return requestId;
      });
      exports.createRequest = createRequest;
    }
  });

  // ../../node_modules/@here-wallet/core/build/strategies/HereStrategy.js
  var require_HereStrategy = __commonJS({
    "../../node_modules/@here-wallet/core/build/strategies/HereStrategy.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HereStrategy = exports.getRequest = exports.proxyApi = exports.deleteRequest = exports.getResponse = exports.createRequest = void 0;
      var types_1 = require_types3();
      var proxyMethods_1 = require_proxyMethods();
      Object.defineProperty(exports, "createRequest", { enumerable: true, get: function() {
        return proxyMethods_1.createRequest;
      } });
      Object.defineProperty(exports, "getResponse", { enumerable: true, get: function() {
        return proxyMethods_1.getResponse;
      } });
      Object.defineProperty(exports, "deleteRequest", { enumerable: true, get: function() {
        return proxyMethods_1.deleteRequest;
      } });
      Object.defineProperty(exports, "proxyApi", { enumerable: true, get: function() {
        return proxyMethods_1.proxyApi;
      } });
      Object.defineProperty(exports, "getRequest", { enumerable: true, get: function() {
        return proxyMethods_1.getRequest;
      } });
      var HereStrategy = class {
        connect(wallet) {
          return __awaiter(this, void 0, void 0, function* () {
            this.wallet = wallet;
          });
        }
        onInitialized() {
          return __awaiter(this, void 0, void 0, function* () {
          });
        }
        onRequested(id, request, reject) {
          return __awaiter(this, void 0, void 0, function* () {
          });
        }
        onApproving(result) {
          return __awaiter(this, void 0, void 0, function* () {
          });
        }
        onSuccess(result) {
          return __awaiter(this, void 0, void 0, function* () {
          });
        }
        onFailed(result) {
          return __awaiter(this, void 0, void 0, function* () {
          });
        }
        request(conf) {
          return __awaiter(this, void 0, void 0, function* () {
            let { request, disableCleanupRequest, id, signal } = conf, delegate = __rest(conf, ["request", "disableCleanupRequest", "id", "signal"]);
            if (id != null)
              request = yield (0, proxyMethods_1.getRequest)(id, signal);
            else
              id = yield (0, proxyMethods_1.createRequest)(request, signal);
            return new Promise((resolve, reject) => {
              let fallbackHttpTimer = null;
              const clear = () => __awaiter(this, void 0, void 0, function* () {
                fallbackHttpTimer = -1;
                clearInterval(fallbackHttpTimer);
                if (disableCleanupRequest !== true) {
                  yield (0, proxyMethods_1.deleteRequest)(id);
                }
              });
              const processApprove = (data) => {
                switch (data.status) {
                  case types_1.HereProviderStatus.APPROVING:
                    this.onApproving(data);
                    return;
                  case types_1.HereProviderStatus.FAILED:
                    clear();
                    reject(new types_1.HereProviderError(data.payload));
                    this.onFailed(data);
                    return;
                  case types_1.HereProviderStatus.SUCCESS:
                    clear();
                    resolve(data);
                    this.onSuccess(data);
                    return;
                }
              };
              const rejectAction = (payload) => {
                var _a;
                processApprove({
                  type: ((_a = request.selector) === null || _a === void 0 ? void 0 : _a.type) || "web",
                  status: types_1.HereProviderStatus.FAILED,
                  payload
                });
              };
              this.onRequested(id, request, rejectAction);
              signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", () => rejectAction());
              const setupTimer = () => {
                if (fallbackHttpTimer === -1) {
                  return;
                }
                fallbackHttpTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                  var _a;
                  try {
                    const data = yield (0, proxyMethods_1.getResponse)(id);
                    if (fallbackHttpTimer === -1)
                      return;
                    processApprove(data);
                    setupTimer();
                  } catch (e) {
                    const status = types_1.HereProviderStatus.FAILED;
                    const error = e instanceof Error ? e : void 0;
                    const payload = error === null || error === void 0 ? void 0 : error.message;
                    clear();
                    reject(new types_1.HereProviderError(payload, error));
                    this.onFailed({ type: ((_a = request.selector) === null || _a === void 0 ? void 0 : _a.type) || "web", status, payload });
                  }
                }), 3e3);
              };
              setupTimer();
            });
          });
        }
      };
      exports.HereStrategy = HereStrategy;
    }
  });

  // ../../node_modules/@here-wallet/core/build/strategies/WidgetStrategy.js
  var require_WidgetStrategy = __commonJS({
    "../../node_modules/@here-wallet/core/build/strategies/WidgetStrategy.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WidgetStrategy = exports.defaultUrl = void 0;
      var HereStrategy_1 = require_HereStrategy();
      var createIframe = (widget) => {
        const connector = document.createElement("iframe");
        connector.src = widget;
        connector.allow = "usb";
        connector.style.border = "none";
        connector.style.zIndex = "10000";
        connector.style.position = "fixed";
        connector.style.display = "none";
        connector.style.top = "0";
        connector.style.left = "0";
        connector.style.width = "100%";
        connector.style.height = "100%";
        document.body.appendChild(connector);
        return connector;
      };
      exports.defaultUrl = "https://my.herewallet.app/connector/index.html";
      var WidgetStrategy = class _WidgetStrategy extends HereStrategy_1.HereStrategy {
        constructor(options = { widget: exports.defaultUrl, lazy: false }) {
          super();
          this.options = {
            lazy: typeof options === "object" ? options.lazy || false : false,
            widget: typeof options === "string" ? options : options.widget || exports.defaultUrl
          };
          if (!this.options.lazy) {
            this.initIframe();
          }
        }
        initIframe() {
          if (_WidgetStrategy.connector == null) {
            _WidgetStrategy.connector = createIframe(this.options.widget);
            _WidgetStrategy.connector.addEventListener("load", () => {
              _WidgetStrategy.isLoaded = true;
            });
          }
          return _WidgetStrategy.connector;
        }
        onRequested(id, request, reject) {
          return __awaiter(this, void 0, void 0, function* () {
            const iframe = this.initIframe();
            iframe.style.display = "block";
            const loadHandler = () => {
              var _a, _b, _c;
              (_a = _WidgetStrategy.connector) === null || _a === void 0 ? void 0 : _a.removeEventListener("load", loadHandler);
              (_c = (_b = _WidgetStrategy.connector) === null || _b === void 0 ? void 0 : _b.contentWindow) === null || _c === void 0 ? void 0 : _c.postMessage(JSON.stringify({ type: "request", payload: { id, request } }), new URL(this.options.widget).origin);
            };
            if (_WidgetStrategy.isLoaded)
              loadHandler();
            else
              iframe.addEventListener("load", loadHandler);
            this.messageHandler = (event) => {
              try {
                if (event.origin !== new URL(this.options.widget).origin)
                  return;
                if (JSON.parse(event.data).type === "reject")
                  reject();
              } catch (_a) {
              }
            };
            window === null || window === void 0 ? void 0 : window.addEventListener("message", this.messageHandler);
          });
        }
        postMessage(data) {
          var _a;
          const iframe = this.initIframe();
          const args = JSON.stringify(data);
          const origin = new URL(this.options.widget).origin;
          (_a = iframe.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(args, origin);
        }
        onApproving() {
          return __awaiter(this, void 0, void 0, function* () {
            this.postMessage({ type: "approving" });
          });
        }
        onSuccess(request) {
          return __awaiter(this, void 0, void 0, function* () {
            console.log(request);
            this.postMessage({ type: "result", payload: { request } });
            this.close();
          });
        }
        onFailed(request) {
          return __awaiter(this, void 0, void 0, function* () {
            this.postMessage({ type: "result", payload: { request } });
            this.close();
          });
        }
        close() {
          if (this.messageHandler) {
            window === null || window === void 0 ? void 0 : window.removeEventListener("message", this.messageHandler);
            this.messageHandler = void 0;
          }
          if (_WidgetStrategy.connector) {
            _WidgetStrategy.connector.style.display = "none";
          }
        }
      };
      exports.WidgetStrategy = WidgetStrategy;
      WidgetStrategy.isLoaded = false;
    }
  });

  // ../../node_modules/@here-wallet/core/build/strategies/TelegramAppStrategy.js
  var require_TelegramAppStrategy = __commonJS({
    "../../node_modules/@here-wallet/core/build/strategies/TelegramAppStrategy.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TelegramAppStrategy = void 0;
      var crypto_1 = require_commonjs3();
      var utils_1 = require_lib4();
      var types_1 = require_types3();
      var proxyMethods_1 = require_proxyMethods();
      var HereStrategy_1 = require_HereStrategy();
      var utils_2 = require_utils12();
      var TelegramAppStrategy = class extends HereStrategy_1.HereStrategy {
        constructor(appId = "herewalletbot/app", walletId = "herewalletbot/app") {
          super();
          this.appId = appId;
          this.walletId = walletId;
        }
        connect(wallet) {
          var _a, _b, _c, _d, _e, _f;
          return __awaiter(this, void 0, void 0, function* () {
            if (typeof window === "undefined")
              return;
            this.wallet = wallet;
            const startapp = ((_c = (_b = (_a = window === null || window === void 0 ? void 0 : window.Telegram) === null || _a === void 0 ? void 0 : _a.WebApp) === null || _b === void 0 ? void 0 : _b.initDataUnsafe) === null || _c === void 0 ? void 0 : _c.start_param) || "";
            (_f = (_d = window === null || window === void 0 ? void 0 : window.Telegram) === null || _d === void 0 ? void 0 : (_e = _d.WebApp).ready) === null || _f === void 0 ? void 0 : _f.call(_e);
            if (startapp.startsWith("hot")) {
              let requestId = startapp.split("-").pop() || "";
              requestId = Buffer.from((0, utils_1.baseDecode)(requestId)).toString("utf8");
              const requestPending = localStorage.getItem(`__telegramPendings:${requestId}`);
              if (requestPending == null)
                return;
              const data = yield (0, HereStrategy_1.getResponse)(requestId);
              if (data.status !== types_1.HereProviderStatus.SUCCESS) {
                localStorage.removeItem(`__telegramPendings:${requestId}`);
                return;
              }
              if (data.type === "sign") {
                yield this.wallet.authStorage.setKey("mainnet", data.account_id, crypto_1.KeyPairEd25519.fromRandom());
                yield this.wallet.authStorage.setActiveAccount("mainnet", data.account_id);
              }
              try {
                const pending = JSON.parse(requestPending);
                if (pending.privateKey) {
                  yield this.wallet.authStorage.setKey("mainnet", data.account_id, crypto_1.KeyPair.fromString(pending.privateKey));
                  yield this.wallet.authStorage.setActiveAccount("mainnet", data.account_id);
                }
                const url = new URL(location.origin + (pending.callbackUrl || ""));
                url.searchParams.set("payload", data.result);
                localStorage.removeItem(`__telegramPendings:${requestId}`);
                location.assign(url.toString());
              } catch (e) {
                const url = new URL(location.href);
                url.searchParams.set("payload", data.result);
                localStorage.removeItem(`__telegramPendings:${requestId}`);
                location.assign(url.toString());
              }
            }
          });
        }
        request(conf) {
          var _a;
          return __awaiter(this, void 0, void 0, function* () {
            if (typeof window === "undefined")
              return;
            conf.request.telegramApp = this.appId;
            conf.request.callbackUrl = "";
            const { requestId, query } = yield (0, proxyMethods_1.computeRequestId)(conf.request);
            const res = yield fetch(`${proxyMethods_1.proxyApi}/${requestId}/request`, {
              method: "POST",
              body: JSON.stringify({ topic_id: (0, utils_2.getDeviceId)(), data: query }),
              headers: { "content-type": "application/json" },
              signal: conf.signal
            });
            if (res.ok === false) {
              throw Error(yield res.text());
            }
            localStorage.setItem(`__telegramPendings:${requestId}`, JSON.stringify({ callbackUrl: conf.callbackUrl, privateKey: (_a = conf.accessKey) === null || _a === void 0 ? void 0 : _a.toString() }));
            this.onRequested(requestId);
          });
        }
        onRequested(id) {
          var _a, _b, _c, _d;
          return __awaiter(this, void 0, void 0, function* () {
            if (typeof window === "undefined")
              return;
            id = (0, utils_1.baseEncode)(id);
            (_b = (_a = window === null || window === void 0 ? void 0 : window.Telegram) === null || _a === void 0 ? void 0 : _a.WebApp) === null || _b === void 0 ? void 0 : _b.openTelegramLink(`https://t.me/${this.walletId}?startapp=h4n-${id}`);
            (_d = (_c = window === null || window === void 0 ? void 0 : window.Telegram) === null || _c === void 0 ? void 0 : _c.WebApp) === null || _d === void 0 ? void 0 : _d.close();
          });
        }
      };
      exports.TelegramAppStrategy = TelegramAppStrategy;
    }
  });

  // ../../node_modules/@here-wallet/core/build/helpers/waitInjected.js
  var require_waitInjected = __commonJS({
    "../../node_modules/@here-wallet/core/build/helpers/waitInjected.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.waitInjectedHereWallet = void 0;
      exports.waitInjectedHereWallet = new Promise((resolve) => {
        if (typeof window === "undefined")
          return resolve(null);
        if ((window === null || window === void 0 ? void 0 : window.self) === (window === null || window === void 0 ? void 0 : window.top))
          return resolve(null);
        const handler = (e) => {
          if (e.data.type !== "here-wallet-injected")
            return;
          window === null || window === void 0 ? void 0 : window.parent.postMessage("here-sdk-init", "*");
          window === null || window === void 0 ? void 0 : window.removeEventListener("message", handler);
          resolve({
            ethAddress: e.data.ethAddress,
            accountId: e.data.accountId,
            publicKey: e.data.publicKey,
            telegramId: e.data.telegramId,
            network: e.data.network || "mainnet"
          });
        };
        window === null || window === void 0 ? void 0 : window.addEventListener("message", handler);
        setTimeout(() => resolve(null), 2e3);
      });
    }
  });

  // ../../node_modules/@here-wallet/core/build/strategies/InjectedStrategy.js
  var require_InjectedStrategy = __commonJS({
    "../../node_modules/@here-wallet/core/build/strategies/InjectedStrategy.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InjectedStrategy = void 0;
      var uuid4_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
      var crypto_1 = require_commonjs3();
      var types_1 = require_types3();
      var waitInjected_1 = require_waitInjected();
      var HereStrategy_1 = require_HereStrategy();
      var InjectedStrategy = class extends HereStrategy_1.HereStrategy {
        connect(wallet) {
          return __awaiter(this, void 0, void 0, function* () {
            if (typeof window === "undefined")
              return Promise.resolve();
            this.wallet = wallet;
            const injected = yield waitInjected_1.waitInjectedHereWallet;
            if (injected == null)
              return;
            yield this.wallet.authStorage.setKey(injected.network, injected.accountId, crypto_1.KeyPairEd25519.fromRandom());
            yield this.wallet.authStorage.setActiveAccount(injected.network, injected.accountId);
          });
        }
        request(conf) {
          return __awaiter(this, void 0, void 0, function* () {
            if (typeof window === "undefined")
              return Promise.reject("SSR");
            return new Promise((resolve) => {
              const id = (0, uuid4_1.default)();
              const handler = (e) => {
                if (e.data.id !== id)
                  return;
                if (e.data.status === types_1.HereProviderStatus.SUCCESS || e.data.status === types_1.HereProviderStatus.FAILED) {
                  window === null || window === void 0 ? void 0 : window.removeEventListener("message", handler);
                  return resolve(e.data);
                }
              };
              window === null || window === void 0 ? void 0 : window.parent.postMessage(Object.assign(Object.assign({ $here: true }, conf.request), { id }), "*");
              window === null || window === void 0 ? void 0 : window.addEventListener("message", handler);
            });
          });
        }
      };
      exports.InjectedStrategy = InjectedStrategy;
    }
  });

  // ../../node_modules/@here-wallet/core/build/telegramEthereumProvider.js
  var require_telegramEthereumProvider = __commonJS({
    "../../node_modules/@here-wallet/core/build/telegramEthereumProvider.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hereWalletProvider = void 0;
      var uuid4_1 = __importDefault((init_browser(), __toCommonJS(browser_exports)));
      var waitInjected_1 = require_waitInjected();
      var promises = {};
      var request = (type, args) => {
        return new Promise((resolve, reject) => {
          const id = (0, uuid4_1.default)();
          window === null || window === void 0 ? void 0 : window.parent.postMessage({ type, id, args }, "*");
          promises[id] = { resolve, reject };
        });
      };
      var hereWalletProvider = {
        on() {
        },
        isHereWallet: true,
        isConnected: () => true,
        request: (data) => request("ethereum", data)
      };
      exports.hereWalletProvider = hereWalletProvider;
      function announceProvider() {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof window === "undefined")
            return;
          const injected = yield waitInjected_1.waitInjectedHereWallet;
          if (injected == null)
            return;
          window === null || window === void 0 ? void 0 : window.dispatchEvent(new CustomEvent("eip6963:announceProvider", {
            detail: Object.freeze({
              provider: hereWalletProvider,
              info: {
                uuid: (0, uuid4_1.default)(),
                name: "HERE Wallet",
                icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTUwIiBoZWlnaHQ9IjU1MCIgdmlld0JveD0iMCAwIDU1MCA1NTAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1NTAiIGhlaWdodD0iNTUwIiByeD0iMTIwIiBmaWxsPSIjRjNFQkVBIj48L3JlY3Q+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjcyLjA0NiAxODMuNTM4TDI5My43ODggMTQzTDMyMi4yODggMjM4LjVMMjc5LjU1OCAyMTkuMTgyTDI3Mi4wNDYgMTgzLjUzOFpNMTE4LjI4OCAyMjZMOTYuMTg0IDI2NS44NTdMMTYzLjc2OSAyOTguOTJMMjU2Ljc4OCAyOTIuNUwxMTguMjg4IDIyNlpNMTA1Ljk2OSAzMDEuMTU4TDg0IDM0MC44MDNMMjE4LjkzNyA0MDcuNzkxTDQ0My44MDcgMzk0LjE0MUw0NjUuNzc2IDM1NC40OTZMMjQwLjkwNiAzNjguMTQ3TDEwNS45NjkgMzAxLjE1OFoiIGZpbGw9IiMyQzMwMzQiPjwvcGF0aD4KPHBhdGggZD0iTTQ2NS43ODggMzU0LjVMMjQwLjk4MiAzNjguMTUzTDEwNC44ODcgMzAxLjAwNUwyNTIuMjU5IDI5Mi4wODhMMTE4LjI4OCAyMjZMMTg0LjA3NiAxNzAuMjgyTDMyMC41NDcgMjM3LjM5N0wyOTMuNzg5IDE0My4wMDFMNDI0LjE5NSAyMDYuOTQ5TDQ2NS43ODggMzU0LjVaIiBmaWxsPSIjRkRCRjFDIj48L3BhdGg+Cjwvc3ZnPg==",
                rdns: "app.herewallet.my"
              }
            })
          }));
        });
      }
      if (typeof window !== "undefined") {
        window === null || window === void 0 ? void 0 : window.addEventListener("message", (e) => {
          var _a, _b;
          if (e.data.type !== "ethereum")
            return;
          if (e.data.isSuccess)
            return (_a = promises[e.data.id]) === null || _a === void 0 ? void 0 : _a.resolve(e.data.result);
          (_b = promises[e.data.id]) === null || _b === void 0 ? void 0 : _b.reject(e.data.result);
        });
        window === null || window === void 0 ? void 0 : window.addEventListener("eip6963:requestProvider", () => announceProvider());
        announceProvider();
      }
    }
  });

  // ../../node_modules/@here-wallet/core/build/wallet.js
  var require_wallet = __commonJS({
    "../../node_modules/@here-wallet/core/build/wallet.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      var __importDefault = exports && exports.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HereWallet = void 0;
      var accounts_1 = require_commonjs8();
      var signers_1 = require_commonjs7();
      var providers_1 = require_commonjs5();
      var crypto_1 = require_commonjs3();
      var crypto_2 = __require("crypto");
      var js_sha256_1 = require_sha2564();
      var bn_js_1 = __importDefault(require_bn());
      var actions_1 = require_actions2();
      var nep0314_1 = require_nep0314();
      var utils_1 = require_utils12();
      var HereKeyStore_1 = require_HereKeyStore();
      var WidgetStrategy_1 = require_WidgetStrategy();
      var types_1 = require_types3();
      var TelegramAppStrategy_1 = require_TelegramAppStrategy();
      var InjectedStrategy_1 = require_InjectedStrategy();
      var waitInjected_1 = require_waitInjected();
      var telegramEthereumProvider_1 = require_telegramEthereumProvider();
      var AccessDenied = class extends Error {
      };
      var HereWallet2 = class _HereWallet {
        constructor({ injected, nodeUrl, networkId = "mainnet", authStorage, defaultStrategy } = {}) {
          this.authStorage = authStorage;
          this.strategy = defaultStrategy;
          Object.defineProperty(this, "ethAddress", { get: () => injected === null || injected === void 0 ? void 0 : injected.ethAddress });
          Object.defineProperty(this, "telegramId", { get: () => injected === null || injected === void 0 ? void 0 : injected.telegramId });
          Object.defineProperty(this, "ethProvider", { get: () => (injected === null || injected === void 0 ? void 0 : injected.ethAddress) ? telegramEthereumProvider_1.hereWalletProvider : null });
          const signer = new signers_1.InMemorySigner(this.authStorage);
          const rpc = new providers_1.JsonRpcProvider({ url: nodeUrl !== null && nodeUrl !== void 0 ? nodeUrl : `https://rpc.${networkId}.near.org` });
          this.connection = accounts_1.Connection.fromConfig({
            jsvmAccountId: `jsvm.${networkId}`,
            provider: rpc,
            networkId,
            signer
          });
        }
        static connect(options = {}) {
          var _a;
          return __awaiter(this, void 0, void 0, function* () {
            if (options.authStorage == null)
              options.authStorage = new HereKeyStore_1.HereKeyStore();
            if (options.defaultStrategy) {
              const wallet2 = new _HereWallet(options);
              yield wallet2.strategy.connect(wallet2);
              return wallet2;
            }
            if (typeof window !== "undefined") {
              if (window !== parent) {
                const injected = yield waitInjected_1.waitInjectedHereWallet;
                if (injected != null) {
                  options.defaultStrategy = new InjectedStrategy_1.InjectedStrategy();
                  const wallet2 = new _HereWallet(Object.assign(Object.assign({}, options), { injected }));
                  yield wallet2.strategy.connect(wallet2);
                  return wallet2;
                }
              }
              if (((_a = window.Telegram) === null || _a === void 0 ? void 0 : _a.WebApp) != null) {
                options.defaultStrategy = new TelegramAppStrategy_1.TelegramAppStrategy(options.botId, options.walletId);
                const wallet2 = new _HereWallet(options);
                yield wallet2.strategy.connect(wallet2);
                return wallet2;
              }
            }
            options.defaultStrategy = new WidgetStrategy_1.WidgetStrategy();
            const wallet = new _HereWallet(options);
            yield wallet.strategy.connect(wallet);
            return wallet;
          });
        }
        get rpc() {
          return this.connection.provider;
        }
        get signer() {
          return this.connection.signer;
        }
        get networkId() {
          return this.connection.networkId;
        }
        account(id) {
          return __awaiter(this, void 0, void 0, function* () {
            const accountId = id !== null && id !== void 0 ? id : yield this.authStorage.getActiveAccount(this.networkId);
            if (accountId == null)
              throw new AccessDenied("Wallet not signed in");
            return new accounts_1.Account(this.connection, accountId);
          });
        }
        isSignedIn() {
          return __awaiter(this, void 0, void 0, function* () {
            const id = yield this.authStorage.getActiveAccount(this.networkId);
            return id != null;
          });
        }
        signOut() {
          return __awaiter(this, void 0, void 0, function* () {
            const accountId = yield this.authStorage.getActiveAccount(this.networkId);
            if (accountId == null)
              throw new Error("Wallet not signed in");
            const key = yield this.authStorage.getKey(this.networkId, accountId);
            if (key != null) {
              const publicKey = key.getPublicKey().toString();
              yield this.silentSignAndSendTransaction({
                receiverId: accountId,
                actions: [{ type: "DeleteKey", params: { publicKey } }]
              }).catch(() => {
              });
            }
            yield this.authStorage.removeKey(this.networkId, accountId);
          });
        }
        getHereBalance(id) {
          return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.account(id);
            const contractId = this.networkId === "mainnet" ? "here.storage.near" : "here.storage.testnet";
            const hereCoins = yield account.viewFunction({ args: { account_id: account.accountId }, methodName: "ft_balance_of", contractId }).catch(() => "0");
            return new bn_js_1.default(hereCoins);
          });
        }
        getAvailableBalance(id) {
          return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.account(id);
            const result = yield account.getAccountBalance();
            const hereBalance = yield this.getHereBalance();
            return new bn_js_1.default(result.available).add(new bn_js_1.default(hereBalance));
          });
        }
        getAccounts() {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.authStorage.getAccounts(this.networkId);
          });
        }
        getAccountId() {
          return __awaiter(this, void 0, void 0, function* () {
            const accountId = yield this.authStorage.getActiveAccount(this.networkId);
            if (accountId == null)
              throw new Error("Wallet not signed in");
            return accountId;
          });
        }
        switchAccount(id) {
          return __awaiter(this, void 0, void 0, function* () {
            const key = yield this.authStorage.getKey(this.networkId, id);
            if (key == null)
              throw new Error(`Account ${id} not signed in`);
            yield this.authStorage.setActiveAccount(this.networkId, id);
          });
        }
        signIn({ contractId, allowance, methodNames = [], strategy = this.strategy, signal, callbackUrl, selector } = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            if (contractId == null) {
              const { accountId } = yield this.authenticate({ strategy, signal, selector });
              yield this.authStorage.setKey(this.networkId, accountId, crypto_1.KeyPairEd25519.fromRandom());
              yield this.authStorage.setActiveAccount(this.networkId, accountId);
              return accountId;
            }
            yield strategy.onInitialized();
            try {
              const accessKey = crypto_1.KeyPair.fromRandom("ed25519");
              const permission = { receiverId: contractId, methodNames, allowance };
              const data = yield strategy.request({
                signal,
                accessKey,
                callbackUrl,
                request: {
                  type: "call",
                  network: this.networkId,
                  selector: selector || {},
                  transactions: [
                    {
                      actions: [
                        {
                          type: "AddKey",
                          params: {
                            publicKey: accessKey.getPublicKey().toString(),
                            accessKey: { permission }
                          }
                        }
                      ]
                    }
                  ]
                }
              });
              if (data.account_id == null) {
                throw Error("Transaction is failed");
              }
              yield this.authStorage.setKey(this.networkId, data.account_id, accessKey);
              yield this.authStorage.setActiveAccount(this.networkId, data.account_id);
              return data.account_id;
            } catch (error) {
              (0, utils_1.internalThrow)(error, strategy, selector);
              throw error;
            }
          });
        }
        silentSignAndSendTransaction({ actions, receiverId, signerId }) {
          return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.account(signerId);
            const localKey = yield this.authStorage.getKey(this.networkId, account.accountId).catch(() => null);
            if (localKey == null)
              throw new AccessDenied();
            const publicKey = localKey.getPublicKey();
            const accessKeys = yield account.getAccessKeys();
            const call = { receiverId, actions };
            const isValid = accessKeys.some((v) => {
              if (v.public_key !== publicKey.toString())
                return false;
              return (0, utils_1.isValidAccessKey)(account.accountId, v, call);
            });
            if (isValid === false)
              throw new AccessDenied();
            return yield account.signAndSendTransaction({
              actions: actions.map((a) => (0, actions_1.createAction)(a)),
              receiverId: receiverId !== null && receiverId !== void 0 ? receiverId : account.accountId
            });
          });
        }
        signAndSendTransaction(opts) {
          return __awaiter(this, void 0, void 0, function* () {
            const { signerId, receiverId, actions, callbackUrl, strategy = this.strategy, signal, selector } = opts;
            yield strategy.onInitialized();
            try {
              const result = yield this.silentSignAndSendTransaction({ receiverId, actions, signerId });
              const success = { type: "web", status: types_1.HereProviderStatus.SUCCESS, payload: result === null || result === void 0 ? void 0 : result.transaction_outcome.id };
              strategy.onSuccess(success);
              return result;
            } catch (e) {
              try {
                if (!(e instanceof AccessDenied) && (e === null || e === void 0 ? void 0 : e.type) !== "NotEnoughAllowance") {
                  (0, utils_1.internalThrow)(e, strategy, selector);
                  throw e;
                }
                const activeAccount = yield this.getAccountId().catch(() => void 0);
                const data = yield strategy.request({
                  signal,
                  callbackUrl,
                  request: {
                    type: "call",
                    network: this.networkId,
                    transactions: [{ actions: (0, utils_1.serializeActions)(actions), receiverId, signerId }],
                    selector: opts.selector || { id: signerId || activeAccount }
                  }
                });
                if (data.payload == null || data.account_id == null) {
                  throw Error("Transaction not found, but maybe executed");
                }
                return yield this.rpc.txStatus(data.payload, data.account_id, "INCLUDED");
              } catch (error) {
                (0, utils_1.internalThrow)(error, strategy, selector);
                throw error;
              }
            }
          });
        }
        verifyMessageNEP0413(request, result) {
          return __awaiter(this, void 0, void 0, function* () {
            const isSignatureValid = (0, nep0314_1.verifySignature)(request, result);
            if (!isSignatureValid)
              throw Error("Incorrect signature");
            const account = yield this.account(result.accountId);
            const keys = yield account.getAccessKeys();
            const isFullAccess = keys.some((k) => {
              if (k.public_key !== result.publicKey)
                return false;
              if (k.access_key.permission !== "FullAccess")
                return false;
              return true;
            });
            if (!isFullAccess)
              throw Error("Signer public key is not full access");
            return true;
          });
        }
        authenticate(options = {}) {
          var _a, _b, _c;
          return __awaiter(this, void 0, void 0, function* () {
            const signRequest = {
              nonce: (_a = options.nonce) !== null && _a !== void 0 ? _a : (0, crypto_2.randomBytes)(32),
              recipient: (_b = options.recipient) !== null && _b !== void 0 ? _b : window === null || window === void 0 ? void 0 : window.location.host,
              message: (_c = options.message) !== null && _c !== void 0 ? _c : "Authenticate"
            };
            const signed = yield this.signMessage(Object.assign(Object.assign({}, signRequest), options));
            yield this.verifyMessageNEP0413(signRequest, signed);
            return signed;
          });
        }
        signMessage(options) {
          return __awaiter(this, void 0, void 0, function* () {
            const { strategy = this.strategy, signal, selector, callbackUrl } = options;
            yield strategy.onInitialized();
            if ("receiver" in options)
              return yield this.legacySignMessage(options);
            const activeAccount = yield this.getAccountId().catch(() => void 0);
            const data = yield strategy.request({
              signal,
              callbackUrl,
              request: {
                type: "sign",
                message: options.message,
                recipient: options.recipient,
                nonce: Array.from(options.nonce),
                network: this.networkId,
                selector: selector || { id: activeAccount }
              }
            });
            if ((data === null || data === void 0 ? void 0 : data.payload) == null)
              throw Error("Signature not found");
            const { publicKey, signature, accountId } = JSON.parse(data.payload);
            return { publicKey, signature, accountId };
          });
        }
        legacySignMessage(_a) {
          var { receiver, message, nonce } = _a, delegate = __rest(_a, ["receiver", "message", "nonce"]);
          return __awaiter(this, void 0, void 0, function* () {
            if (nonce == null) {
              let nonceArray = new Uint8Array(32);
              nonce = [...crypto.getRandomValues(nonceArray)];
            }
            const { strategy = this.strategy, callbackUrl, selector, signal } = delegate;
            const activeAccount = yield this.getAccountId().catch(() => void 0);
            const data = yield strategy.request({
              signal,
              callbackUrl,
              request: {
                type: "sign",
                network: this.networkId,
                selector: selector || { id: activeAccount },
                message,
                receiver,
                nonce
              }
            });
            if ((data === null || data === void 0 ? void 0 : data.payload) == null) {
              throw Error("Signature not found");
            }
            try {
              const { publicKey, signature, accountId } = JSON.parse(data.payload);
              const sign = new Uint8Array(Buffer.from(signature, "base64"));
              const json = JSON.stringify({ message, receiver, nonce });
              const msg = new Uint8Array(js_sha256_1.sha256.digest(`NEP0413:` + json));
              const isVerify = crypto_1.PublicKey.from(publicKey).verify(msg, sign);
              if (isVerify === false)
                throw Error();
              const account = yield this.account(accountId);
              const keys = yield account.getAccessKeys();
              const pb = publicKey.toString();
              const isValid = keys.some((k) => {
                if (k.public_key !== pb)
                  return false;
                if (k.access_key.permission !== "FullAccess")
                  return false;
                return true;
              });
              if (isValid === false)
                throw Error();
              return {
                signature: new Uint8Array(Buffer.from(signature, "base64")),
                publicKey: crypto_1.PublicKey.from(publicKey),
                message: `NEP0413:` + json,
                receiver,
                accountId,
                nonce
              };
            } catch (_b) {
              throw Error("Signature not correct");
            }
          });
        }
        signAndSendTransactions(_a) {
          var { transactions } = _a, delegate = __rest(_a, ["transactions"]);
          return __awaiter(this, void 0, void 0, function* () {
            const { strategy = this.strategy, selector, callbackUrl, signal } = delegate;
            yield strategy.onInitialized();
            let results = [];
            try {
              for (const call of transactions) {
                const r = yield this.silentSignAndSendTransaction(call);
                results.push(r);
              }
              const payload = results.map((result) => result.transaction_outcome.id).join(",");
              const success = { type: "web", status: types_1.HereProviderStatus.SUCCESS, payload };
              strategy.onSuccess(success);
              return results;
            } catch (e) {
              try {
                if (!(e instanceof AccessDenied) && (e === null || e === void 0 ? void 0 : e.type) !== "NotEnoughAllowance") {
                  (0, utils_1.internalThrow)(e, strategy, selector);
                  throw e;
                }
                const activeAccount = yield this.getAccountId().catch(() => void 0);
                const uncompleted = transactions.slice(results.length);
                const data = yield strategy.request({
                  signal,
                  callbackUrl,
                  request: {
                    type: "call",
                    network: this.networkId,
                    selector: selector || { id: uncompleted[0].signerId || activeAccount },
                    transactions: uncompleted.map((trx) => Object.assign(Object.assign({}, trx), { actions: (0, utils_1.serializeActions)(trx.actions) }))
                  }
                });
                if (data.payload == null || data.account_id == null) {
                  throw Error("Transaction not found, but maybe executed");
                }
                const promises = data.payload.split(",").map((id) => this.rpc.txStatus(id, data.account_id, "INCLUDED"));
                return yield Promise.all(promises);
              } catch (error) {
                (0, utils_1.internalThrow)(error, strategy, selector);
                throw error;
              }
            }
          });
        }
      };
      exports.HereWallet = HereWallet2;
    }
  });

  // ../../node_modules/@here-wallet/core/build/helpers/types.js
  var require_types4 = __commonJS({
    "../../node_modules/@here-wallet/core/build/helpers/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/@here-wallet/core/build/strategies/WindowStrategy.js
  var require_WindowStrategy = __commonJS({
    "../../node_modules/@here-wallet/core/build/strategies/WindowStrategy.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WindowStrategy = void 0;
      var HereStrategy_1 = require_HereStrategy();
      var WindowStrategy = class extends HereStrategy_1.HereStrategy {
        constructor(endpoint = "https://my.herewallet.app") {
          super();
          this.endpoint = endpoint;
          this.signWindow = null;
        }
        onInitialized() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.signWindow)
              return;
            const left = window.innerWidth / 2 - 420 / 2;
            const top = window.innerHeight / 2 - 700 / 2;
            this.signWindow = window.open(`${this.endpoint}/loading`, "_blank", `popup=1,width=420,height=700,top=${top},left=${left}`);
          });
        }
        onRequested(id, request, reject) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this.signWindow == null)
              return;
            this.unloadHandler = () => {
              var _a;
              return (_a = this.signWindow) === null || _a === void 0 ? void 0 : _a.close();
            };
            window.addEventListener("beforeunload", this.unloadHandler);
            this.signWindow.location = `${this.endpoint}/request/${id}`;
            this.timerHandler = setInterval(() => {
              var _a;
              if ((_a = this.signWindow) === null || _a === void 0 ? void 0 : _a.closed)
                reject("CLOSED");
            }, 1e3);
          });
        }
        close() {
          var _a;
          clearInterval(this.timerHandler);
          (_a = this.signWindow) === null || _a === void 0 ? void 0 : _a.close();
          this.signWindow = null;
          if (this.unloadHandler) {
            window.removeEventListener("beforeunload", this.unloadHandler);
          }
        }
        onFailed() {
          return __awaiter(this, void 0, void 0, function* () {
            this.close();
          });
        }
        onSuccess() {
          return __awaiter(this, void 0, void 0, function* () {
            this.close();
          });
        }
      };
      exports.WindowStrategy = WindowStrategy;
    }
  });

  // ../../node_modules/@here-wallet/core/build/index.js
  var require_build = __commonJS({
    "../../node_modules/@here-wallet/core/build/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HereWallet = void 0;
      var wallet_1 = require_wallet();
      Object.defineProperty(exports, "HereWallet", { enumerable: true, get: function() {
        return wallet_1.HereWallet;
      } });
      __exportStar(require_waitInjected(), exports);
      __exportStar(require_proxyMethods(), exports);
      __exportStar(require_nep0314(), exports);
      __exportStar(require_actions2(), exports);
      __exportStar(require_types4(), exports);
      __exportStar(require_utils12(), exports);
      __exportStar(require_HereKeyStore(), exports);
      __exportStar(require_JSONStorage(), exports);
      __exportStar(require_HereStrategy(), exports);
      __exportStar(require_InjectedStrategy(), exports);
      __exportStar(require_TelegramAppStrategy(), exports);
      __exportStar(require_WidgetStrategy(), exports);
      __exportStar(require_WindowStrategy(), exports);
      __exportStar(require_types3(), exports);
    }
  });

  // ../../node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "../../node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray2;
      exports.fromByteArray = fromByteArray2;
      var lookup2 = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup2[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray2(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output2 = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output2.push(tripletToBase64(tmp));
        }
        return output2.join("");
      }
      function fromByteArray2(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_feature/dapp_connect/error_handling_dappConnect.js
  var require_error_handling_dappConnect = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_feature/dapp_connect/error_handling_dappConnect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getExternalActionErrorMessageForEndTag = exports.EDappActionErrorTag = void 0;
      var EDappActionErrorTag;
      (function(EDappActionErrorTag2) {
        EDappActionErrorTag2["NEW_ACTION_STARTED"] = "NEW_ACTION_STARTED";
        EDappActionErrorTag2["INCOMPLETE_ACTION"] = "INCOMPLETE_ACTION";
        EDappActionErrorTag2["NO_ACCOUNTS"] = "NO_ACCOUNTS";
        EDappActionErrorTag2["WINDOW_CLOSED"] = "WINDOW_CLOSED";
        EDappActionErrorTag2["USER_CANCELLED"] = "USER_CANCELLED";
        EDappActionErrorTag2["POPUP_WINDOW_REFUSED"] = "POPUP_WINDOW_REFUSED";
        EDappActionErrorTag2["POPUP_WINDOW_OPEN_FAILED"] = "POPUP_WINDOW_OPEN_FAILED";
      })(EDappActionErrorTag = exports.EDappActionErrorTag || (exports.EDappActionErrorTag = {}));
      var en = {
        [EDappActionErrorTag.WINDOW_CLOSED]: "User closed the window",
        [EDappActionErrorTag.INCOMPLETE_ACTION]: "User didn't complete the action",
        [EDappActionErrorTag.NEW_ACTION_STARTED]: "A new action was started by the user, old action failed",
        [EDappActionErrorTag.POPUP_WINDOW_OPEN_FAILED]: "Popup window failed to open",
        [EDappActionErrorTag.POPUP_WINDOW_REFUSED]: "User refused to allow the popup window to open",
        [EDappActionErrorTag.USER_CANCELLED]: "User cancelled the action",
        [EDappActionErrorTag.NO_ACCOUNTS]: "No Meteor account found- try again after creating one"
      };
      function getExternalActionErrorMessageForEndTag(tag) {
        return en[tag] ?? "An unknown error occurred";
      }
      exports.getExternalActionErrorMessageForEndTag = getExternalActionErrorMessageForEndTag;
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_feature/dapp_connect/types_dappConnect.js
  var require_types_dappConnect = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_feature/dapp_connect/types_dappConnect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EDappActionConnectionStatus = exports.EDappActionSource = exports.EMeteorInjectedFeature = exports.EMeteorExtensionDirectActionType = exports.EWalletExternalActionStatus = exports.EWalletExternalAction_SignIn_AccessType = exports.EMeteorWalletSignInType = exports.EExternalActionType = exports.MeteorActionError = void 0;
      var error_handling_dappConnect_1 = require_error_handling_dappConnect();
      var MeteorActionError = class extends Error {
        constructor(reason, previousError) {
          super();
          if (reason.message == null) {
            reason.message = (0, error_handling_dappConnect_1.getExternalActionErrorMessageForEndTag)(reason.endTags?.[reason.endTags.length - 1] ?? "unknown");
          }
          this._reason = reason;
          this.message = reason.message;
          this.name = "MeteorActionError";
          this.cause = previousError;
        }
      };
      exports.MeteorActionError = MeteorActionError;
      var EExternalActionType;
      (function(EExternalActionType2) {
        EExternalActionType2["login"] = "login";
        EExternalActionType2["sign"] = "sign";
        EExternalActionType2["logout"] = "logout";
        EExternalActionType2["verify_owner"] = "verify_owner";
        EExternalActionType2["keypom_claim"] = "keypom_claim";
        EExternalActionType2["sign_message"] = "sign_message";
      })(EExternalActionType = exports.EExternalActionType || (exports.EExternalActionType = {}));
      var EMeteorWalletSignInType2;
      (function(EMeteorWalletSignInType3) {
        EMeteorWalletSignInType3["ALL_METHODS"] = "ALL_METHODS";
        EMeteorWalletSignInType3["SELECTED_METHODS"] = "SELECTED_METHODS";
        EMeteorWalletSignInType3["FULL_ACCESS"] = "FULL_ACCESS";
      })(EMeteorWalletSignInType2 = exports.EMeteorWalletSignInType || (exports.EMeteorWalletSignInType = {}));
      var EWalletExternalAction_SignIn_AccessType;
      (function(EWalletExternalAction_SignIn_AccessType2) {
        EWalletExternalAction_SignIn_AccessType2["FULL_ACCESS"] = "fullAccess";
        EWalletExternalAction_SignIn_AccessType2["LIMITED_ACCESS"] = "limitedAccess";
      })(EWalletExternalAction_SignIn_AccessType = exports.EWalletExternalAction_SignIn_AccessType || (exports.EWalletExternalAction_SignIn_AccessType = {}));
      var EWalletExternalActionStatus;
      (function(EWalletExternalActionStatus2) {
        EWalletExternalActionStatus2["UNCONFIRMED"] = "UNCONFIRMED";
        EWalletExternalActionStatus2["PENDING"] = "PENDING";
        EWalletExternalActionStatus2["SUCCESS"] = "SUCCESS";
        EWalletExternalActionStatus2["FAILURE"] = "FAILURE";
      })(EWalletExternalActionStatus = exports.EWalletExternalActionStatus || (exports.EWalletExternalActionStatus = {}));
      var EMeteorExtensionDirectActionType;
      (function(EMeteorExtensionDirectActionType2) {
        EMeteorExtensionDirectActionType2["check_sync_status"] = "check_sync_status";
        EMeteorExtensionDirectActionType2["sync_accounts"] = "sync_accounts";
        EMeteorExtensionDirectActionType2["open_page"] = "open_page";
      })(EMeteorExtensionDirectActionType = exports.EMeteorExtensionDirectActionType || (exports.EMeteorExtensionDirectActionType = {}));
      var EMeteorInjectedFeature;
      (function(EMeteorInjectedFeature2) {
        EMeteorInjectedFeature2["open_page"] = "open_page";
        EMeteorInjectedFeature2["batch_import"] = "batch_import";
        EMeteorInjectedFeature2["sync_check"] = "sync_check";
        EMeteorInjectedFeature2["account_sync"] = "account_sync";
      })(EMeteorInjectedFeature = exports.EMeteorInjectedFeature || (exports.EMeteorInjectedFeature = {}));
      var EDappActionSource;
      (function(EDappActionSource2) {
        EDappActionSource2["website_callback"] = "wcb";
        EDappActionSource2["website_post_message"] = "wpm";
        EDappActionSource2["website_visit"] = "wv";
        EDappActionSource2["extension_injected"] = "ext";
      })(EDappActionSource = exports.EDappActionSource || (exports.EDappActionSource = {}));
      var EDappActionConnectionStatus;
      (function(EDappActionConnectionStatus2) {
        EDappActionConnectionStatus2["initializing"] = "initializing";
        EDappActionConnectionStatus2["connected"] = "connected";
        EDappActionConnectionStatus2["attempting_reconnect"] = "attempting_reconnect";
        EDappActionConnectionStatus2["disconnected"] = "disconnected";
        EDappActionConnectionStatus2["closed_success"] = "closed_success";
        EDappActionConnectionStatus2["closed_fail"] = "closed_fail";
        EDappActionConnectionStatus2["closed_window"] = "closed_window";
      })(EDappActionConnectionStatus = exports.EDappActionConnectionStatus || (exports.EDappActionConnectionStatus = {}));
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_utility/data_type_utils/StringUtils.js
  var require_StringUtils = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_utility/data_type_utils/StringUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StringUtils = exports.stringToConstantStyledString = exports.convertToSlug = exports.pad = exports.createPadder = exports.BetterStringArray = exports.safeAppend = exports.firstNotNullEmpty = exports.nullEmpty = exports.notNullEmpty = exports.StringRegex = void 0;
      exports.StringRegex = {
        digitsRegex: /\b\d+\b/gi
      };
      var notNullEmpty = (str) => {
        return str != null && str.length > 0;
      };
      exports.notNullEmpty = notNullEmpty;
      var nullEmpty = (str) => {
        return !(0, exports.notNullEmpty)(str);
      };
      exports.nullEmpty = nullEmpty;
      var firstNotNullEmpty = (...strItems) => {
        for (const item of strItems) {
          if ((0, exports.notNullEmpty)(item)) {
            return item;
          }
        }
        return void 0;
      };
      exports.firstNotNullEmpty = firstNotNullEmpty;
      var anyNullEmpty = (strs) => {
        for (const str of strs) {
          if ((0, exports.nullEmpty)(str)) {
            return true;
          }
        }
        return false;
      };
      var safeAppend = (str, value, ifEmptyValue = null) => {
        return (0, exports.notNullEmpty)(str) ? str + value : ifEmptyValue != null ? ifEmptyValue : value;
      };
      exports.safeAppend = safeAppend;
      var BetterStringArray = class extends Array {
        pushIfNotNullEmpty(str) {
          if ((0, exports.notNullEmpty)(str)) {
            this.push(str);
          }
        }
      };
      exports.BetterStringArray = BetterStringArray;
      function createPadder(padCharacter, desiredTotalLength, padFromRight = false) {
        return (input) => {
          return pad(input, padCharacter, desiredTotalLength, padFromRight);
        };
      }
      exports.createPadder = createPadder;
      function pad(input, padCharacter, desiredTotalLength, padFromRight = false) {
        const difference = desiredTotalLength - `${input}`.length;
        if (difference > 0) {
          const padding = new Array(difference).fill(padCharacter);
          if (padFromRight) {
            return `${input}${padding.join("")}`;
          }
          return `${padding.join("")}${input}`;
        }
        return `${input}`;
      }
      exports.pad = pad;
      var regexAllSpaces = new RegExp("\\s+", "g");
      var regexDoubleDashes = new RegExp("--+", "g");
      var regexFirstDash = new RegExp("^-+", "g");
      var regexLastDash = new RegExp("-+$", "g");
      var regexSingleDash = new RegExp("-", "g");
      var regexRemoveNonWord = new RegExp("[^\\w\\-]+", "g");
      var regexAllUnderscores = new RegExp("_", "g");
      function escapeRegExp2(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      var convertToSlug = (text, { slugDivider = "-", letterCase = "LOWER", normalize = true, excludeCharacters = [] } = {}) => {
        if (!text || text.length === 0) {
          return "";
        }
        let resp = text.toString();
        if (normalize) {
          resp = resp.normalize("NFD");
        }
        if (letterCase === "LOWER") {
          resp = resp.toLowerCase();
        } else if (letterCase === "UPPER") {
          resp = resp.toUpperCase();
        }
        return resp.replace(regexAllSpaces, "-").replace(excludeCharacters.length > 0 ? new RegExp(`[^\\w\\-${excludeCharacters.map((c) => escapeRegExp2(c)).join("")}]+`, "g") : regexRemoveNonWord, "").replace(excludeCharacters.includes("_") ? regexAllSpaces : regexAllUnderscores, "-").replace(regexDoubleDashes, "-").replace(regexFirstDash, "").replace(regexLastDash, "").replace(regexSingleDash, slugDivider);
      };
      exports.convertToSlug = convertToSlug;
      var stringToConstantStyledString = (input) => {
        return (0, exports.convertToSlug)(input, {
          normalize: true,
          slugDivider: "_",
          letterCase: "UPPER"
        });
      };
      exports.stringToConstantStyledString = stringToConstantStyledString;
      var reverse = (input) => {
        let r = ``;
        for (const char of input) {
          r = `${char}${r}`;
        }
        return r;
      };
      function isUriEncoded(uri) {
        uri = uri || "";
        return uri !== decodeURIComponent(uri);
      }
      var decodeUriFully = (uri) => {
        let failSafe = 0;
        while (isUriEncoded(uri)) {
          failSafe += 1;
          uri = decodeURIComponent(uri);
          if (failSafe > 20) {
            throw new Error(`String Utils: Decode URI Fully: Enacted while loop too many times with attempt to decode fully.`);
          }
        }
        return uri;
      };
      var removeAndTrim = (input, removeText, { spaceAware = true, insideWords = false } = {}) => {
        let text = `${input}`;
        for (const rem of removeText) {
          if (spaceAware) {
            if (!insideWords) {
              if (text.indexOf(` ${rem} `) >= 0) {
                text = text.replace(` ${rem} `, " ");
              } else {
                if (text.startsWith(`${rem} `)) {
                  text = text.substring(rem.length + 1);
                }
                if (text.endsWith(` ${rem}`)) {
                  text = text.substring(0, text.length - (rem.length + 1));
                }
              }
            } else {
              const checkNew = [
                new RegExp(`\\s${rem}\\s`, "g"),
                new RegExp(`\\s${rem}`, "g"),
                new RegExp(`${rem}\\s`, "g")
              ];
              for (const remNew of checkNew) {
                if (remNew.test(text)) {
                  console.log(`Replacing "${remNew}" in "${text}"`);
                  text = text.replace(remNew, " ");
                  console.log(`Text after: "${text}"`);
                }
              }
            }
          } else {
            if (text.indexOf(rem) >= 0) {
              text = text.replace(rem, "");
            }
          }
        }
        return text.trim();
      };
      function sortCompareStrings(a, b) {
        const aa = a.toLowerCase();
        const bb = b.toLowerCase();
        if (aa < bb)
          return -1;
        if (aa > bb)
          return 1;
        return 0;
      }
      function comparePure(a, b) {
        if (a > b) {
          return 1;
        }
        if (a < b) {
          return -1;
        }
        return 0;
      }
      function onlyNotNullEmpty(strArray) {
        let notNullEmptyArray = [];
        for (const str of strArray) {
          if ((0, exports.notNullEmpty)(str)) {
            notNullEmptyArray.push(str);
          }
        }
        return notNullEmptyArray;
      }
      var joinIntoUrl = (...routes) => {
        return routes.filter((v) => v).map((v, i, arr) => {
          const isNotFirst = i !== 0;
          const isNotLast = i !== arr.length - 1;
          if (isNotFirst) {
            v = v.startsWith("/") ? v.slice(1) : v;
          }
          if (isNotLast) {
            v = v.endsWith("/") ? v.slice(0, -1) : v;
          }
          return v;
        }).join("/");
      };
      var getUrlWithBaseUrl = (baseUrl, route) => {
        const isRouteCompleted = route.startsWith("http://") || route.startsWith("https://");
        if (isRouteCompleted) {
          return route;
        }
        return joinIntoUrl(baseUrl, route);
      };
      var isHashId = (accountId) => {
        const hash = accountId.match(/^[a-zA-Z0-9]+$/);
        return Boolean(hash);
      };
      exports.StringUtils = {
        isUriEncoded,
        decodeUriFully,
        StringRegex: exports.StringRegex,
        reverse,
        notNullEmpty: exports.notNullEmpty,
        nullEmpty: exports.nullEmpty,
        anyNullEmpty,
        safeAppend: exports.safeAppend,
        createPadder,
        pad,
        convertToSlug: exports.convertToSlug,
        stringToConstantStyledString: exports.stringToConstantStyledString,
        removeAndTrim,
        sortCompareStrings,
        comparePure,
        onlyNotNullEmpty,
        firstNotNullEmpty: exports.firstNotNullEmpty,
        joinIntoUrl,
        getUrlWithBaseUrl,
        isHashId
      };
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_utility/state_utils/EnvironmentStorageUtils.js
  var require_EnvironmentStorageUtils = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_utility/state_utils/EnvironmentStorageUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EnvironmentStateAdapter_Sync = exports.EnvironmentStateAdapter = void 0;
      var EnvironmentStateAdapter = class {
        constructor(implementation) {
          this.implementation = implementation;
        }
        async setJson(key, value) {
          await this.implementation.setString(key, JSON.stringify(value));
        }
        async getJson(key) {
          const val = await this.implementation.getString(key);
          if (val == null || val === "undefined" || val === "null") {
            return void 0;
          }
          return JSON.parse(val);
        }
        async setString(key, value) {
          await this.implementation.setString(key, value);
        }
        async getString(key) {
          const val = await this.implementation.getString(key);
          if (val == null) {
            return void 0;
          }
          return val;
        }
        createJsonGetterSetter(key) {
          return {
            get: () => this.getJson(key),
            set: (value) => this.setJson(key, value)
          };
        }
        createStringGetterSetter(key) {
          return {
            get: () => this.getString(key),
            set: (value) => this.setString(key, value)
          };
        }
      };
      exports.EnvironmentStateAdapter = EnvironmentStateAdapter;
      var EnvironmentStateAdapter_Sync = class {
        constructor(implementation) {
          this.implementation = implementation;
        }
        setJson(key, value) {
          this.implementation.setString(key, JSON.stringify(value));
        }
        getJson(key) {
          const val = this.implementation.getString(key);
          if (val == null || val === "undefined" || val === "null") {
            return void 0;
          }
          return JSON.parse(val);
        }
        setString(key, value) {
          this.implementation.setString(key, value);
        }
        getString(key) {
          const val = this.implementation.getString(key);
          if (val == null) {
            return void 0;
          }
          return val;
        }
        clear(key) {
          this.implementation.clear(key);
        }
        createJsonGetterSetter(key) {
          return {
            get: () => this.getJson(key),
            set: (value) => this.setJson(key, value)
          };
        }
        createStringGetterSetter(key) {
          return {
            get: () => this.getString(key),
            set: (value) => this.setString(key, value)
          };
        }
      };
      exports.EnvironmentStateAdapter_Sync = EnvironmentStateAdapter_Sync;
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/MeteorWalletConstants.js
  var require_MeteorWalletConstants = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/MeteorWalletConstants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WALLET_URL_LOCALHOST_BASE = exports.WALLET_URL_PRODUCTION_BASE = exports.WALLET_URL_DEV_BASE = void 0;
      exports.WALLET_URL_DEV_BASE = "https://dev.wallet.meteorwallet.app";
      exports.WALLET_URL_PRODUCTION_BASE = "https://wallet.meteorwallet.app";
      exports.WALLET_URL_LOCALHOST_BASE = "https://localhost:3000";
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/envConfig.js
  var require_envConfig = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/envConfig.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.setEnvConfig = exports.envConfig = void 0;
      var MeteorWalletConstants_1 = require_MeteorWalletConstants();
      var locallySetBaseUrl = typeof window !== "undefined" ? window.localStorage.getItem("DEV__METEOR_WALLET_BASE_URL") : void 0;
      exports.envConfig = {
        wallet_base_url: locallySetBaseUrl ?? MeteorWalletConstants_1.WALLET_URL_PRODUCTION_BASE
      };
      function setEnvConfig(config) {
        Object.assign(exports.envConfig, config);
      }
      exports.setEnvConfig = setEnvConfig;
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/utils/MeteorSdkUtils.js
  var require_MeteorSdkUtils = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/utils/MeteorSdkUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getNetworkPreset = exports.resolveWalletUrl = void 0;
      var envConfig_1 = require_envConfig();
      var resolveWalletUrl = (network, walletUrl2) => {
        if (walletUrl2) {
          return walletUrl2;
        }
        const base2 = envConfig_1.envConfig.wallet_base_url;
        switch (network) {
          case "mainnet":
            return `${base2}/connect/mainnet`;
          case "testnet":
            return `${base2}/connect/testnet`;
          case "betanet":
            return `${base2}/connect/betanet`;
          default:
            throw new Error("Invalid wallet URL");
        }
      };
      exports.resolveWalletUrl = resolveWalletUrl;
      var getNetworkPreset = (networkId) => {
        switch (networkId) {
          case "mainnet":
            return {
              networkId,
              nodeUrl: "https://rpc.mainnet.near.org",
              helperUrl: "https://helper.mainnet.near.org",
              explorerUrl: "https://explorer.near.org"
            };
          case "testnet":
            return {
              networkId,
              nodeUrl: "https://rpc.testnet.near.org",
              helperUrl: "https://helper.testnet.near.org",
              explorerUrl: "https://explorer.testnet.near.org"
            };
          case "betanet":
            return {
              networkId,
              nodeUrl: "https://rpc.betanet.near.org",
              helperUrl: "https://helper.betanet.near.org",
              explorerUrl: "https://explorer.betanet.near.org"
            };
          default:
            throw Error(`Failed to find config for: '${networkId}'`);
        }
      };
      exports.getNetworkPreset = getNetworkPreset;
    }
  });

  // ../../node_modules/nanoid/url-alphabet/index.js
  var urlAlphabet;
  var init_url_alphabet = __esm({
    "../../node_modules/nanoid/url-alphabet/index.js"() {
      urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    }
  });

  // ../../node_modules/nanoid/index.browser.js
  var index_browser_exports = {};
  __export(index_browser_exports, {
    customAlphabet: () => customAlphabet,
    customRandom: () => customRandom,
    nanoid: () => nanoid,
    random: () => random,
    urlAlphabet: () => urlAlphabet
  });
  var random, customRandom, customAlphabet, nanoid;
  var init_index_browser = __esm({
    "../../node_modules/nanoid/index.browser.js"() {
      init_url_alphabet();
      random = (bytes2) => crypto.getRandomValues(new Uint8Array(bytes2));
      customRandom = (alphabet, defaultSize, getRandom) => {
        let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
        let step = -~(1.6 * mask * defaultSize / alphabet.length);
        return (size = defaultSize) => {
          let id = "";
          while (true) {
            let bytes2 = getRandom(step);
            let j = step;
            while (j--) {
              id += alphabet[bytes2[j] & mask] || "";
              if (id.length === size) return id;
            }
          }
        };
      };
      customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);
      nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
        byte &= 63;
        if (byte < 36) {
          id += byte.toString(36);
        } else if (byte < 62) {
          id += (byte - 26).toString(36).toUpperCase();
        } else if (byte > 62) {
          id += "-";
        } else {
          id += "_";
        }
        return id;
      }, "");
    }
  });

  // ../../node_modules/strict-uri-encode/index.js
  var require_strict_uri_encode = __commonJS({
    "../../node_modules/strict-uri-encode/index.js"(exports, module) {
      "use strict";
      module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
    }
  });

  // ../../node_modules/decode-uri-component/index.js
  var require_decode_uri_component = __commonJS({
    "../../node_modules/decode-uri-component/index.js"(exports, module) {
      "use strict";
      var token = "%[a-f0-9]{2}";
      var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
      var multiMatcher = new RegExp("(" + token + ")+", "gi");
      function decodeComponents(components, split3) {
        try {
          return [decodeURIComponent(components.join(""))];
        } catch (err) {
        }
        if (components.length === 1) {
          return components;
        }
        split3 = split3 || 1;
        var left = components.slice(0, split3);
        var right = components.slice(split3);
        return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
      }
      function decode(input) {
        try {
          return decodeURIComponent(input);
        } catch (err) {
          var tokens = input.match(singleMatcher) || [];
          for (var i = 1; i < tokens.length; i++) {
            input = decodeComponents(tokens, i).join("");
            tokens = input.match(singleMatcher) || [];
          }
          return input;
        }
      }
      function customDecodeURIComponent(input) {
        var replaceMap = {
          "%FE%FF": "\uFFFD\uFFFD",
          "%FF%FE": "\uFFFD\uFFFD"
        };
        var match = multiMatcher.exec(input);
        while (match) {
          try {
            replaceMap[match[0]] = decodeURIComponent(match[0]);
          } catch (err) {
            var result = decode(match[0]);
            if (result !== match[0]) {
              replaceMap[match[0]] = result;
            }
          }
          match = multiMatcher.exec(input);
        }
        replaceMap["%C2"] = "\uFFFD";
        var entries = Object.keys(replaceMap);
        for (var i = 0; i < entries.length; i++) {
          var key = entries[i];
          input = input.replace(new RegExp(key, "g"), replaceMap[key]);
        }
        return input;
      }
      module.exports = function(encodedURI) {
        if (typeof encodedURI !== "string") {
          throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
        }
        try {
          encodedURI = encodedURI.replace(/\+/g, " ");
          return decodeURIComponent(encodedURI);
        } catch (err) {
          return customDecodeURIComponent(encodedURI);
        }
      };
    }
  });

  // ../../node_modules/split-on-first/index.js
  var require_split_on_first = __commonJS({
    "../../node_modules/split-on-first/index.js"(exports, module) {
      "use strict";
      module.exports = (string, separator) => {
        if (!(typeof string === "string" && typeof separator === "string")) {
          throw new TypeError("Expected the arguments to be of type `string`");
        }
        if (separator === "") {
          return [string];
        }
        const separatorIndex = string.indexOf(separator);
        if (separatorIndex === -1) {
          return [string];
        }
        return [
          string.slice(0, separatorIndex),
          string.slice(separatorIndex + separator.length)
        ];
      };
    }
  });

  // ../../node_modules/filter-obj/index.js
  var require_filter_obj = __commonJS({
    "../../node_modules/filter-obj/index.js"(exports, module) {
      "use strict";
      module.exports = function(obj, predicate) {
        var ret = {};
        var keys = Object.keys(obj);
        var isArr = Array.isArray(predicate);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var val = obj[key];
          if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
            ret[key] = val;
          }
        }
        return ret;
      };
    }
  });

  // ../../node_modules/query-string/index.js
  var require_query_string = __commonJS({
    "../../node_modules/query-string/index.js"(exports) {
      "use strict";
      var strictUriEncode = require_strict_uri_encode();
      var decodeComponent = require_decode_uri_component();
      var splitOnFirst = require_split_on_first();
      var filterObject = require_filter_obj();
      var isNullOrUndefined = (value) => value === null || value === void 0;
      var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
      function encoderForArrayFormat(options) {
        switch (options.arrayFormat) {
          case "index":
            return (key) => (result, value) => {
              const index = result.length;
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode(key, options), "[", index, "]"].join("")];
              }
              return [
                ...result,
                [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
              ];
            };
          case "bracket":
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode(key, options), "[]"].join("")];
              }
              return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
            };
          case "colon-list-separator":
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode(key, options), ":list="].join("")];
              }
              return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
            };
          case "comma":
          case "separator":
          case "bracket-separator": {
            const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              value = value === null ? "" : value;
              if (result.length === 0) {
                return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
              }
              return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
            };
          }
          default:
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, encode(key, options)];
              }
              return [...result, [encode(key, options), "=", encode(value, options)].join("")];
            };
        }
      }
      function parserForArrayFormat(options) {
        let result;
        switch (options.arrayFormat) {
          case "index":
            return (key, value, accumulator) => {
              result = /\[(\d*)\]$/.exec(key);
              key = key.replace(/\[\d*\]$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = {};
              }
              accumulator[key][result[1]] = value;
            };
          case "bracket":
            return (key, value, accumulator) => {
              result = /(\[\])$/.exec(key);
              key = key.replace(/\[\]$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = [value];
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
          case "colon-list-separator":
            return (key, value, accumulator) => {
              result = /(:list)$/.exec(key);
              key = key.replace(/:list$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = [value];
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
          case "comma":
          case "separator":
            return (key, value, accumulator) => {
              const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
              const isEncodedArray = typeof value === "string" && !isArray2 && decode(value, options).includes(options.arrayFormatSeparator);
              value = isEncodedArray ? decode(value, options) : value;
              const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
              accumulator[key] = newValue;
            };
          case "bracket-separator":
            return (key, value, accumulator) => {
              const isArray2 = /(\[\])$/.test(key);
              key = key.replace(/\[\]$/, "");
              if (!isArray2) {
                accumulator[key] = value ? decode(value, options) : value;
                return;
              }
              const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
              if (accumulator[key] === void 0) {
                accumulator[key] = arrayValue;
                return;
              }
              accumulator[key] = [].concat(accumulator[key], arrayValue);
            };
          default:
            return (key, value, accumulator) => {
              if (accumulator[key] === void 0) {
                accumulator[key] = value;
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
        }
      }
      function validateArrayFormatSeparator(value) {
        if (typeof value !== "string" || value.length !== 1) {
          throw new TypeError("arrayFormatSeparator must be single character string");
        }
      }
      function encode(value, options) {
        if (options.encode) {
          return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
        }
        return value;
      }
      function decode(value, options) {
        if (options.decode) {
          return decodeComponent(value);
        }
        return value;
      }
      function keysSorter(input) {
        if (Array.isArray(input)) {
          return input.sort();
        }
        if (typeof input === "object") {
          return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
        }
        return input;
      }
      function removeHash(input) {
        const hashStart = input.indexOf("#");
        if (hashStart !== -1) {
          input = input.slice(0, hashStart);
        }
        return input;
      }
      function getHash(url) {
        let hash = "";
        const hashStart = url.indexOf("#");
        if (hashStart !== -1) {
          hash = url.slice(hashStart);
        }
        return hash;
      }
      function extract(input) {
        input = removeHash(input);
        const queryStart = input.indexOf("?");
        if (queryStart === -1) {
          return "";
        }
        return input.slice(queryStart + 1);
      }
      function parseValue(value, options) {
        if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
          value = Number(value);
        } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
          value = value.toLowerCase() === "true";
        }
        return value;
      }
      function parse3(query, options) {
        options = Object.assign({
          decode: true,
          sort: true,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
          parseNumbers: false,
          parseBooleans: false
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const formatter = parserForArrayFormat(options);
        const ret = /* @__PURE__ */ Object.create(null);
        if (typeof query !== "string") {
          return ret;
        }
        query = query.trim().replace(/^[?#&]/, "");
        if (!query) {
          return ret;
        }
        for (const param of query.split("&")) {
          if (param === "") {
            continue;
          }
          let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
          value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
          formatter(decode(key, options), value, ret);
        }
        for (const key of Object.keys(ret)) {
          const value = ret[key];
          if (typeof value === "object" && value !== null) {
            for (const k of Object.keys(value)) {
              value[k] = parseValue(value[k], options);
            }
          } else {
            ret[key] = parseValue(value, options);
          }
        }
        if (options.sort === false) {
          return ret;
        }
        return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
          const value = ret[key];
          if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
            result[key] = keysSorter(value);
          } else {
            result[key] = value;
          }
          return result;
        }, /* @__PURE__ */ Object.create(null));
      }
      exports.extract = extract;
      exports.parse = parse3;
      exports.stringify = (object, options) => {
        if (!object) {
          return "";
        }
        options = Object.assign({
          encode: true,
          strict: true,
          arrayFormat: "none",
          arrayFormatSeparator: ","
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
        const formatter = encoderForArrayFormat(options);
        const objectCopy = {};
        for (const key of Object.keys(object)) {
          if (!shouldFilter(key)) {
            objectCopy[key] = object[key];
          }
        }
        const keys = Object.keys(objectCopy);
        if (options.sort !== false) {
          keys.sort(options.sort);
        }
        return keys.map((key) => {
          const value = object[key];
          if (value === void 0) {
            return "";
          }
          if (value === null) {
            return encode(key, options);
          }
          if (Array.isArray(value)) {
            if (value.length === 0 && options.arrayFormat === "bracket-separator") {
              return encode(key, options) + "[]";
            }
            return value.reduce(formatter(key), []).join("&");
          }
          return encode(key, options) + "=" + encode(value, options);
        }).filter((x) => x.length > 0).join("&");
      };
      exports.parseUrl = (url, options) => {
        options = Object.assign({
          decode: true
        }, options);
        const [url_, hash] = splitOnFirst(url, "#");
        return Object.assign(
          {
            url: url_.split("?")[0] || "",
            query: parse3(extract(url), options)
          },
          options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
        );
      };
      exports.stringifyUrl = (object, options) => {
        options = Object.assign({
          encode: true,
          strict: true,
          [encodeFragmentIdentifier]: true
        }, options);
        const url = removeHash(object.url).split("?")[0] || "";
        const queryFromUrl = exports.extract(object.url);
        const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
        const query = Object.assign(parsedQueryFromUrl, object.query);
        let queryString = exports.stringify(query, options);
        if (queryString) {
          queryString = `?${queryString}`;
        }
        let hash = getHash(object.url);
        if (object.fragmentIdentifier) {
          hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
        }
        return `${url}${queryString}${hash}`;
      };
      exports.pick = (input, filter, options) => {
        options = Object.assign({
          parseFragmentIdentifier: true,
          [encodeFragmentIdentifier]: false
        }, options);
        const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
        return exports.stringifyUrl({
          url,
          query: filterObject(query, filter),
          fragmentIdentifier
        }, options);
      };
      exports.exclude = (input, filter, options) => {
        const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
        return exports.pick(input, exclusionFilter, options);
      };
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_app_core/theme/constants_theme.js
  var require_constants_theme = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_app_core/theme/constants_theme.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.THEME_SMALL_WINDOW_WIDTH_MAX = exports.THEME_CONSTANT_BADGE_GREY_COLOR = exports.THEME_CONSTANT_GREEN_COLOR = exports.THEME_CONSTANT_RED_COLOR = exports.THEME_CONSTANT_COLOR_DARK = exports.THEME_CONSTANT_COLOR_BRAND = exports.SIGN_POPUP_HEIGHT = exports.SIGN_POPUP_WIDTH = void 0;
      exports.SIGN_POPUP_WIDTH = 390;
      exports.SIGN_POPUP_HEIGHT = 650;
      exports.THEME_CONSTANT_COLOR_BRAND = "#471be8";
      exports.THEME_CONSTANT_COLOR_DARK = "#101046";
      exports.THEME_CONSTANT_RED_COLOR = "#e25252";
      exports.THEME_CONSTANT_GREEN_COLOR = "#8bdaa1";
      exports.THEME_CONSTANT_BADGE_GREY_COLOR = "rgba(116,117,126,0.67)";
      exports.THEME_SMALL_WINDOW_WIDTH_MAX = 600;
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/postMessage/MeteorPostMessenger.js
  var require_MeteorPostMessenger = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/postMessage/MeteorPostMessenger.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getMeteorPostMessenger = void 0;
      var nanoid_1 = (init_index_browser(), __toCommonJS(index_browser_exports));
      var envConfig_1 = require_envConfig();
      var types_dappConnect_1 = require_types_dappConnect();
      var query_string_1 = require_query_string();
      var error_handling_dappConnect_1 = require_error_handling_dappConnect();
      var constants_theme_1 = require_constants_theme();
      var ComWindow = class {
        constructor(connection, listener) {
          const baseWalletUrl = envConfig_1.envConfig.wallet_base_url;
          const url = new URL(baseWalletUrl);
          this.walletOrigin = url.origin;
          if (window.meteorCom == null) {
            this.comType = types_dappConnect_1.EDappActionSource.website_post_message;
            console.log("No extension found. Need to connect to web popup for Meteor communication");
            const queryParams = {
              source: types_dappConnect_1.EDappActionSource.website_post_message,
              connectionUid: connection.uid
            };
            const w = constants_theme_1.SIGN_POPUP_WIDTH;
            const h = constants_theme_1.SIGN_POPUP_HEIGHT;
            const y = window.outerHeight / 2 + window.screenY - h / 2;
            const x = window.outerWidth / 2 + window.screenX - w / 2;
            const newWindow = window.open(`${baseWalletUrl}/connect/${connection.network}/${connection.actionType}?${(0, query_string_1.stringify)(queryParams)}`, "_blank", `popup=1,width=${w},height=${h},top=${y},left=${x}`);
            if (newWindow != null) {
              this.websiteWindow = newWindow;
            } else {
              throw new types_dappConnect_1.MeteorActionError({
                message: "Couldn't open popup window to complete wallet action",
                endTags: [error_handling_dappConnect_1.EDappActionErrorTag.POPUP_WINDOW_OPEN_FAILED]
              });
            }
            window.addEventListener("message", (event) => listener(event.data));
            this.wasOpened = false;
          } else {
            this.comType = types_dappConnect_1.EDappActionSource.extension_injected;
            this.wasOpened = true;
            window.meteorCom.addMessageDataListener(listener);
          }
        }
        focus() {
          if (this.comType === types_dappConnect_1.EDappActionSource.website_post_message) {
            this.websiteWindow?.focus();
          }
        }
        sendMessage(data) {
          if (this.comType === types_dappConnect_1.EDappActionSource.website_post_message) {
            this.websiteWindow?.postMessage(data, this.walletOrigin);
          } else {
            window.meteorCom?.sendMessageData(data);
          }
        }
        isWindowClosed() {
          if (this.comType === types_dappConnect_1.EDappActionSource.website_post_message) {
            return this.websiteWindow?.closed ?? true;
          } else {
            return false;
          }
        }
        hasActiveWindow() {
          if (this.comType === types_dappConnect_1.EDappActionSource.website_post_message) {
            return this.websiteWindow != null;
          } else {
            return true;
          }
        }
        close() {
          if (this.comType === types_dappConnect_1.EDappActionSource.website_post_message) {
            delete this.websiteWindow;
          } else {
          }
        }
      };
      var pingInterval = 450;
      var MeteorPostMessenger = class {
        constructor() {
          this.connections = [];
          const baseUrl = envConfig_1.envConfig.wallet_base_url;
          const url = new URL(baseUrl);
          this.baseWalletUrl = baseUrl;
          this.walletOrigin = url.origin;
          this.listener = (data) => {
            if (data != null) {
              const currentConnection = this.connections.find((con) => con.uid === data.uid);
              if (currentConnection != null) {
                this.updateConnection(currentConnection.uid, {
                  lastConnection: Date.now()
                });
                if (data.status === types_dappConnect_1.EDappActionConnectionStatus.attempting_reconnect) {
                  this.updateConnection(currentConnection.uid, {
                    status: types_dappConnect_1.EDappActionConnectionStatus.initializing
                  });
                  this.sendComs();
                }
                if (data.status === types_dappConnect_1.EDappActionConnectionStatus.connected && currentConnection.status === types_dappConnect_1.EDappActionConnectionStatus.initializing) {
                  this.updateConnection(currentConnection.uid, {
                    status: types_dappConnect_1.EDappActionConnectionStatus.connected
                  });
                }
                if (data.status === types_dappConnect_1.EDappActionConnectionStatus.closed_success) {
                  currentConnection.resolve({
                    success: true,
                    endTags: [],
                    payload: data.payload
                  });
                  this.updateConnection(currentConnection.uid, {
                    status: types_dappConnect_1.EDappActionConnectionStatus.closed_success
                  });
                  this.sendComs();
                }
                if (data.status === types_dappConnect_1.EDappActionConnectionStatus.closed_fail) {
                  this.updateConnection(currentConnection.uid, {
                    status: types_dappConnect_1.EDappActionConnectionStatus.closed_fail
                  });
                  this.sendComs();
                  currentConnection.reject(new types_dappConnect_1.MeteorActionError({ endTags: data.endTags }));
                }
                if (data.status === types_dappConnect_1.EDappActionConnectionStatus.closed_window) {
                  this.updateConnection(currentConnection.uid, {
                    status: types_dappConnect_1.EDappActionConnectionStatus.closed_window
                  });
                  currentConnection.reject(new types_dappConnect_1.MeteorActionError({
                    endTags: data.endTags,
                    message: "User closed the window"
                  }));
                }
                if ([
                  types_dappConnect_1.EDappActionConnectionStatus.disconnected,
                  types_dappConnect_1.EDappActionConnectionStatus.closed_fail,
                  types_dappConnect_1.EDappActionConnectionStatus.closed_window,
                  types_dappConnect_1.EDappActionConnectionStatus.closed_success
                ].includes(data.status)) {
                  this.removeConnection(currentConnection.uid);
                }
              }
            }
          };
        }
        removeConnection(uid) {
          this.connections = this.connections.filter((con) => con.uid !== uid);
          if (this.connections.length === 0) {
            delete this.comWindow;
            clearInterval(this.comInterval);
            delete this.comInterval;
          }
        }
        updateConnection(uid, newConnectionProperties) {
          this.connections = this.connections.map((con) => {
            if (con.uid === uid) {
              return {
                ...con,
                ...newConnectionProperties,
                uid: con.uid
              };
            }
            return con;
          });
        }
        sendComs() {
          if (this.comWindow?.hasActiveWindow() && this.connections.length > 0) {
            if (this.comInterval == null) {
              this.comInterval = setInterval(() => this.sendComs(), pingInterval);
            }
            if (this.comWindow.isWindowClosed()) {
              if (this.comWindow.wasOpened) {
                for (const con of this.connections) {
                  con.reject(new types_dappConnect_1.MeteorActionError({
                    message: "User closed the window before completing the action",
                    endTags: [
                      error_handling_dappConnect_1.EDappActionErrorTag.INCOMPLETE_ACTION,
                      error_handling_dappConnect_1.EDappActionErrorTag.WINDOW_CLOSED
                    ]
                  }));
                }
                this.connections = [];
                this.comWindow.close();
              } else {
                console.log("Window is closed, need to allow popup");
              }
            } else {
              this.comWindow.wasOpened = true;
              for (const { network, actionType, endTags, status, inputs, uid } of this.connections) {
                const postMessage = {
                  endTags,
                  actionType,
                  status,
                  uid,
                  network
                };
                if (status === types_dappConnect_1.EDappActionConnectionStatus.initializing) {
                  postMessage.inputs = inputs;
                }
                this.comWindow.sendMessage(postMessage);
              }
            }
          } else {
            clearInterval(this.comInterval);
            delete this.comInterval;
          }
        }
        addAndStartConnection(connection) {
          if (this.connections.length > 0) {
            for (const con of this.connections) {
              con.status = types_dappConnect_1.EDappActionConnectionStatus.disconnected;
              con.endTags = [error_handling_dappConnect_1.EDappActionErrorTag.NEW_ACTION_STARTED];
            }
          }
          this.connections.push(connection);
          if (this.comWindow == null || !this.comWindow.hasActiveWindow()) {
            this.comWindow = new ComWindow(connection, this.listener);
          } else {
            this.comWindow.focus();
          }
          this.sendComs();
        }
        async connectAndWaitForResponse({ actionType, network, inputs }) {
          let newConnection = {
            uid: (0, nanoid_1.nanoid)(),
            actionType,
            lastAttemptedConnection: 0,
            lastConnection: 0,
            status: types_dappConnect_1.EDappActionConnectionStatus.initializing,
            promise: void 0,
            reject: void 0,
            resolve: void 0,
            currentPayload: {},
            inputs,
            network,
            endTags: []
          };
          const promise = new Promise((resolve, reject) => {
            newConnection.resolve = resolve;
            newConnection.reject = (error) => {
              this.connections = this.connections.filter((con) => con.uid !== newConnection.uid);
              reject(error);
            };
          });
          newConnection.promise = promise;
          this.addAndStartConnection(newConnection);
          return await promise;
        }
      };
      var postMessenger;
      function getMeteorPostMessenger() {
        if (postMessenger == null) {
          postMessenger = new MeteorPostMessenger();
        }
        return postMessenger;
      }
      exports.getMeteorPostMessenger = getMeteorPostMessenger;
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/near-schema/TransactionSchemaV2.js
  var require_TransactionSchemaV2 = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/near-schema/TransactionSchemaV2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SCHEMA_V2 = void 0;
      var crypto_1 = require_commonjs3();
      var transactions_1 = require_commonjs4();
      exports.SCHEMA_V2 = /* @__PURE__ */ new Map([
        [
          transactions_1.Signature,
          {
            kind: "struct",
            fields: [
              ["keyType", "u8"],
              ["data", [64]]
            ]
          }
        ],
        [
          transactions_1.SignedTransaction,
          {
            kind: "struct",
            fields: [
              ["transaction", transactions_1.Transaction],
              ["signature", transactions_1.Signature]
            ]
          }
        ],
        [
          transactions_1.Transaction,
          {
            kind: "struct",
            fields: [
              ["signerId", "string"],
              ["publicKey", crypto_1.PublicKey],
              ["nonce", "u64"],
              ["receiverId", "string"],
              ["blockHash", [32]],
              ["actions", [transactions_1.Action]]
            ]
          }
        ],
        [
          crypto_1.PublicKey,
          {
            kind: "struct",
            fields: [
              ["keyType", "u8"],
              ["data", [32]]
            ]
          }
        ],
        [
          transactions_1.AccessKey,
          {
            kind: "struct",
            fields: [
              ["nonce", "u64"],
              ["permission", transactions_1.AccessKeyPermission]
            ]
          }
        ],
        [
          transactions_1.AccessKeyPermission,
          {
            kind: "enum",
            field: "enum",
            values: [
              ["functionCall", transactions_1.FunctionCallPermission],
              ["fullAccess", transactions_1.FullAccessPermission]
            ]
          }
        ],
        [
          transactions_1.FunctionCallPermission,
          {
            kind: "struct",
            fields: [
              ["allowance", { kind: "option", type: "u128" }],
              ["receiverId", "string"],
              ["methodNames", ["string"]]
            ]
          }
        ],
        [transactions_1.FullAccessPermission, { kind: "struct", fields: [] }],
        [
          transactions_1.Action,
          {
            kind: "enum",
            field: "enum",
            values: [
              ["createAccount", transactions_1.CreateAccount],
              ["deployContract", transactions_1.DeployContract],
              ["functionCall", transactions_1.FunctionCall],
              ["transfer", transactions_1.Transfer],
              ["stake", transactions_1.Stake],
              ["addKey", transactions_1.AddKey],
              ["deleteKey", transactions_1.DeleteKey],
              ["deleteAccount", transactions_1.DeleteAccount],
              ["signedDelegate", transactions_1.SignedDelegate]
            ]
          }
        ],
        [transactions_1.CreateAccount, { kind: "struct", fields: [] }],
        [transactions_1.DeployContract, { kind: "struct", fields: [["code", ["u8"]]] }],
        [
          transactions_1.FunctionCall,
          {
            kind: "struct",
            fields: [
              ["methodName", "string"],
              ["args", ["u8"]],
              ["gas", "u64"],
              ["deposit", "u128"]
            ]
          }
        ],
        [transactions_1.Transfer, { kind: "struct", fields: [["deposit", "u128"]] }],
        [
          transactions_1.Stake,
          {
            kind: "struct",
            fields: [
              ["stake", "u128"],
              ["publicKey", crypto_1.PublicKey]
            ]
          }
        ],
        [
          transactions_1.AddKey,
          {
            kind: "struct",
            fields: [
              ["publicKey", crypto_1.PublicKey],
              ["accessKey", transactions_1.AccessKey]
            ]
          }
        ],
        [transactions_1.DeleteKey, { kind: "struct", fields: [["publicKey", crypto_1.PublicKey]] }],
        [transactions_1.DeleteAccount, { kind: "struct", fields: [["beneficiaryId", "string"]] }],
        [
          transactions_1.DelegateAction,
          {
            kind: "struct",
            fields: [
              ["senderId", "string"],
              ["receiverId", "string"],
              ["actions", [transactions_1.Action]],
              ["nonce", "u64"],
              ["maxBlockHeight", "u64"],
              ["publicKey", crypto_1.PublicKey]
            ]
          }
        ],
        [
          transactions_1.SignedDelegate,
          {
            kind: "struct",
            fields: [
              ["delegateAction", transactions_1.DelegateAction],
              ["signature", transactions_1.Signature]
            ]
          }
        ]
      ]);
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/utils/create-action.js
  var require_create_action = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/utils/create-action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createAction = exports.parseArgs = void 0;
      var bn_js_1 = require_bn();
      var transactions_1 = require_commonjs4();
      var crypto_1 = require_commonjs3();
      var getAccessKey = (permission) => {
        if (permission === "FullAccess") {
          return transactions_1.actionCreators.fullAccessKey();
        }
        const { receiverId, methodNames = [] } = permission;
        const allowance = permission.allowance ? new bn_js_1.BN(permission.allowance) : void 0;
        return transactions_1.actionCreators.functionCallAccessKey(receiverId, methodNames, allowance);
      };
      var parseArgs = (data) => {
        if (typeof data === "string")
          return Buffer.from(data, "base64");
        return data;
      };
      exports.parseArgs = parseArgs;
      var createAction = (action) => {
        switch (action.type) {
          case "CreateAccount":
            return transactions_1.actionCreators.createAccount();
          case "DeployContract": {
            const { code } = action.params;
            return transactions_1.actionCreators.deployContract(code);
          }
          case "FunctionCall": {
            const { methodName, args, gas, deposit } = action.params;
            return transactions_1.actionCreators.functionCall(methodName, (0, exports.parseArgs)(args), new bn_js_1.BN(gas), new bn_js_1.BN(deposit));
          }
          case "Transfer": {
            const { deposit } = action.params;
            return transactions_1.actionCreators.transfer(new bn_js_1.BN(deposit));
          }
          case "Stake": {
            const { stake: stake4, publicKey } = action.params;
            return transactions_1.actionCreators.stake(new bn_js_1.BN(stake4), crypto_1.PublicKey.from(publicKey));
          }
          case "AddKey": {
            const { publicKey, accessKey } = action.params;
            return transactions_1.actionCreators.addKey(
              crypto_1.PublicKey.from(publicKey),
              // TODO: Use accessKey.nonce? near-api-js seems to think 0 is fine?
              getAccessKey(accessKey.permission)
            );
          }
          case "DeleteKey": {
            const { publicKey } = action.params;
            return transactions_1.actionCreators.deleteKey(crypto_1.PublicKey.from(publicKey));
          }
          case "DeleteAccount": {
            const { beneficiaryId } = action.params;
            return transactions_1.actionCreators.deleteAccount(beneficiaryId);
          }
          default:
            throw new Error("Invalid action type");
        }
      };
      exports.createAction = createAction;
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/MeteorWallet.js
  var require_MeteorWallet = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/MeteorWallet.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConnectedMeteorWalletAccount = exports.MeteorWallet = void 0;
      var near_api_js_1 = __require("near-api-js");
      var transactions_1 = require_commonjs4();
      var types_dappConnect_1 = require_types_dappConnect();
      var borsh_1 = require_cjs();
      var StringUtils_1 = require_StringUtils();
      var EnvironmentStorageUtils_1 = require_EnvironmentStorageUtils();
      var MeteorSdkUtils_1 = require_MeteorSdkUtils();
      var MeteorPostMessenger_1 = require_MeteorPostMessenger();
      var TransactionSchemaV2_1 = require_TransactionSchemaV2();
      var crypto_1 = require_commonjs3();
      var create_action_1 = require_create_action();
      var bn_js_1 = require_bn();
      var MULTISIG_HAS_METHOD = "add_request_and_confirm";
      var LOCAL_STORAGE_KEY_SUFFIX = "_meteor_wallet_auth_key";
      var localStorageAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({
        getString: (key) => window.localStorage.getItem(key),
        setString: (key, value) => window.localStorage.setItem(key, value),
        clear: (key) => window.localStorage.removeItem(key)
      });
      var sessionAdapter = new EnvironmentStorageUtils_1.EnvironmentStateAdapter_Sync({
        getString: (key) => window.sessionStorage.getItem(key),
        setString: (key, value) => window.sessionStorage.setItem(key, value),
        clear: (key) => window.sessionStorage.removeItem(key)
      });
      var MeteorWallet2 = class _MeteorWallet {
        /**
         * The easiest way to set up the SDK. Returns an instance of MeteorWallet, automatically connected to the Near API.
         *
         * If you need more control over the Near Network configuration- rather use {@link MeteorWallet:constructor}
         *
         * @example
         * ```js
         * const wallet = await MeteorWallet.init({ networkId: "testnet" });
         * ```
         */
        static async init({ walletUrl: walletUrl2, ...config }) {
          const keyStore = new near_api_js_1.keyStores.BrowserLocalStorageKeyStore();
          const near = await (0, near_api_js_1.connect)({
            keyStore,
            headers: {},
            walletUrl: (0, MeteorSdkUtils_1.resolveWalletUrl)(config.networkId, walletUrl2),
            ...(0, MeteorSdkUtils_1.getNetworkPreset)(config.networkId),
            ...config
          });
          const wallet = new _MeteorWallet({ near, appKeyPrefix: "near_app" });
          if (!wallet.isSignedIn()) {
            await keyStore.clear();
          }
          return wallet;
        }
        /**
         * Construct MeteorWallet. If you'd a quick and default way, you can also use {@link MeteorWallet.init}
         *
         * @example
         * ```js
         * // create new MeteorWallet instance (passing in your initialized Near connection)
         * const meteorWallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });
         *
         * if(!meteorWallet.isSignedIn()) {
         *   const { accountId } = await meteorWallet.requestSignIn();
         * }
         * ```
         */
        constructor({ near, appKeyPrefix = near.config.contractName ?? "default" }) {
          this._initializationPromises = [];
          this._near = near;
          const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
          this._authDataKey = authDataKey;
          this._authData = localStorageAdapter.getJson(authDataKey) ?? { allKeys: [] };
          this._networkId = near.config.networkId;
          this._walletBaseUrl = near.config.walletUrl;
          this._keyStore = near.connection.signer.keyStore;
        }
        /* async initialize() {
           await Promise.all(this._initializationPromises);
         }*/
        isExtensionInstalled() {
          return window.meteorWallet != null;
        }
        /**
         * Returns true, if this app is authorized with an account in the wallet.
         * @example
         * ```js
         * const wallet = new MeteorWallet({ near: connectedNear, appKeyPrefix: 'my-app' });
         * wallet.isSignedIn();
         * ```
         */
        isSignedIn() {
          return !!this._authData.accountId;
        }
        /**
         * Returns authorized Account ID.
         * @example
         * ```js
         * const wallet = new MeteorWallet(near, 'my-app');
         * const accountId = wallet.getAccountId();
         * ```
         */
        getAccountId() {
          return this._authData.accountId;
        }
        /**
         * Verifies that the user is the owner of a specific Near account, available in the wallet.
         * Removes the need to do blockchain operations for simple Dapp actions.
         * Signs a payload with the wallet's private key. Will return a promise with a payload like so:
         *
         * ```ts
         * interface VerifiedOwner {
         *   accountId: string;
         *   message: string;                 // The same passed message, unencrypted
         *   blockId: string;
         *   publicKey: string;               // The public key which should be verified as belonging to this account
         *   signature: string;               // The signed payload (this exact same object JSON stringified, excluding this "signature" property)
         *   keyType: utils.key_pair.KeyType; // Type from inside the near-api-js package
         * }
         * ```
         *
         * or throw a {@link MeteorActionError} error if the verification failed for whatever reason.
         * */
        async verifyOwner(options) {
          const accountId = options.accountId ?? this.getAccountId();
          const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: types_dappConnect_1.EExternalActionType.verify_owner,
            inputs: {
              accountId,
              message: options.message
            },
            network: this._networkId
          });
          if (response.success) {
            return response;
          } else {
            throw new types_dappConnect_1.MeteorActionError({
              endTags: response.endTags,
              message: response.message
            });
          }
        }
        /**
         * Requests a sign-in using Meteor Wallet. Will return a promise with the `accountId` of the
         * signed-in account, or throw a {@link MeteorActionError} error if the sign-in failed for whatever reason.
         * */
        async requestSignIn(options) {
          const { keyPair, ...restOptions } = options;
          const accessKey = keyPair ?? near_api_js_1.KeyPair.fromRandom("ed25519");
          let usingPublicKey = accessKey.getPublicKey().toString();
          const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: types_dappConnect_1.EExternalActionType.login,
            inputs: { public_key: usingPublicKey, ...restOptions },
            network: this._networkId
          });
          if (response.success) {
            const { allKeys, accountId } = response.payload;
            this._authData = {
              accountId,
              allKeys,
              signedInContract: {
                contract_id: restOptions.contract_id,
                public_key: usingPublicKey
              }
            };
            localStorageAdapter.setJson(this._authDataKey, this._authData);
            await this._keyStore.setKey(this._networkId, accountId, accessKey);
            return {
              success: true,
              endTags: [],
              payload: {
                accessKey,
                accountId
              }
            };
          } else {
            throw new types_dappConnect_1.MeteorActionError({
              endTags: response.endTags,
              message: response.message
            });
          }
        }
        /**
         * Sign out from the current account
         */
        async signOut() {
          const accountId = this.getAccountId();
          if (this._authData.signedInContract != null && accountId != null) {
            const inputs = {
              accountId,
              contractInfo: this._authData.signedInContract
            };
            const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
              actionType: types_dappConnect_1.EExternalActionType.logout,
              inputs,
              network: this._networkId
            });
          }
          this._authData = { allKeys: [] };
          localStorageAdapter.clear(this._authDataKey);
        }
        /**
         * Allows users to sign a message for a specific recipient using their NEAR account, based on the [NEP413](https://github.com/near/NEPs/pull/413).
         *
         * Will return a promise with a payload like so:
         *
         * ```ts
         * interface signMessage {
         *   accountId: string;               // The account name to which the publicKey corresponds as plain text
         *   publicKey: string;               // The public counterpart of the key used to sign
         *   signature: string;               // The base64 representation of the signature
         *   state?: string;                  // The same state passed in.
         * }
         * ```
         *
         * or throw a {@link MeteorActionError} error if the signing failed for whatever reason.
         * */
        async signMessage({ message, nonce, recipient, callbackUrl, state, accountId }) {
          const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: types_dappConnect_1.EExternalActionType.sign_message,
            inputs: {
              message,
              nonce,
              recipient,
              callbackUrl,
              state,
              accountId
            },
            network: this._networkId
          });
          if (response.success) {
            response.payload.state = state;
            return response;
          } else {
            throw new types_dappConnect_1.MeteorActionError({
              endTags: response.endTags,
              message: response.message
            });
          }
        }
        /**
         * Sign transactions using Meteor Wallet. Will return a promise with an array of `FinalExecutionOutcome`
         * of the given transactions.
         * */
        async requestSignTransactions(inputs) {
          const { transactions } = inputs;
          const transformedTransactions = await this.transformTransactions(transactions);
          console.log("Transformed transactions", transformedTransactions);
          const response = await (0, MeteorPostMessenger_1.getMeteorPostMessenger)().connectAndWaitForResponse({
            actionType: types_dappConnect_1.EExternalActionType.sign,
            inputs: {
              transactions: transformedTransactions.map((transaction) => (0, borsh_1.serialize)(TransactionSchemaV2_1.SCHEMA_V2, transaction)).map((serialized) => Buffer.from(serialized).toString("base64")).join(",")
            },
            // inputs: { public_key: usingPublicKey, ...options },
            network: this._networkId
          });
          if (response.success) {
            return response.payload.executionOutcomes;
          } else {
            throw new types_dappConnect_1.MeteorActionError({
              endTags: response.endTags,
              message: response.message
            });
          }
        }
        /**
         * Returns the current connected wallet account
         */
        account() {
          const currentAccountId = this.getAccountId();
          if ((0, StringUtils_1.notNullEmpty)(currentAccountId) && this._connectedAccount?.accountId !== currentAccountId) {
            this._connectedAccount = new ConnectedMeteorWalletAccount(this, this._near.connection, currentAccountId);
          }
          return this._connectedAccount;
        }
        async transformTransactions(transactions) {
          const account = this.account();
          const { networkId, signer, provider } = account.connection;
          const localKey = await signer.getPublicKey(account.accountId, networkId);
          return Promise.all(transactions.map(async (transaction, index) => {
            const accessKey = await account.accessKeyForTransaction(localKey);
            if (!accessKey) {
              throw new Error(`Failed to find matching key for transaction sent to ${transaction.receiverId}`);
            }
            const transformedActions = transaction.actions.map((action) => (0, create_action_1.createAction)(action));
            const block = await provider.block({ finality: "final" });
            return (0, transactions_1.createTransaction)(account.accountId, crypto_1.PublicKey.from(accessKey.public_key), transaction.receiverId, new bn_js_1.BN(accessKey.access_key.nonce).add(new bn_js_1.BN(index)).add(new bn_js_1.BN(1)), transformedActions, near_api_js_1.utils.serialize.base_decode(block.header.hash));
          }));
        }
      };
      exports.MeteorWallet = MeteorWallet2;
      var ConnectedMeteorWalletAccount = class extends near_api_js_1.Account {
        /** @hidden */
        constructor(walletConnection, connection, accountId) {
          super(connection, accountId);
          this.meteorWallet = walletConnection;
        }
        /**
         * Sign a transaction using Meteor Wallet. Overrides the Near Account API method of the same name, makes use of {@link ConnectedMeteorWalletAccount.signAndSendTransaction_direct}
         */
        async signAndSendTransaction(...args) {
          if (typeof args[0] === "string") {
            return this.signAndSendTransaction_direct({
              receiverId: args[0],
              actions: args[1]
            });
          }
          return this.signAndSendTransaction_direct(args[0]);
        }
        /** @hidden */
        async trySendOrCreateTransaction({ receiverId, actions }) {
          const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
          let accessKey = await this.accessKeyForTransaction(localKey);
          if (accessKey != null && accessKey.access_key.permission !== "FullAccess") {
            const accessKeyMatchesTransaction = await this.accessKeyMatchesTransaction(accessKey, receiverId, actions);
            if (!accessKeyMatchesTransaction) {
              return {
                sent: false,
                transaction: {
                  receiverId,
                  signerId: this.accountId,
                  actions
                }
              };
            }
          }
          if (accessKey) {
            if (localKey && localKey.toString() === accessKey.public_key) {
              try {
                return {
                  executionOutcome: await super.signAndSendTransaction({
                    receiverId,
                    actions: actions.map((action) => (0, create_action_1.createAction)(action))
                  }),
                  sent: true
                };
              } catch (e) {
                if (e.type !== "NotEnoughAllowance") {
                  throw e;
                }
              }
            }
          }
          return {
            sent: false,
            transaction: {
              receiverId,
              signerId: this.accountId,
              actions
            }
          };
        }
        /**
         * Sign a transaction using Meteor Wallet
         * @see {@link MeteorWallet.requestSignTransactions}
         */
        async signAndSendTransaction_direct({ receiverId, actions }) {
          const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });
          if (sent) {
            return executionOutcome;
          }
          return (await this.meteorWallet.requestSignTransactions({
            transactions: [transaction]
          }))[0];
        }
        /** @hidden */
        /*async signAndSendTransaction_redirect({
            receiverId,
            actions,
            walletMeta,
            walletCallbackUrl = window.location.href,
          }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome> {
            const { transaction, sent, executionOutcome } = await this.trySendOrCreateTransaction({ receiverId, actions });
        
            if (sent) {
              return executionOutcome!;
            }
        
            await this.meteorWallet.requestSignTransactions_redirect({
              transactions: [transaction!],
              meta: walletMeta,
              callback_url: walletCallbackUrl,
            });
        
            return new Promise((resolve, reject) => {
              setTimeout(() => {
                reject(new Error("Failed to redirect to sign transaction"));
              }, 1000);
            });
          }*/
        /**
         * Check if given access key allows the function call or method attempted in transaction
         * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items
         * @param receiverId The NEAR account attempting to have access
         * @param actions The action(s) needed to be checked for access
         */
        async accessKeyMatchesTransaction(accessKey, receiverId, actions) {
          const { access_key: { permission } } = accessKey;
          if (permission === "FullAccess") {
            return true;
          }
          console.log("Comparing access key and actions", {
            accessKey,
            receiverId,
            actions
          });
          if (permission.FunctionCall) {
            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
            if (allowedReceiverId === receiverId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {
              return true;
            }
            if (allowedReceiverId === receiverId) {
              if (actions.length !== 1) {
                return false;
              }
              const firstAction = actions[0];
              console.log(firstAction);
              if (firstAction.type === "FunctionCall") {
                const functionCallParams = firstAction.params;
                return (!functionCallParams.deposit || functionCallParams.deposit.toString() === "0") && // TODO: Should support charging amount smaller than allowance?
                (allowedMethods.length === 0 || allowedMethods.includes(functionCallParams.methodName));
              }
            }
          }
          return false;
        }
        /**
         * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
         * @param localKey A local public key provided to check for access
         * @returns Promise<any>
         */
        async accessKeyForTransaction(localKey) {
          const accessKeys = await this.getAccessKeys();
          console.log("accessKeys", accessKeys);
          if (localKey) {
            const accessKey = accessKeys.find((key) => key.public_key.toString() === localKey.toString());
            if (accessKey) {
              return accessKey;
            }
          }
          const walletKeys = this.meteorWallet._authData.allKeys;
          for (const accessKey of accessKeys) {
            if (walletKeys.indexOf(accessKey.public_key) !== -1) {
              return accessKey;
            }
          }
          for (const accessKey of accessKeys) {
            if (accessKey.access_key.permission === "FullAccess") {
              return accessKey;
            }
          }
          return null;
        }
      };
      exports.ConnectedMeteorWalletAccount = ConnectedMeteorWalletAccount;
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_external/near/types/near_basic_types.js
  var require_near_basic_types = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-common/src/modules_external/near/types/near_basic_types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ENearNetworkSuffix = exports.ENearNetwork = void 0;
      var ENearNetwork;
      (function(ENearNetwork2) {
        ENearNetwork2["localnet"] = "localnet";
        ENearNetwork2["testnet"] = "testnet";
        ENearNetwork2["betanet"] = "betanet";
        ENearNetwork2["mainnet"] = "mainnet";
      })(ENearNetwork = exports.ENearNetwork || (exports.ENearNetwork = {}));
      var ENearNetworkSuffix;
      (function(ENearNetworkSuffix2) {
        ENearNetworkSuffix2["testnet"] = ".testnet";
        ENearNetworkSuffix2["mainnet"] = ".near";
      })(ENearNetworkSuffix = exports.ENearNetworkSuffix || (exports.ENearNetworkSuffix = {}));
    }
  });

  // ../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/index.js
  var require_src = __commonJS({
    "../../node_modules/@fastnear/meteorwallet-sdk/dist/meteor-sdk/src/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.setEnvConfig = exports.ENearNetwork = void 0;
      __exportStar(require_MeteorWallet(), exports);
      __exportStar(require_MeteorSdkUtils(), exports);
      __exportStar(require_MeteorWalletConstants(), exports);
      __exportStar(require_types_dappConnect(), exports);
      var near_basic_types_1 = require_near_basic_types();
      Object.defineProperty(exports, "ENearNetwork", { enumerable: true, get: function() {
        return near_basic_types_1.ENearNetwork;
      } });
      var envConfig_1 = require_envConfig();
      Object.defineProperty(exports, "setEnvConfig", { enumerable: true, get: function() {
        return envConfig_1.setEnvConfig;
      } });
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    handleLogin: () => handleLogin,
    handleSend: () => handleSend
  });

  // src/icons/here.ts
  var here_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xOS43MzM1IDExLjY4MzFMMjEuNzA4OSA4TDI0LjI5ODMgMTYuNjc2NkwyMC40MTYgMTQuOTIxNUwxOS43MzM1IDExLjY4MzFaTTUuNzYzODggMTUuNTQwOUwzLjc1NTYyIDE5LjE2MjFMOS44OTYwNSAyMi4xNjYxTDE4LjM0NzMgMjEuNTgyOEw1Ljc2Mzg4IDE1LjU0MDlaTTQuNjQ0NjQgMjIuMzY5NEwyLjY0ODY1IDI1Ljk3MTNMMTQuOTA4MyAzMi4wNTc1TDM1LjMzODggMzAuODE3NEwzNy4zMzQ4IDI3LjIxNTRMMTYuOTA0MyAyOC40NTU3TDQuNjQ0NjQgMjIuMzY5NFoiIGZpbGw9IiMyQzMwMzQiLz4KPHBhdGggZD0iTTM3LjMzNTkgMjcuMjE1N0wxNi45MTEyIDI4LjQ1NjFMNC41NDYzMyAyMi4zNTU0TDE3LjkzNTggMjEuNTQ1M0w1Ljc2Mzg3IDE1LjU0MDlMMTEuNzQxIDEwLjQ3ODZMMjQuMTQwMSAxNi41NzYzTDIxLjcwOSA4TDMzLjU1NyAxMy44MUwzNy4zMzU5IDI3LjIxNTdaIiBmaWxsPSIjRkRCRjFDIi8+Cjwvc3ZnPgo=";

  // src/icons/near.ts
  var near_default = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAD8UExURUdwTGx5rpLO8YOYx1Og0ly29X5ezR4mT0tiji4eWJ953KGn1Jxs7qB9xvfD/Us0gduu8yeh4HOq74dD647R91256eSz+j82cbvg/dSj/LuL79Wp6zCf24KN9xANGRANF59d/0W+/taa/8iN/3HL9uOn/z638Bil7l3G84TP+FHB8o5A/0i9/ZjU+47S+vq8/4Qy/S6w8O+x/5Rp/wyg7G2T/s+T/vO2/+qt/1qp/qDV/HyD/ki4+4R7/qnY/tyh/1Gx/ptU/76E/2bJ9Ld8/4t0/pxe+XvN9iOq7rB0/0i88aRk/6ps/z++/naL/mab/mGh/pVM/wub5mGd+fAEOhEAAAAgdFJOUwBEyWKA47EKJhnFluGA6l3H67Du6crdNOXs5q/I65rcQbfB9AAAIABJREFUeNrsnE9r4zoXxidOG9tNQqBvSrLKeKGF7WIz4J0WgSCuDc1s7vf/Mq/+S0d2p7Zkd7i0SsZJh3th+PGcR4+OpP748T3+4yNODofDKY2/SYxgdbhcfl4ul9M3rY9ZpZefbFwu6TeMD8dJwPp5Sb6l9eFIL5zW5TDoWrEc35wEjtOFDWPxjE2aJMkqWa3W6/WevuigPyVJ+tWngTg+HQ58PmSDQlqvt5Eax+jIBv2UY7umyL6u0JiMBK6DpETp4KqmL/ngX9hnwcEJYl8TGIV1EpzOEaNUCUBqFPwPfRX0W8GfFSPGgX255JCcTpwUByVY1WAU/FHwLxRWV3RdIYGtvhIvKqoVI0WriwoGK1CDvLi8JDouse5L8YqT08M2Op+vVFOYl54wJ+5PkppkJUkJZYlipN9RV1Ne69UXmCOT0zY6Xq+4Kip7GEYGmKZVyNF1ghj9whx//ZfltXQYTE/b8xnTUeFr1R82Lm7vwuPh6Cgz9jr+TVx8Mt+zcTgt0w6Ik310xIJVJXxdUaqgsIzH1w6tjlekxrVdpX/FSlb7zW63a+lrt3vazG8JFiqHVa2ewOQLlR70W1oX58XlhSiv7aerKz4xUvd7Rse9pWO32xxm/VfE6To64yt1KyEsgUt8ckT99GDsHUpL6oq9EaKT4+cWY5weNrvfbZtlNwqLfkpcM0o8XtFMhZlRUT7YYDLKEtmhsurQJNO6R0sEL0brk3FRWe3+ydpMDvblzpDtnvYz/SPihIYFzHRFYYE6xMazBnJWYTyrhsri4uqEfSESPX+WdcWnza7NbjemKyYpVob/Ml5Zu9vP0cmME1aBxZXDuSpdKWSGlK0qxUqteSxUphA7hLoOsednWVe8YiV4y34zTYkX9a4bhXejtbgJp8VQcVmJuDA4Gyp7d2K8TFn1oGnJWbEjqO5ywnLE5+iK8mGyEnbFlMV0dWO1GEyLmhWdA1kKrdiTG7y2duPvss3QWx1qVLVLSxZiJwRWdOQTxJXsd9qrGKvMHsznn4JocbNic6B5KWW5wlLMBmbDesjcOzN4KZLj0uKKD7tWcslcVIJgiLbi1fasSYk3p2WUJTsOdsqqHGVBw9I5q7BQcVp0XlxYXKdNa4Tlqkp8/uNNi0UrzupqawsLd8cYqqoXSkHOqu0ED5SF1AshQo1+tRyteM+F1RhGjXy0oiwZLU9txWwdKEhpTKIIjWv1pDUQHGpXW66uUGfTWi8WIk5Pd6Ao5VqNNDCGq7170WIx9IqFqq4iuXNUVyWr95RVDeYsSKqwPEvSkrgQLcXFhHW/STz8T2uqz9DKfHwrPVisMP/GSV0tZdkxvq6qgf6fzu+1hQsoC+mwRQd/Pi5kXOnmt+Jh53fH4mkG220m/gOSh0gpyuBSVVhhuNxRsbRfh+5sCH1LCqpjvNg39kHYrLiIcfEqZHwah5DzM8tbk2glbBbEVgHKqVANMxViJzvApWFd9wOWcng9FSrHQtLpaUJdgFa8euqHheExzeWptRuzMgqzgpaO8bClVVXuhoXSVT0kLCEtwUo+mG2hxwVoxetdNhYW09YkXUFQ3LIMJ1OJGPJyFoiqVVrD6K6VpSdCpS0xlqjEdD8a1hRa8fYs8DiuBUrRpSWF1e/+DbSzrCq0YpaaDjv2mJ9Wutll9w8xNWKGpLT242gl0fnDEsRDylKkqoF2Vu24FoxYcsGjypDQEa3npRVvRllWw8MXXWGPpJVE0bXvWCad2sLCfc9yZkSoqkI3suyljnQrrimOi+Q5mplWuhnp7zKqUm2lo6wQlqGqQygsteDBoAFfuWsdp1Oquu+82dBZyoKuRdhr3kqksMbSov8dja8jtZVsoyFlye6DrSwtLVxbydQA05hqW1qOZ1mrQ1GENGyxx7y0KKzbOFgNz6ajXT5xogO+2j0H4Fm2tNxeqZXgB5SF3JQFBnWtefPW2DJsVLRvR9KKk4GgpV1LSQv0HjDcwh8CpTfCQHPGWJampF1+zrw12rPElDghQXBa2PV3LFc9lrIwbCtbs2ExBMzOo9ZEqCtQUpLFmOfH59lW1emYAN+2rb1snEDrHWm56QE7uAZmQ1iInb3QkaTEgwhgiIgPNCetdNxqpzUmn4kexFhauOdbYDVtdwAr9zzb8JahyqSwCjtkS4vwwX/K82g7T38rnqgs9Rf30S5/xX9QlhO1avNyldVzeKejbKpQSosI46Jhi+Rzxa109DoajFs2ntYfpNWbEHstmrofsmQZFrD5Dk2LCJNnpkWBoXlMPh4Jq4ENG563vLTVC1qgDut+F75/5AiUIfR36er6Wy4URrp5bCsZBavpb2fcRva3+tqCMb7CTg+w6p8qfb8MkeblmpaweOZblFl5nKPRHHuW4fj+FshbeIgXPPBQgSNa8iwpnAjtIjTuToBpyaW0GvPYFlXWPYTWhDnRNJcx1rs8yrC0ZfWOO4CGA5gLkW1ZrJ2skAlBWQPl5CXctpiyfGG12ciVz0lWIjZLa6Osyj3XVtfvG5YmVViGZa11pGUREUpFepDSIjPYlqeyGtXfmpK3sNUAtGj1TmnB3p+7aWiON1jW3klJ6ToEwqKoaNp6iP8KrEa5/di8dbLnRNxrl1Z21JLLRJgd3MMzrrur7E6QeQBYpCRRMkPO8itDtbc4tmNzBgZvw3Kb8AM7PEJbmhXYMESgj0V0yDI1mHNplcdgafkbPKfF9hPHnA0cWPmArGV1acCJtt5+YQH9ynYsgvS6EDllSGnRKB/s8QEGb3Yxxs6Jg5YFtyyArApnbSjPdPcSKQLKUgbveFYe7vFB0WFKf6u3kYhB9wH2ljUrFUrroe1CI6qOGGERhFCfE/8IlVaYsqZ0bNTKB2OVIrBTifJy4cAR3HcWOhKYG0d7M+Fc0vJTlld/C86JIGrpJQ/olaqLTXVtoSqsRGpWOTC5m3DFKTFQ3LVCc7yXstp+f2vUno/JW043XsbSuhq4kDJ07hZurMJAOmBXiloZJi3fBN/CoyNsPzGdsPKxYZmzy8KvsK5F9WUok0LXIqCfbCJDrljlYpRh0krDytBaJ07RluNa8Jj3UV0if5b3pu2DpI6yYMAyjQYrMhD9CpVWHBwdVH/r9xRaIMTbTRoBar9aJWKs+H1XSqxn8JpVJ2dDiQrBKEqAsgKlFbaQhnlrdCVewTa+Vha/X89+iUMM/49EACsKc/IdwfMNBLRIkWtYufb5IGkxZbE7AtMXh9nAefnt6P1ErNfV8iYPxmd2QeKdS3txslpTXPJeU1cg5PRnUK/+BB9LVDNIi+0btu2f3Gg0vZFnbHQPomK3U0Qgra7nj26Is9s/xyOlUxRDZ9d0KLXjlealPCsnQdJK+CZrm80w2imVKLqB/HoKV9W7ooK4okJ1sxCMWUQld2QbFvArupbmrZpVgLL+xy6DZfdwUqzLNS1viWXO9Rptk1E7e1xdtAaVbSHU26oAwT03ZiWZlbQO/ZsPFNbrLbsNH7qd0gzU57fS8VmeX9SkFTj+kH+SbKNanGCTJ7E63vgjCEYsouZBRYm7OzP4kL4WhfXr9XYb3H+ePjfesmYCLd6Jv068bMPEpY/O2Cdm1E40sqrQrUTOy9/iGSxFqwlgpc9vNU9jK5HdAJ4kK3W++vkIt+w7qzmK+v0GC1Qelh44rF//3uTN6CbMuW6j89aPlHdsztH0y7rsArGqxM5q+BF3BW3lK0WLLRD9LV7Aotq6ZzJvNb7RwfS3Rs2JlBaNml7XRpLt8UiorApwykjHhtwOC4ZUKT/KR986lLAorYErdF7r63a0ttbedwOpcRHSdXCXAsYG1fIjDi/28K1DBYvTalvv4OD0t0ZpK/b/JRuMlrMJTdw8CrO7paz8JRSW0FZIx9Ta8hmprZBuCaWVy/1CGLGsuK54lcLdpbJy7zo0sLhvZd77Yg04NHJfntY2Mg1lgnrtPuDrSloS1+NzGgpLJoh7gLIm97dCGuLbI4E79o6/W7hIqVmVtAx969CG1U+nPnOizBC/F6e1itR2DhlY5pjuqO1ZUlovq3BYglbr5fONX38rpCW+juz9HOT0sGzLKqVxleLta1oQFvetW3Zv5+lBbBf+HQvUtuSBoj/VoPH4UqAqc+JnWg4sOSe2QctEfdBmwv1EP9uKOnUeC2gqH/YrSYo9/JKWC4vTus0grAnpNLAQYcJyls9lbmJDKQ2ePl7mgRWUt5yY2ixNK3k+8gPJTsCydSVQKUxSWW+PXhv5fVgib4V2A6f1t/yldRwMDU5TRvAy0aEs0cNMsGbpb8lfntE0y9JKoiM76O4IK7eDOzAshuqNKeshnQmWS6v1tq3x9xP9XYvYsKyOe8nempYsQEXMz+FF82+YVtuG2tZtcd+iyZRYW6nvKctQkuMlmUtZpr/VhvsWpbVdjla6PZZcWQ4qKCrbsdh4K70yvFbW68Cc6N+yUbm0bTit5bQVr6J8uN0ODMtW1hufDn0yPNvd+TWsLf9EqhY+7LNZ2OWTl37/2O7J6LhgAXsLgcVxvc6Yt8zvSWKLxmZJWunzsXRxldzaS9utchsVez94K+v11+uwbwVKq2kFrHY5WjRqlWYjh6jFoFw8A1BvFqvH5yBlDWnLt2Uj9qcbRqvhymr+T9vZtTaOZGG4m51O3M3AsDOEgaEDXhjsxr6JcXxh3AKLHQnFDk68/v//ZavOV51TVfKHpJRkxUl6LubhOW+dKtlO9VG0fGhFrajsxiihfqi8grPLUpphtbhV9lhH4wdN4fjA3Pr88PcPvcahXQZdgRoVserUaHEZiluGGd5P7BD0TqeyFq18xn8YrdHvf4fmXWJd1oNRg7Wj8z8P3WA9zcmsltwqO9JybQMdOD6oEu//lXRY0X6MTIEECi4dYc0F1DzfQdy8v+UJ4bnU4/FDaEGnlZglpH7sog6LaHWGRbjmuZiH/a36JqfGJbGKYDm3PuJDMSHhCdR/bRf6Q9XezuT7rpdZ8/ZK7HDHgutPToL17QNoueUhvxg5tA2zdDm4I2a7fmXIauV53XY/sQ51aMWq3OHduv8QWDOJLIXqh4703Uyfuy6LQzILec3T+TB7P7E+qxaQqmOriNcH0Bo9yEvVeB6cmbTaxcB2HVfSbBYAw2JM7bpyfwuLcImJtRwniQWX6tvQtD4/SNdOG6N6caP7djnc+PJ5gMxq706vuZ+4ZLeYVSSWgzW4W86szK6MXTdrWjt4dHk7nZg1n8/VtBhXI+xvjc/uby3JqmWmaSCxMLaGdotghbUg35UIMs0w1yned2jWfefM0p3pvGUP4qJZwoucGusCJFp+fBv0k/hGDz/0YtDs8dneKqCaDGKWZNdT4tbljrTWdbhMpkJmVT3+OiQtB2um7jnbxY0qQJ1YPcyai1y6i8j2W/t2qZYRqXEovzpYVQ3uFpo1i7YZQv3586cpQW9Wl92/XGaZ6DK5db4/LTmyIrGqcHwELc4sm+ncJESUhoL1FBqurFpP6t0F7QvCjFdwFlqsQWn5MkxWzrtMtyCgJu4yhFmm45onbpXnb1EsWxosa1WBtIaaEwFWvBZUC5uIFdLqDusYVaEqQusXvV7+TOfOk+BYNe2+XYi88mOolIeAT2/ghElwNrOoepnlWR3n84xhmQ6i9fVb3F2N064dkSmzCj8eB3Jr9CDNle7Wd7swD052P9GncBmoDMPM+DTP3/NJtmw8onKZmwi5Fw2kioqOohiGlocFbu1UtxDSPVSeOXqU4TFHLJv14FYN7xVe2i0stcixabXUNViwWJV3a4hKFLNmihdTwifCKDzpUYZHC0zahywtiK19VIDpRMiNu80rJZaj9fsAtBjWTjUMO92ua7Xw7BnwSOqYmpVu2+A6Mbzblxv3fIdly7CAMgxjiA4CYamJb5ZMfgGVXL/80sMsVqtlZmztIJZxgxUCq9LrQc0KcG38uRmgEo1ZyqbJ2aM7LMaVZpfs3cyztPCtFRmvKu5IbbqHCgRag1QiwFJTn2GlmanI6m+W+HWMaCVuHZlW3da5i1TWrFCDHtVmsxmAloMlQTWTXQWKp0kUVSHgf+kd8MfsnJj2XEfcCoTw2ktoRfvtUeMeEqsiq1wZAq1+f6uKzOJdPV2CkxSS59cPVnokXVfccdWv+HmS/iVY+2XYw4q2RTWqQoe7w7QZhhaYtTPrZQ3JcuJHH1hH/7DhdcxFl4w7/5dJa9pp2OdWg8s42yuNisXyoyctb1ayUtZJBXAmhItpdYSFlEItJlH/xIvroNcfd3/+dkevvvKvWEv3RdMaND0DmMW0Nr1oebNyLdXErnCi0RkWD7aLWJ1x64/fvn79fId/7HZZi1e1whRt91FYVRmzerpFZXi2X5jIV8bWDVZ9LAWUkMo1EtJ1Aaz7T/fOrVevVT3WVsUb7rJyjkixWQd39HILzTJNekBjrhOFqxesSK44up4ULoL16etvd/tXvPds072qkiosKqa1kcZBxPK4utNCWJNs/ck1HovesCDobXTlNm3mHhb8x86t2t7ICbcmosCy6b7hA8069KFFZsVa7VSq6yeTvmVYGrtEMNui6m1nMMv915/vKKdqulTSt5ttGdlpUGFlxDocDo933WiNHtKEujAWPc0qLau5jq9owRhgebd0uHupinQbWa8HqXUnXAcgBaxWh45uxbAmqldQeOiER68yLMsScSlk8zpdWwsyhgWViFpVyzTZk/WglKASC6rw4HF1oxVgtXQJA5tVloKq1Dmvp8fjXG1yCSxPqwpuKbVUMxol1maz4XTHqRBjyz2+dKE1ejgPCYyyhzs7wgJSZUlfkuyisrSGBVi+g6jiFWGVqEW0glgqsCCywK1OKe9gRY1CWnxcfwuB1xkWc4IncTWa3YgjNRAKFtGqlrl90ciqWCzMduAEo1NueViZOmOFBJvF1QXWCM2CzEJmx1SxOOafDCxPCzjV0GApXoXZdGepCh1X9GBYqw65hWYlrGwJmktvsxAXSEWtRGnnRtN6GVjgVpXZkpEVYdUa7oeN9srBWt2cWzmzJtqsuBi7Z9Y3gCU1SJXIlqXtRA4Wp3yyHoxQ8RZWCCsK9kDLfXcrLQ9rkYZ5kCgN+K5mMSxGFqqR7Kqj+IJLBAtzq1qmPYPdwrK9aJgHoQLJrMOtuQVmJYjgXOgiNN9MBoClHHOUyriz5+g6xrDAragOw3KwkPWNFCEtcgQVksLr6TZaZFb7KZR6Z5aDNfbv/ir5UqoqlGqsfYuq6jGBhbRyN1PNPFgYs6QAV+HwxG7LLQernU/4brHAi79O+phV+3Os1QpVidkPvKivd5cUVkRLbnpVIlZh58GDqkGsQjpXb7f18lSGhtWCSjBAmqjrortZY4+pRrESwUqFS6mVgWVpFYlaG7V8Pti8Ikj0ZXXjnAhmLfQ5YVDqqYDql1ke1jjQMry4Eo/Y53PY58yiDsJsM5gGy/buB91fHYhVGDek/Oi7AWN1khqkn6FYPc1CYgxprHDRUsi2qVlYwa1CZ9aGOyyn1SFaO4cGS+N6W51ucGv0fTGxXlnBFgttFz/vCsvfLGVa4NhYcCGyY62v3rA8rOBW6LA20jUUei3Im1hhKgyk4Pp29arawbJjop43Ot0n8rNFD1j0MVBAyrHSuPx3ZoKEamyBxbQKfTdHljgFpxUvni0qKcM3h8qN1ZX3qhWsiSq/JsKmYPpf/bsrrJI+6hftGktdcoJFRXlsNYtpFXaJYzZGD3bxvDJinUgsr9bpykqMzGqUPnSNqPkfTjrC2qcfkFyOpSxrnfiyOfFrGyykpefBTaEXz9E8uJJ+VInlI4vduoJWBGvSLK4ZA8ESZPi1DGVZcpNRtpoFtEzPYBpRnALtrowpQc4sxHX6ckUlOlgN+nQBk9arh1l7OrLAalWTXJXtZqFbUS9qbk4c1EYyLQkF1xtVIMXW++mKSiSzCFdDlwy5ZjCz8NPYWqjpyMce9gwscMvcdi4MqDiwbIPlig9JrQDW6XLKs1lGL/u0SdB1N2vvxhgeltWeQOFnO2F/AW7V58zCfqsw97z0grAt3FEsZPUORXg6gVsXaOnMaoSOMo1/1ah/1nSHxQcz4xPJ7eUznsSzs2ZRJRZF1LdT9W3OouLGwU2GDta7w3aJFpnVhPJrDJ7G/gwf/cxiu1gxOeGo4aAPfPefnHwelneL2lHdim7OspIqpHHy4/39Ii0d8E2sUfhBNAv0gIVA9qKXyMWo8M8QwMce+uMSLMotuxq02wwZrzwqYYW0PKwLtDwsB6KhSxNUEoKNqVP4TVdY2RFwuVHTQ8ZFWOBWYe7Qm3VzbpHDnTtOhG/vPNbvp3O0Rt+bhlGFcmzEpsY84cegsOzwRYiVCI8rYHm3HjniDxu7MarMsmqFxDoJqbW7nnOLYZFYGlljZsfmw8w6P66ABbSCVXb/KrCKpsFQgGTWybFar8/RElgtgkXNF3zpDOvV/c+/wtk2kl+91lfA8q+xeTQNVnTXK+MV8joRrTcQy7t1WrfT8rCm7rDEwhFCKyRZD1ivROsVTz7CU48Hjj3942vMgtx6DHtYuRoM+wzgFdegEwraBjDrtPZne245WFODa5EyW1hinc16JRpBL4WIkfkTBn7zch2sT/d/3lVKLLMzGtL9zezMYLxLuK9JrnWrW6Pv0ymgmvqvLQOLk89FH1ivTIUhAROtGP8S/+XrlbA+3VMl4vbVJocq6q5wInS03kLCr5lW9p1cDhZyimuxaTLJz5r1MUtXnsYkHMUtP16uhoW0HKeVeQVI3GCtQsC/265BxPIpn/3kCjZrinKdI7YI0HqZJVwUMEtIf3ctLKjEx41e56R3clCslXglWgGkdzrWbZUIsIDV9KJbIfS7wopNujxerof16SvQStbPqh19W0WstFlrMWvrjhwthBWAYX41TWt+NU0/WFcRen2h8+UWWOiWbbHS2xOrRKt3UYpTfutwZWgFWOQWxDxNkPkkW0y7wnrZnyUEpx9Myz/55wZYQCu8SkZe0hDFO+z5ua7hzXglgYVjkqHlYT1PY2DypSX3hzbrhVGFg8S6ySyitUn7dtW4UzNKvZUmpVk5uVJaDtYzY9K0zrLqCusl8QiBvITn8iMef90Ei93KRLtZ5mSLkONq61vTHK3R92ej1tRY1UiG6THtAYvNoZMtwrrjIlTjn9vMIlq5lbPak1G5rkgJLjdmp+02peVhAa7nJkn6WLJesO4BFvIJGW4jKgL18o87bjTLDaAVrQdDWtEsqHCZuNqiXOstDttvEayp8at5bkI3kavHHma9hHKTQE8oMSl33A4rdSvpGUJgSXvlzi2H1RaKMXWLyjCuxQSUUqyzWVJsJphSTMypo1mf7kdIK4DSeaXbqzWtCY1ZAsqPn5qWg/X8jLQI2rT5nyR+nldXs15UQOkyNJg0KT86wLK01B7y6i1e5di2fcsZvyW9ttv/83Z+PY3kWBSHpdkkZBtlHjYtQr9UlaCkliXUKGuIZClRKQ8QbQlU+f7fZe17/edel9MTXMlWMmmGHqTh1+ceHx9XB0FpASxnW7XV19uyb161TxTZBv9OEkHq2vLHFv7JejsnQ4t2ok5Ze8fKVDOfetEzjd+Ki8rL6pcR1urxMdCa/DSoGC+trC6o641RsmIbAovO3n8PiMqj0srKei8GT4tW7vuervYrlkYBlMe12uEgBm15ZcFLZ4B1b5yTw1UP8iyAlRBWwBNe6LXIfOMKoPXxYW9Y2//nY7+PhtDPn98PkhFU9lXpy7v85CfoarnUcqqJvKzfL98It8BsAKweKfvqTCpoatuYR45nMW3t9dOdOn+QLJrK7ZvVhrq7sayNMNrCBDH52SEqa/PE6Ol+0UsMX08Ea+ul5fhwVTX6uch+S5TxP6/hFhm8FQssa0+ncPUZzyCbQ60tYXBpYKq4/of53xgjLFRWR5TFokScU/NgbWOHsoMXJpCBgscAWCNDC6Koze57X7f7JOpZbbyugrLEBqdQCVGYe2xGZm+4tLyctpZ8FD2wN6+vXFhbMn3bSFRJVEOUhdr6cJEU7pQBTh9hCtnFSCnrWRqVVlZr1sTxj5+1QQW4nLaiWXzju+xBytoGUfE49Z4gBdcQWIbWB4mjENo/yAjS/TOCoroCezdjKIq2ba///e3bz87pCrVFvQscfslBwcdDYPUiQkpSICoANgjWhZtER2tF94Mstq+YtysrK41KGGKFxnV9ff2XhtWhtGqnrbAq8j2QP9sYMIY9Ub0fGsATKIvR6jUNn/EySMYQdWXsSr8abcH1WHeIy0qrphvr5VsoI2qyCcqHFRC9p43KU8KrWgx9g7Bvek2047fHzSAxrE/r7DwyWF2Z0CBUIdQv7VpFWxQaWW0Gsevq9CxaeXGvz4S15VuZ9yglbPkAGlTDYRlaRlQmv/ePU10rs+EJSxhXN7TEpoA5dNJq2zeqrc5vrP0vxMLsJObCOjx7yCpSVnUCZekEoWkZZe0/UVurz55fRbJyjmWEZUSlgRlVaZEhrSWZRKetlKgGKiusfO9pT2cj2FTVcFigLXunzH7fWwXjAssqC0htQFqgKGGYASzU1rKjq2LtaHmNLUM1mA8r7VV9XBWwak4Cy2gLItZ+7/srnq74MiiU3RQKq6y2LdzVIi3CqrZPjwsF9rY8jbKSsgJM20hWp/Asq61Pcwix/4zWwY2vGryyhN0/Y2wwBl+wy2srTlxdWBxJjljWA2AxaTV+DWxIDnWiAlwngWW0Ze/s49vBOLe7rgG2hPphrp0A14IRLITo06ptogdp9TY/g5WVSFXc1wOuxWney91M4iqxErLcDnvnYFdGWIBMGVYQTAtM823NJtE3gh1fGHE9PAmsHiSNaFv5+TulsqxvOVR7XvWtIllZUgBIuCn0w4jawry1rLl18YrLfmIgrKb/oFbVBFQng4W+FUh5Wa2ItVtZbUBROikQQu6DHX46sSZ6YFxay2GwGp4XmjgveGWdFhbSYstgcPcI6FJiAAASE0lEQVRQNIBZaWIGijP3yOJ3zuUJrM6VzXXweEttAKwmmr8tD1aoqSYM4uKEPwmG0Nq4jMWmUOAiuAFdCcQUxhA/2rXpNbGrvXeBdXVuHLNhNdtD80eiFVGWlCeEZXyLnTvTgAUrILRX2I3iI9JUAVtEKy3UVnShprrwSz0EVjKruxXQ6coP4UmVBdpiLXLQlYIO2ccrE0VVawaxcN6lGDNVJGjV4eiH9Db5sJreZpmJinECaZ0UltfWph+wbCVj94PWs4qIkGiDifV2PmRx7IysrMByYTmv2vZUZXn5LHoeWJggrFWtwrmzcr0oqqpVrfAzVxR9ajuBnU1bp/eJ/mCxyx9Db+69FFr5dEVRyZPDsrT4aWrQFZbIkBsEiiteCp2yIKQWpN86FCKWy2xYyW6hYcHKfSBPbvDBt1jZ/mjrmLAOqp6tk2URgykw1Z/6XdM1saN53hlYPqwmHkNnV02wdmlFBR/cXZ78x9AirfhAFVVlHZ0aFqyJ7Y6jcwkfsrzRFdv+kI4rX1l/RuUEFSZRympx+p9w7GgBscfQyeB2MK0sl0a9siyuVAfhZQXtc6ayFgcmkGwGvbSke9ydHtbI0lIrUrmbGVT+ZCINrGWDCKPo+61+5HLOlQVruqj6siKJoUFhyWBYAGt6clhWWyt+kANHXgJ9XbXUrLyiRG8Qd3rpJNpKKmwArMQEelQkZUmUl4F1hh9ib7QFth4OCKEYRc+yWaFVTFHCK4poS7TK561umR7GHFij74skqortcGSQlQEm5d3NGWBdXFxqWuSGBhhCJURR9MOooFGLwCpsM6hh/a5TsAYoa3T1r2jLTLbNTUDlE5a9ZuNzwLrw2jLhARq+X86wqDfxrNUzMnCuonD9Fjh6F81jFqzLBeHkHcuLSpIBNJqytMrZ5ehstADW4wZEFQ4Hv3IplyDImuiP+FFdWbB+zMLWpgp7G/2AkSNRFJFZXPOr88BC34JbioATFsi0wHJBVJiQJeKkhToT9ouifmuosi4AVt/VUVmNdJx8aLDXmUzL0wKbh+8bTijcrKVVJrCDUNGqyPstrqw8WOOblLHTnkHa5EAcS8r1mUwLaYGqrLebUewzOpRQhbctVFbc2HjHz4KFEb6i5UKvkeETKM86h4GWu5lB4bGXlY7oc1IJXm59DLT43qfOh1Vxw/Lbm/QMlrIszxNLKS17WI8nN2n9GMcSETIVBhG+OJxVW2SWWBas0XRBW74qLvuca+EQVo7WGefQ+ZaAATTDJBIxQdjaPSEx5feJqqDniR3ND3nKurzbVtGpoI+fvpIJU1jio6zm30dnpaVshSASXV+UT6nAqMUXzuxs3iJxq8tT1uWC1XxEYBVtsIhflRLm8P580gJaQrV2Z6iK/jYwlA5t6t9cA4Fx9rfb+Xh95SlLZwfaWjWVbLysnLhoHnXKktX5LN7Ran2PwDCFIot8NqjLHZbZSWT9lh/DPGXp7CCdR5HkwHVFUFla8szSsi4P37Ld8YiCHUf/IT8UeMBvx9in086ZVpc9hpPpXRXvnoOkYAL9QljapRCe5VmlBbR+qVan0h1fDnloJ5m+JTUgftIBM0YftYF5yhpdLXp6on0Mze0WF8Bay7vZOaUF+0TjW5jgRTJOaY8SCXIicHL7xIL3W5ljqB2+Cmc4TcTLSUwGwypRWmtZnnNBdLTghiIRO1PUv8M2sWDBwX+NzhgC/4bBG0mlmbAuftykMrskyyBPWGBZa7kuy7tzdQ+EljL3qhX+kEuIY7Y+9r4kP5IGF79/KxcWmJYvZWQ4wmH5ypKynoUKO7PHO1pws7vpinHLp0Xy94cXCXi+gxgwhmBatDqWdPtMAlYp0aykxEEsy/V6Pj0/LfNtKvVoJol2ovE+cRcXhIwV3lH5O/hWLqzLWWxU9JCQ0iq9sNC5jG1Nzktrgr7lTriCHSlCSdBKXvGzV8G0Ze8NzIZlkhbt2yUVVkwKJ3FtnuXaDOLsanTxf/EtkEbRMvOmdbP4w3F13G91+bDMCY+MhSXjUqaM10KYQzkfQGs0Gn3F5TFdujrB16RhZVQpz1dMWf4em1xYbA5lhAuAlfxhRLWG14chtEaX08sjaYW8hSIr4v1PwuEVKylYvzVAWaPxTcRKVgd0FeI7sCo1rTKX1uTqdn6c5QEtPIaAb3f3x9OK5G+LqA3MhgVzSJo+CwpRVSEyBFpISssLXvNojae3t0+3t8fS+qUK51voUja779KpQSSaU8heeJ44AJYO8bKJ+/aoRi5tYCDCkmvgZWh9H39Zzfe3T/o6ntaj/jYdrSMbeUFKVbelBnVpbWXD0uvhXcOPJ6SkrEpuWWYpRHWtgdZ6Ppt+7Qc4ji41q5enp5eX2+Mm0SQIE0ahaFbpLgvVJZzszG/6/yDut+p8WKMrHeJlQxJDf/ccRGWVVeIUmqt8mN9ffSFwjb/Pb180K8PreG35xKQOnYmlT1zdEPrLZPl8WBc/ZjJq26XXVhmCu9/nrO2KuMYLbP5ocenVd377+voE18vr8bR22G/tFHekHasf1CF7xzICnprWAFi4P/TZiuqqlL0toZtBMCyA9fCg4+n99yNwjUbjqZWV1hX88vQFl29dhEjeDn+wDPSoXK3fXufD0n/YMj4frDgrNolrqiszhlpb2rlmf4drNBlPjaxeYALx+fTyhUmENlCIg86+a/HgJ/xFDOHvfRC+5jJvzfJtwNt43Nw5s5L9ZZBpStplkPPS6jJGr4dxMjosqqv7+e0zyOn1+cldL1/xrfZw5dD7GwShq+f7b+N6Q2CZ6kGy4C57wd0qax1CVgRLPzUuPY3j3j5G72zGl05Uz0/P1t2f3CAeTcv0UiSR28r5byZyJ4IcbYgYAuticnMXWneuLRm1DTSUMlRw3Rle0++X4/FkMjLXZDIZj6+m9zON6vn55fnFXd6zvkgLd9M75TpRyKnh6HB3jIu1g2Bpacn+zTJS0sAQMkOIWLgYPoTnw8Prej6fGWT6mpqX2b3mdKvn75nCeqIm/3Kky0/ifmsnxIGB3P0psKpBsLRrrdlJDstYss/K03pAXERcmtfD66vOBHO87m7/197V9CaOBNGwBGEmCkJIOEKcMHK0QpbQ+GD3wVLfkfj/f2e7+rOqus0ANtFqEq82yaz2sPvy6vWrV9VG1OrPtcGqtlA9xq3efCti1SVRnn6LcFgZgjENnDrw8qNoBcUqUswCpEoQfKF/BpD0F8CKVKEVLf1DfTu3rudbUXtYRXcxBjNLqVZxOHCl8k0hyxu0d0d1iLCy3DLwCA0T/KFtMVwn83cg1l3cYvlWVbGCO/uUSx+HPqzp/N2xgcxS1MpTviF4d9cT0irUSAWsZCkMVsJ8hQJ030WoQouVF632PpVn+Rbuf7reKH5MZukDMZVgFThywNTCCi8tVE6yNECGX74EqcC3vgI9v+7QLZRv7aveCuzzYoOZpai1OjR8WcYNc5zJgkBZUktqqWXx0lhZ5QI2aVJ5yBy1Tr4K2xOqxdvRwvlWmE2fk1JvDD3ZxRnMrJc5dIimv4FqLIjAG+cOKZYsUljJcBKWZW2p5bEKAo+5RY7DO9H6VOrel2+lr9hhyl0Gg/Xy8Us2h4KOCaPD0Hc7xGVJxCwNmAh41eFAbJFsBY+FEbvHb/F8i3Gq613jGl6GEItvi0NTsAm0mxK63F2yXocB5cAKSAl7KCaYdWqxwt/rt+yQiwcQfA0Crwg6CIeDBc60cYYh2IUQY7kmOnCrRJJFkcJw+aclttSTCjGrvT2x+cT5VnrNpkfqx2AWRDUWLdoRNrglbJLdDvZYlFmWXbVxDgnNailcj+VbzKKfA6vQ6k3g2AhgvSzeVSFagMyiLUlmcPRexL5B4m4nwIUf5LSQuj+k8nG+db4i9mc8uR6FWVCIBW6g4fvBTVYbHzdwzZJMtIwjLSmzrH8P5gEz61G0XL7V4bvT1R9s1kjMgkIsDiwZtUVImRVpFrWk2DtY6yA8Wix3iAzE4/lWxUuyS1rVkZg1VydiOAllg6Y5wV/hxMEplkMMkaoMx6EXeSZaqKNmaL3d3Ccav/Vp7iCevfPq2FUxvBFRdaOABaPiLZpQSLcEQjxDiP1KKVO+oceUuk46xDRO3eNSvGNCdtH78tH+FtEwshzRVSOBNQfZKhBeZPZFAuUS5zOo16FFaMtQJJl1aoPTah9Ay+VbnX/9n4GrSvsHN3sci1latkjgwEK/okfc0VmITsOa+Cx2HBIbT587slOUL8f51vnCOFaNySzjH2B32zHLjSh46OfR4k10KYi8Y8B0qhXxqk0YiMfzra7q3ZZ3ujUeWDBzDWZUaxaqQ4nSGdwUBoUX1Gfh3tAUYU3L8JQowkH5Fr2+Eu1MjlmGGq28CdkM7gm5yXIpKZH4kjY7tBRRtOzrMMksjVZ2o251aLvvfGWSuB+dWeq3tcsLnMzwsU7BipD7d1KIdbI3JMRK2Yfb0YLOpwqJzYV2h1qviN8aOGRN7E9tnV41XNujrpCGMyU/CyOhJ3FpGwxEohJXt+9v0XyrZ4/SBPKqDKejvlsO0DJWq0li5aYU/iiUUatjoaprFjxQT4rz0rgS83s2knC+1XGnFe75jA2WQctcaYK/Ghl5Uq9WVxTLwcVki4wtyFgs5tZtl8+yK/lWdDRWY4Ol0dKGlJ6EEtt3pFgso4m8Q8JnOWaRyXQbNz43/W/xfOvaNjP4rMnLqM98sttawUo5UjoCI71OD7FSHv7PzFrduCQX51vn3rcDKrDGvkezALSkkXncQIc+Giv8NWax7rDFVovMpaMucXn7zTOSb/kbKuHlBej9LF21Gf3S0fzj11YSVkWtDmdW1BcGWmHNQvlf29sdAla7O27pxftbFdetyjFrfLBAt3JrSMNeJNOsMNyh1KJ4mWF+GzstNmltqV7t7tqCDvkW9aM8n7+MaeAjlZcS2Xgi8bKkXbRHill4wRKtOHlIlODy3ht62dTfT6zsx/LAzxcSCyr2/R5b3x1ab7kxWqV1EQVLsiQ17wnvQJvD1IEYpha2IFuzanp3rSi0rN+CzzGi40R/GVZht37SPcmP9xxEvpTR8gxay5LJmWHiLAzMYkENppVZE1lNH7jLaKav5h75J+SmlVuUtDmXNvlPqUI7el2Z7rDEK1ncOkhmSvt8ViJZpi7LbZk+eAHbvPUHADt3x+6otBzsRNiG1xH05mkXcOeLiTkUrbYXkkwqJG116lRvGKjV+jKkIk/j5Rbk6tFrW6DynXt3ML2/ad4fcpw99WUnH2+5kEVBAmW278fNQ8lNVp/Ae3lvUUiavz/+u9d+qzOvsKEpvN3jmq2ferN7nk1XW1WGDq2SRMpsN6ukDt5zq7cMww6g+bbMd4PegaDzLfPpMu4dbdU+vPPoMnvyGxbAzecNGYKVvdNV6uB9CYq0wLPFNh00ZIM/EfCoDddlb1/C5d6VpP7B+XnqjgeKK1AuvVnLh2DSrd5a8xAx69rw8GRFy9JquRuuKIvp5viphz1ddzzqt/8YAVN2dPaavTz/WUzeVtuyARfhFmeSAU3Zw6xoxBNymlNtLqm0Il8NpZX9b93M9r/trOe815+GCHVZzdbTr8DKwJWL0otWgdRd9galxGiJVAJ4EgYpEPa3yVjzvNfZWctWePa/j/+8ZvOXL3oWIPSluTTXo1oRs5KTQ8otDVXdKmEf8deeTdf6rrCWLv31c7b5KlqZX9j84321DPfAPKd6NatGTqsvATydhFDWapwKxEf4Zvbv0b5JdzbbrL+QVki6cjq5v+azBK5AMrIIkiXq8aEycE1e1xv9rF+nky+Hypw1Ci4U/PHWsExrVjzDd3CJZf4EqEwlLLJskmWJW31fVoyGXTJK30WsWXUqKiXMWj4Nqv/LA9oVtF57L5s3hHEYmRtquPQlHrvwoKklalV/Stb/ZqjMyaivptalbKRbCHGpgyDxn2hxCRrkNFLCkGrxt0NlqvFjqvGSOpZx8QxCy2+V+mtiUI3KqgOCLSA1yb4DUgSvrbYSNbpsWCYyeCCU8lOaW8Cpt+k3QsrhpW9AA2CWXLWguXJtL7IKW4MA1E5xavHdoPKGRhFspRADWkkMV+0WQ+D8g5vA6l97n35XoJCjmb7rS/Y5YMYaRGCTvpY/zb45UKQmgWQ7hRl5dj8wXaPZQr/PQeGTLfQLHn5A+Xl+np/n53nC8x/tAMljWkeBnAAAAABJRU5ErkJggg==`;

  // src/icons/meteor.ts
  var meteor_default = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZsAAAGbCAMAAAAlRs3KAAAC/VBMVEUAAAB1gdddWs6cq+JsadRdXalLTJhFRXtTU415iNhOTo5+pe41NXxjYM8qKmscHGuRn+MSGZl0ovJ3eL6EqPEXF19QUcFdnfNlctZZmvNvc9prbdaMsPA1NoYkJHFdXdFSg+08ReFMO9VVTdg3k/Vdk/BHSL1bXac+mPVDlvQcIqFKcupJlfQvL3lRculLS404ivJLRNw9P7dHkPIoKHQ/lPQpLapPm/RGRohmlvF0oPCBg7pFPt4UFFBOQ9AkKag0OK9Ie+04PLJYT9ZeYLtJRsc4OH9LXOE/TuIrL64kJG9dZ+EVHJxDZudFgu5AXuZHk/NHjfE9PMA2OLVQfOtLd+tQjfBrbLZ7fbFGdOs8d+1Dj/JCK9hPT49Jk/JqnvJaVc4jI3EXHptRTclVUcxOS8dUQdhNQ91SO9pZUdBLRt5WR9UgIGlLScVYU80YGFJXTNJGRcMbG1tDfO1BXOVDeexSPttJR8RVRNZDV+MUFEVTUMohIW5BaOhCcuqkoe9Eh+9DgO5CQcBCdetAX+VHT+FCbelBZedPQdxBaulITeBJS99GUeFFU+JAYeZYTtEdHWBKSd8XF04WFkseHmNCWeQTE0JEVeISEj94a+49Pr1WStRQP9xAQL5FivBCb+lFj/IfH2YZGVVBY+YaGlhGlvNEhO4VFUk5O7tGkvNFjPEPDzoRET0tMLDCv/02OLgwM7IqLa00NrZaVM8cIqAcHF4kKagyNbQhJqVCWuQODjVGmvQnK6tEQsIKCi0dHW1MR8tQSsuAcfUYGGmrqPNiXd97bfFKSN9hXNFNS9CvrPQGBiMFDJMTE2ZIRMhfWtsVG6NFRc0/QMfIxf9AlvQICFxQTtUoJ3lpZNU5OcCbmOw0NJrRzv8ZHopoYONcV9UwL4ampPAPFpgSElRRTcJEQacwMbo6Oq1WU9g8PLM+jvIVFV0dIamBfeAoKpM3cOsnKrOOi+ZJSNE7g+9GM9s4VuU7OqJ0cNo1e+83aOlyZ+q7uPkyX+gzT+RLR7VJUHVbAAAAYHRSTlMACZEcgRAaYFcjjy+3ib/zE9xhVFP2lmouhmk/Q3XcXEv+/bL+qGNK9d7Vq8yjfzb+2a2k7em8saKagj/++dCljvvGnHfp0r7s6s2b7u3z3b7u6NrO8+HPcNr59ujU+LDlSLXNAAApKklEQVR42uzYPU7EMBAF4IlQftZEASkNTdxSRdtssdK2aIvcYu4xd5vCtUvEdRACaSRgvSlINsLvu8LzjJ9NAAAAAAAAAAAAAAAAAJCzsjoNbhzd0FcVwXZUjTt7/uInVz8RbMLe+fAqLMIfhDnGw1gXBLfWtxqUv9Gg55eS4Jb2owb+VQhdQ3A79SEIX6I8YLHdjAvKCRLaHa2prO77pq6b/qnK/FSUY+Ar4rSntVS18wdVEVHVw3loMo6naCNfpX6dcIrno5coLHbdvU1uT3myaJKC39HiiuEcflx8IoG7njJUWjRpsStoYc2kKvwLERl3lJuyDTxTGGlR1VGVLxH1uTX5wqK5Lja0oJNX4QRVRzmxhTaH+pIW8/ygnCaxzej31aKZJwy0lMaiuUynbAqbNbSZ1N+RWW1qjHSZTM7n1GxicCyaK7TL4iFqDW0+nQoy6y00E3MoBIloEuKJzB9Gs5WyuAmJhZYSj2RWXGhG/SP9b+/s2rFrE1EcB/BLbFqjRcWaUBTtIOgkhVKkIARRU1G3OOgiRK635QXO5YY7EO4vyNCp4FBwTWiE6OLjkOsQAhHhCCYli4iTEezk0MXna8jvJeba9L0neSl+h66v8Mn39969O9oaHptVGGqSW/N/qgENV5zPi+OhgTiJY317Qwaa4/DhNK7/C5r/xWFpSPhsno6JBuItn9COa8hAc2jGfxhgaY7PUS0yfeHixYsX4rEIV2u4cfyVsdM892c1dXPp2t1U2sWmiTPp1KOFeQ4aXhxvVioN1+/DUfYYHVu4qiPTMNB+rBZOJy8dgeZ7zhHAcWaltobP5rmiQ23hqoWQ8SeoG8vCZnJ+dJqcCI43K5OGt7yXNQUzf9WkMAM4Fn68MDKNEI6/Io+Gu7yNFU29TKWRbUAAB5k4GRuZhsUZw8MFtIbTxl/VlEvU1EmG4ZDgpfhhNGcojVBzGnOSaHxn4F9Q5QUsVyJ3EZEJx7Ey04fTiOJ4i1JoNoGGA8dZVuwVWyRKaSiOibH5N465FNPCM00HmiCOv3pOSms2yfI5fpyzatlEooZOY2GMstVq1nRdNIDjJg9szWZOGMe/IYeGLn9cbLo0tuEav3Zqe6XS3pfdJt5AAzgLB9FsiuP4JyXQdP8PJzdEZwJnWiSq2zahMY0ftaDdDkjI35dN19T7cDLxkIFGaYRxnOWYOE1iHZbnw/GuKPTVAKUhOLi63W6XemkHOwizOOhVNOzwTGDEceqnJAw0SkPDu+XUn2nKhNKQ4GaJyDAJ2tvI7WvORnzoQPu6vi4Bxzkbl9QaseY01HmDQ2jW1oCmL+0vlmkADmpFhw60dRJxnPqKRJrhe86E3dlQGoKD9BrQAM7uRt9pLRVGI47jLcflDTRYnmPXu6WpkUjUXqPBu0ADCYKmy+LguWEDTQpOY0ZOa0Sb41zR1EiPBlVLAZCwU81EDE5rarA1XwsFKTj+rDBNBZYO23Mm6IOBHo39EWrDhoBVsQE47v2/aaTgeA8FHypmEgV2ae7TmuOr8cV6JLrWjW7XgtLQtH+0DAYnHWMHGqWRgeMkFgVbQ2hIxJvjryrxdENo8vk8tTGqpTCbHYwYnPT0QGsAh4YPxxO9gJ6pVOB3wbfnwGdYCoTSdHHQrzCbYNuwDMDJnGBpKhXAEWiOVxelSVToyjSHNWcCXt5QGrAJwmz28qYBOK0LDM0LsBFojnhrTia+04UlNKeuQm0ITTab3w/0JsQGcFrnGZoXgMPRHIk0FVhZbM+p39DGH0oDOEa4Tc224GWbtXGaoeHDkb7XkNbAyjS8zfGvKPBRZySaz2YB56CzwEsDbAyUOQc01IYbRz7N6M0JvdFT4EqAtobFse3tMJtdVzcg6WmGhrc5kml663LuOUAzo409PRrACX32DJpYBxwzBTQCOHJpCoAjdFqrK3DJCTSA86EZcmdT05EOOO4USyM01uDwHL8+lVy6eXMpOTW3yEVT4GiOou8GgIbB+bjTHmrzi9QGcNAcpXkNMiLN8RK3tNi125lO5325WCy/7XzaunMvfhSaF4RmdJz+KEgDrenD+VDdC4beChg6g5Pap3ktBccrPJlPPtjaKr7bIin+SbnTeXD70hFpOJvjTAJNtzjw+MlONMvWAQc/6tIADv9Yy+W+Vd/8fPfmzTuwKZbL79+Wb8ePMtC4m6MazW/q7i60rTIOA7jzC4coykBkIkIHE7zTCxH82Jh6oezOC28U0iaZ69YmSy/WkQwCvfKuNSkhzZaLhsIJJCH9yloObWhCEtO07KwV1i5zSVNbt+Iy7CgtdFD8vydJ/yc5zTnp+5529ZmgF2rAn89z3ryJFgdNpnO7+MefNTTP0pNAs4vT/u1bx77nfISGvTn91zfn/x0OD0NKOKjz+LsPG6PBF6VrzpGiwdbshbP47M8/pF8XsNssQIM4t19+4c2/fD5NcHqbH94bDkNEnOrqDI1PvK9OMzDQg32lfOb8H2jKs5bO/vEn8JS+BPWsaOy0Vdk8+vFNzkcywDxrvQtr8/5w2aZ21kh13lFtzUAEwtico0ODg1ZHJza1SL46CHlWKJomjTYI0tzVdbiIDHtzgMY/74eIOvJZg9z5RJUG/41gaM4RocHWwC2NzQbX0DIcg9GiTy9CdO0WI/w5UhxDa7PbZzaz4xAaD9CQgExJpTJriHNWedAilbpGmJpzxGgMeoMOANLkD2pwIDZjO/wy2gwQm0TH8GjJbYYo4kQawiGt8ZRoBsfCnslOb3gsNCTD+UClNTIcqhuCo0RjiKWL61k7JLteTMdMMhyDJGhjE+5bzT60UXjmqH2eEyE0HoIzFo4Jue2+vr7tXGvXUAhnjdjc+uhYXRrJxQTVM+do0uhtRXsmkShAEomMfctmk+GY9sIRVq2cWQzrrEWaPUADCY915uLxeIoEfi+Eh6qfOXfeqTdovg4MxawdUZpYej2TsO8mkVlP61VxII9WOaDRAqenQuMP5+Pxvt2k4n2WGpzxd/emwdZQz1rb0aPRL9oz9qpksoCjNmsGYZWzmqU21Efpjt3W+JPxVJ808XgMcbA4dQYNQ3GUPkI0lcOzcbFQosGAlU5t1oDGijQszZHS5HZLg9WZqmrOxHfH5TQ+pGF55hwVmt1BW7TjniHOusGkhCPSuBwOdpzys8br9SJNNU7KOzSGOHhUQ5ov/8LXY5q1/wMN4GzFdAqzVqZBHPpZg9bc9pIgTXXiyZC0OLc+kdPg6zHO2lGgeWGXpoA00iSyOkNdHJshWaZhb85AhcaPNLU4Fun7nIkfjslpSNhmDWle/fybs2fOnDl78l2mr/xq3xrE2cLjgGzWhFW3y+xgxyGt8ZZpPEhTayOExhBnKPReFY2jTKM6a+o4/3z2wntnz52fXV5uaWlZXp49f+6s6uX3IdKgTTFWz8aUXHW5nSIM66zBoM15uxRpwGY7PCi9IDhd3ZrSq7HPWn/P0o9nWpZnWzCzyy2f4uONMeyDhqOGV2tVOmUapzqOenN8zV6ggSjRwGnAEpJcfA6+X0ODOAyz1t/b9mAcClMTsPoUekoRptYY67cGUsimDbq9cIDGDTSIQz9rvuswaITGo0ADgfc4ks9zHp+WDJrDJ4Z11qA0zS13UKRKp+UNbQFoBw1t7GnbXja6Mg2EddYGoDVdIo0XaBRtQpKPDO6cxNaUaRhmDSK2ZgFp9qgO5amAfdDUbVBnJLfqDgILOw60pkLjTwKNig3iQG+QBl6tnP3OGuoATf8DlNlL56PXXzj4HFOmwSRw0zCkNcGgk+PAhXXWzNe7gIbEnwcaRZupkORj6rH3cdDMZsShn7VeFRrAOS+/jdCexiQbNNWzAGYkuRogNBrg+K5PTpVoPMZUSpEGzgKDYQnOaWyNrKc0OL29QKOS2bdf0UaAnQbP0NLAoAUDnBjWWYPWTFssoo03p1abbenH1KGxEyUavAOnnzWkUcU5q5EBO02hsKiX2eRWAwHOakUc6uaY2yanJi0WyyTWRsEmPyjBCf3wFqFxIg1Lc5BGFecEOwALDSaxjpOGgybSEBzGWTNfF2kIjvrTJtU3OexHnMFz2BoNcJBGJcvyj1y1p9Gn1WkKeNdZNWjWUhhnzdEGg1ZOA5MmjEm/ffP4ZTkNztp+j9I9PUijVhx8z3tgrVGiwc8I9Cb5oFVo2GYt4myzAE3FxrKdUqbp8w77EWcwdBxOaEizn+bIcZBGPctv47ucA2rNYiM0WVPtATq5yiMNy6xFHIQGbdqVbVJxI9QGcULvwLPGii9EP2tI02hx8ELigAYtq06TwM+kcdACPMpQzhrSYLztfSlFmm7SGrT5+8RrX3IOBwWObNaQpsHifMoAoE5jMGUz6q2xp2O1g7YT4F0uF5iwzpqz3zLd2dmJvencTinRtI75PR7UGZ7/mePwhVhmDWkaHrXjGpIgjWGkVJuiOk1CTpNccfNWF+JQzxrQdE5bOiH4vMmllFpDaCQ48/cDVocY5lnriCANw6ix07SKNvrFQqHhQcPk871RVymMs0aOAUQGbSa9ybhCa8JAgzjhe8M+l0MM86xFkKZhmxe1t3nxSmsrwTHp1zMUg6bLLUXdLi1wuH7L3RIN6nhaU/VphokL4njmm4MOCFNzaFsDNue0b00MaAiOLW0vqNJga3DRgrwbcehnjevtvNvejjj4wFGkQZy5J0HOqYajfvFJRwP56BWtWxPrbi3h6LcS+xg0vA9ojrohzDhcP6GR4Xjz8XqDJn41CnHmN61WfBmGZw7NoJGc1/gdzhvXusFGTKyoYpPJ4qBhbXYCAWLDOmswaEAjx4F3n/G9aUBGajO/5nA7IezNEVvz/G3eaOqGoE2jNBhhAWqDOLRHaVdPu0gjx8HbTllrpDhza76gE8KO09EBNM/f5mTTlStXKjqx9USjg4bJr7h4AsM4a1Z41hiNdXAMqbiMxi/CoM480rDNWmSA0Dx/m/e+7VawUWgNJnk/GgiCC9usuXo7HxmN9XC8xu24pDogpfd7u9BGbI054IQwNwdpnu9Z4N2PbwBNSQc3raETGr63aYsGg5Q4SBMhNAo4k0JfvLRsqVQ8lbSEvV0QxCE0+CIUzUGaAQoa7c/Qx7+6fKOCQ3RiW4kGBw0j2Dg+CGGZNZ+1hwyaEk6X1yjkwAV8tgWjx0NkEKdMQ43DSqP9e8+Xvmq6AZHY4PsbtUFDG/hoAG3omuPqWYHW1MOpXHp6J42t+XyrsQtkKtmlcQCNFjh0g6b9nc2ppsuXoTiS5sTWM/ugwceNGGocd2Tlkd5YDwd1KhRlF8QBGt7KaYHjG3jwmAJF87vOF5tuXK7BiS0mCo0OGt7XkOIwzJoLaIx6NRzMZFdVyjRWLXB8Phoa7T8jONl07bIYyaxdweKotQYvBWZkNvtqjrsHWgNRwrFUpcZm7qEzYIWw4xCa0ZZR6kn7QKsjWtO1a3KcWN6eaYgGbdqiAcChnbXSoJHQNufpGkdaw44jDtroKDXOslYn6Le+unBNhgM6U2nEQRq9rq6N0E9sqGct2EFo6HG8T9ecQKMFjtgaCNCMPteTwKkmsJE3h+BkMwU7JpFZ1wFNfZu2GZChnbUgtoZu1uawNYw4ZjPQiKGQ0fI7UKc3rl2oh2MoFjLlI0EhkbEXbUBTP8nrxIZy1gIdK4INTKib8/Qh0rDhmKE142Uaqlmb/VAbmhNNFyByHFHnylS6mC1kIAl7tqiLmXRKyS3M8CBDNWswaHmbjQHn6ZoVaZhwoDX/Ak05FDiz32j1sLl4oZQ9cbpjsdbFrWKxuLVo0ht0ykkuRcGGCicQARoxlDhzQIN/fxYch/nBxPj4+CjhoXrmLJ/RaNG+birJ1Js1wjMVg98M0Bk1m01iQzNr4qBBaJvTNedxAo0WOA7SGhKszT5ptPrPCD7YuHi1Hg5efJKM6FQj7PBgQ4ETGAAag4Ee5/YU+QYJOw6hefLvrVslnHGaWZt9+yWN3tn8dPGiCg6kjKOqkzc54BC931kjrbERGgacu0u826UBjs/hABpIVXMQh4KGOqeARhmnu8Hm4MXAvpvDw6ABDAPO9Fow4HKx4/icZZqa5hCZ0UOmeXnjopgLGs1abnOG57E4DTXHyfv0QMOE87QfFo0FB2n+nhBlKjiYQ6Y5DosGYZ81HDUuyvP7m7WAzwY0TDjTcP/tZsLB1kxMAA7RwebgiYCChnrRNq5eBRgNZy25BMUpyTR4Q8APrCRNBgoctOmEg4DbzY5DWjNUtsFZk5ykD5HmA6ABHC1nTVjhowSn0aM0x5uBxkSDgzrTm4GAmx2HcwLNEOBgc2TPnMOiOd508yqJprOWg+Jgc1RnjTfbBJMYBpy7C1AbJhykQRxsDoaChnbRblbhXNBi1gQTV8LhG5k13getEcMwa1MWM+9mxnECTQhtZM3B4hwCzYmNX28eAE5udSaKzVGetSgMGv6/b2hxpjeBhhWHIzQhxKnTHMA5BJpjH9/8tQan4RsCJZ2R0nGgkdMaDBrQMONML4ENIw6hGQyVcBSeOXgiUKRhf2vzKwRw0EbttAZpoDl5IVLBkdtI//mRQdOhjRwH0gjOdFvUzYhj5Z7cAxqSKpu9bggOnub1jV9+QRwtj9Km5IgDcFRPa1EH0FTC8syZ8kWD1DhIM1iFU/+0Br8Uadhz6otf9okDaRTHxmFz6uFEyaBh6GdtysvxQSYcq/XJveFBxFE5rbUcMM17QENwUAdxKqE9SgOOYUD5meNyR3tNhAZDPWvTay4+CKHGITT4A3QaeeaMKtOw1wZycLOWb1Y8rfHRhTzSsM3a9EM32lDglGnABiK1kTUHZUYPkObkhihzcLMmJDcDoLP3m9BA1LqZFEw6DMusTT8Mgg01jtv6ZD4s+7Fg6qe1g6J56+MvLl1CHFFH2xsCUz6nX+BBJ1A7ayDDL6zk8kDDjIM21Dgu631Co4gDkeFoToO1uURs2GdNKUJyp5mfmameNT4aDbTtJAUdhnXWxOcNBQ7S1PxYMLkNNgeCpzWk0bI2QCPH0fricySZ3FnyRWdmohCeB5aZqCuytCMk4a/TDifWxUUDlDhu6/05f5ikweagDrZG07z8xe/EpnbWtL/4HBGS+dX7S70+zh10Wc29C5sr+aQwgnOmxawZY75ogA6HtMbvV8BROa2NIo1mtfn9t0sUzaH8mDon5E2GlZ0VmwmocMy0aw7cCwRocCo0aKN0kpaf1pBGu5z8j717i42iCuMAvmu9gEUliAgCYuOFKOIFFFEeVEQF7wQvqC+u8fbQ2tCChLoQWi4Nd9gtZUNSSguhwK4BTCi4abdt9oFsmq5tI7tp+mDDA21NA00JBBIwfrPd9ut2Zs45c3pWZqbnM9EXn/jl+8/Z7xvOZO3ZAzjpjjXk+Rvqzz/hX/g/i+ycWAfYcOAESttb9gMNoXOIE4I00IxffG7PIA7GmpjBJ73E48TgtjYOHB/SHDXyzEGaZ4BGdNts2wY253Q75yeeWBNvw4zTkOMJGcbxJmig0IYaa9g5SCP6abMtgSPwmSO4jOJ0xRv9RnH8CRrEIXxhVz0hwEAT3TZbt0EJjbVvbm+sxTqDQYM4fp9CgziGT2sXnhkvnMb54tatAziYawYHn9g6Ap85/IPPhkhFox9x6IPPqgDQ4OU3HM+cCxBowmtG1lbEocfaL5aItS58R56pc/wKDdqocMiDT6QRXI9nbQIbu8VaDBqHHccfaO8r2484Rw11DhQGmsiamrVpEwmHfZ9jqljr+jcY8rPGmtI1RWVKccZaM3aNyHo/YWO/WOuCF0gYOwdo+gbvvsFij7UL6aGZvHiTUsZi7QcLxNqvXRVsOIlAK0rScMVaMwaa0Loza/t2Ag518GmOWNPCieV4Gv0MOMEETZFKB4oJp7pnHnaNyHK+u2k74AzY2CrWulYXUHGQhqVztBvn9TR9d+ix7TvARq9zfjRrrDHirPBSYy3ku9ZXWwRFaBzi4LMaaQTXW1k7EIfyzLFerHXlnCbj+ELezgSNSocVpyZtNGMX71BsNGLtnFlna0YGnzm7YvFQSBen1B+qgI8dYqljjTL4RBrxdeetHUohjqJjjcEnW+d819Ve2ggLai0cfyjQUd+HMmoc+uBTPA2eBHbs2wc26lizzT6noSsn7ged4TgB+Gnq7o5Ea2uLiDpHSac1pBFfU4EGbNSxZqN9Ts6urn87vCGINsQBmGCBqzMSwYuJSI+c/XqxNgdphNdzWWsAx7Kxxjr43NWV057tCYYGK+itaC8Dmf6q5Y211x1Qd89cfu/82bPn37v8+btFRtrH+9YATmqs2XHw+X1DLLa6s70j7q6ocMU72q8VRSL1q3WvkVSnmlas9cInOxdMn/1SuKnO7XK565rCL82e/rywHzdroIbh2HLwqbxDADyxSEN9fUMkEoshDAGHPCHofXvszHFhVxhcBsoddtWNG+MUM+a8NYCDsWbPwSfgKJX8r8bFREZj7eTF/V+8Ew67VBUOj1sgItI+XLMXaEZJrBm6HZc2vjlz4veOkiY3kgxtnqbpI7fJXLx3717eWLPYhIADhzQhOHoifjrb5QYcLZ2mcXeP+JR2td8GasDG/rGmi0OxgUKcthPx3dluKJd2hR99fqQ/PK/+sXdY51hy8Pm/x1rb0Xhedjbg6OrU1T04ski7unKlFo5d9zmiYi1JQ8EJzxyJzcO3VgIOxhppQmDXWFvBcVpra4vnVSRsSLHmfmAkz5x3oW+Gdc4Oq8bad6I6h44DNJUlFYijpxO+38kfaR/uBRp1rNl5nyMg1lrbXJUlYEPvnPP38r9pe3UjyKhizdb7HO5YQ5r98crdJVBUHEi1ydwn6FsbEadfx9KDz5/TGmvYNbn9H8ivoMda02zuOefKjVo4dt/njCTWoGtc3rzdKhzdRw7nr5yMxTvBxlisnVN1Du/FRCKL/2IitGHrnNYylwe+uQY2bLHWNJ/PZsJKsEntnFE2+DQca61Fbm8eFDNOHZyj+QY2OxEHCmzk4FM71pCm4HDys8UqHG2d81zTAeenYKPqnNG0zzGEk6SpPJzE2c2GU8d1Gpi8duNONc4aGWt6R+lobXZBZSUBR9PmUSfPyvPWoUM7d8pYY+2c1la3LxdsjHVOXZxnz/ba1UODONg5cp+jjVNW2+oqzYVixMG6h8NmVrFiQ4k1sLHti+zGJgR9HT5PLh1HbTOdx2ZncbEaxx77HOFH6bKWa74qsDHeOU1jeAadYFM8PNbkPkcTpyxaVunzeNQ4p6njm/OLjNvMWAs0KbFmj8FnWmKttiXu93oRx0CsnV/OMYS+WazCoU4ILBRrQjunpbOqwMuKk6pTx3EWePXm2kTnYKzJwacuTl/cX+VNxTlMirURngW+LAYbaqzZ/0V2lliL7vf4qgCHI9bcrjEcC4Ita9U49trnCDuttVwKwp0qup2zm3AgqHtprPEFwYdAM6gjJwREnGgJ2KhwQIc++Ky7n2NBULyFG8d+FxORcaJlXn8B4kCxHwjC8zkWBGu3bFHZyH2OJg58HixQoBTHM+f8Aj6bLTLWmHDg7k/lXhWeWAu/5+SwublFjSP3OZo4kXioFIon1sLTeRZrN4CGFmvyRfb+r1G6Qj6w4Yg19wMZHBd0frZ2M9BwxZo9LybSx1kdzQ75+HC4Xh6cXL55cyqOHHzq4UQVG8CBMoiTXHo6M2c+BTU1g9HmxmbESdrIfY4KBzPNx9M5D42BP+lFcxb+3n9PxJJ5kx68i24z7SbQqDsnFUe+yA46/TaBAAfO4emOGXPO9Jw8VXMKZOBOolM9PfMWjaUupG+Wp+Lc9sGniWMtFm8MqHCog8+S0/EvFv7Wm3KvNPicXTKJ0jtTboDNsFiz5z5HwOAzdkn5XovBWDtdcunoxZMa961VNy+cSd4Q3ChPxbH94HMEnQPf2A0CjqFYy8vubNO8kR3q7AekXahz1rry8nKzxZpZ9zk5K6pCfr+hWDtccbKVcI1k8xz9ccFds9YBzrDOkfscPZyIG2yMxFplRWcr8UMTgEPoG8AZbbHGjRNrDwXpOLjPqdzd2Ur+0ATg6I4FZt1QcDDW5OCThFMfLVAah/WZk1sCNLTbcZvf0Pt589nldQZxRvXgMwa3gCMOZfCZm+gaGk71t1MJNpRYky+yI06kqBQah+2Z48nrbKV+aALq7Dxtm4lvKjYy1hhwsHGCTLEGNC1s3zJoXqRjU76BgiNfZB+KUx/NRRxSrHkTNEw41Us0z2oT3ly3AXBSYk3uc0g4sU7lU7G0WKusqgQa1u/nnJ2ha8PQObZ8kZ2vc+CjICFqrFXlJmmYOqdnoa5NKo7c55BxcmDiGSTFGuAUAI2BG9lreibr2hiNtdF9MVF9xNVIjrVSD9Aw38gO1fyIpg3ApHaO3OdQcWJxQqx5vAHoGmMfmqiZ49Q6p21YNQTHjINPE8Zafazd3wg2mjil/uzuFqYb2RGnZt5d2jbDcOQ+h+WZ03061KgRayDj6aiNst3IjjZnl2Xq2CDOaBx88p3WIrF2TyMkW2Aojs8fLIh399WWGf3QRM3JRzRsPlJszB5rJtznrKiP1bfn+RsbgwPBFgiGArkgE9W+Nor4zDl1cpHGPE2xMdo58mKiRIFOd0e2xx9MlL+qJN5e1tKif98a4WuHBJvbH2sWPEpD5URikSL4toFS17pX9PWtqCXfv6qDAzaPaNi8+RXAII4cfBrCgaqPJKs+Sru6WD/WapY8qLbJ+PRy/lAcEww+LbXPGdGN7IhTszBDbeOcuwpsUnDkPiftN7KrP0Wp9fvGOSs/P3+VjLXb8qEJ7Jzq+xyaNlBmizXrTAgoOKxf2G2eqmUzF220Yk2+yC7g6mJq5/y2bLzme51fIQ5b58iLicidw3FaOzVJ+33o6yCTEmtyn5PmWFPj1CzQtHntcorNaB183oZYQ5veOTrXCyg2xFgz0eDToqc12uCzd4G2TaaSaagjB5+icehf2O3Ve7FzcmFhfr45Ys3iL7IjjLEv7J5ZlqFncyQFxxSDT4s+czhjbclU3auGluarcKDkhEB0rOmlWu9TDr1yfn69ECq/kPGZIy8mEnuU7r2P9JcKEzagUmimWLPohMBwrPVOIt5nU5iofhk5+PwfYw2KTOOYciRpo/xjxsGnjfc5F8k0jgmFgKMba/JF9jTuc6BryDXtypEBHJPFmg0nBIM6SEMq55dHAGcg1+TgM/04ycJAIxyiwWZIrMl9TpoHn0hDr2evII7qtCZfZBfdOUjDUK9dXw82ZjmtWf9FdmqsIQ21HruyfhDHPINPC7/IzhBrF+9wMNW0A0dScArNNSGw4ovslM7BrqGV81lonCE4cp+TbhzsGmrNhb4Z3jlmiDW77nOQhl5PKn2DOHKfk97TGgQae028DjKqzpH7HNGxhl3DXpmJvmF75siLiUYw+EQa5sqAw4Be58gX2QXGGtKw1xSwGcAx6+DTHrGGNMw2Bw4kbcw0IbDhi+xtSMMcah9p4kDJfY7IWMOuYS/n0gOIQ37myIuJOHCQhqNevTKAY64Jga32ORBoPPUw2PTjmHNCYPFYQxqOmrZ0vQ6O3OcIeuYADWd9otCY8rRmk31O230O3npy/fEhOHKfI3rwydM1OFIDG8SR+xxhncNPg2+sHzhO7xxrxJrp9jk5GGh8ofaCYmOK05rtLiZCGr6acOX4EByT73OsdZTGQOOs8S8cPA5F6Bw5+OSINaQZaaglcEw7IbDmPgcDjb8efuHgQYw1uc8RE2tCaByZTys2AzpynyMm1oqARkC98k8Sx6wTAgvucwTROCZAqPWfB0wxIbBDrLUKonGMXQqNQ+0ceTERO07RHQ5RNVexOWj205p1Bp/QNcJqIoRaAsc0EwKTz9bInVMkkMbhfBoah9Y58mIixs6pBRqBNSXROCY/rVlk8CmYxjHta0XGVKc1q77ILo4Gf+IcG8SR+xzOZw7SCK3H/jmWxNEffMqLieixBjTCK+NpwGF75siLifRxxNLgwPMYdo52rMmLiWixFkUakTX+5YNJHDn45OscpBFeUyDUCDimusHDnPscpBFdmS8rNqTTmryYSAMnzTR4jKZ1jjnvWzPHhCCdNI6JTxxLlAUmBCYcfKaVxuH85K+EjekmBFaItXTR4DT6v/bOoLWJKIjjs6wKYRHKGojRBZMYpSEhWEIIhuAlhxZKbQUVRNCbeBRE6EWoWBXRjyClICnYq8dc9CRePO2n2IuHNNBAC07WrjGmJumyu5l5O79D6P3HzJvM//WldZLKkYvsg8pBNSFTcv7IIZ/nkLrI/uUUhA0WTuvIjeQ50xGRGmTNbo1WDpMbn7NbfH4JvaF5hdNiM60RyXPCrxpvVEM5NKc1qnkOqomGZL7lyZE8ZyqwoUVF7Y8cyXNIVQ2SqLY8OQTzHHKLz6+oJjqu256cKfOcOF9kx6qJEr3a8uRInkNLDUA678lhnudM2hAwa2h95gr2kRzJc2hVDWLlWyesHPQSv4eJUM0MqLmFw2lD4DfPYacGu5prhuGG4KRtjZ0agJTX1STPoaYGtJLX1STPIaYGwPAKR/Icamq8LzmjlcPoBY9p5XBTA4BdbUxbo/PGZxB5DjM1YM23W8SntcAeJmKmBruaPSRnYIdRnjPtKM1MDc5qrhxZfNJTA2DMt1EOww2BrzyHlZr+N9DfciTPIacGoGK3pa3RVAN66bccyXPIqXGPHFcOxTwn+IvsrNQA1G1Xjo88R72HiYipcY8cptOar8UnJzWgF1AO+Q1BYLs1TmoAjGrbb+Wo9DARRTUAmXlXjup5zp/FJyM1/bigjbDNc056kZ2TGnceQGKc5/wgqwa02kDOuIvsqv7CLt2qQfRa2/eZw/9hIsJV0ydRaiPxzHOIq+mnoKgmlotP8moAkiiH64bAV57D4azxMFEO3cVn8G2NTdW4chRpa9NuCBipAUj15TDNc3wtPnk0tDFytqm0teDzHDZV48pBM2TynJAvsn/mpQblcJ3WfFxkZ6bmt5x45Dns1ExROUw2BJPk4Gsb/EA5MchznjSBIyhH+Tzne/M0sMS0Vc9zck0NmGJV20rnOTmOZ42HscYiz/G5+Mzxm9D+JlGzZ57nhHSRfX3hEvBGu5JXYvE5Iie3cBHYU6/y3BCMv8i+fuM8KECmao/KobIh8NnWHjV1UALLvY7L47+ppxulmU8Bf2PUbJYbguPznPVHuQugDlra5rwhGJKznruhwBTwN2bB9lM59PKcx3uXE6AYRinPcVr7t3Ier18F9dCv5G32ec7eZcX62aCvHclh+yL7XvMMKIpes21fZw6Rh4nYb2nGoaUKNvVp7T8PE6GapnJDwDBGZbRyXKjnOWoXzRFYOn6mtRkvPveaSuzPJmHgwMZsQ7B3Q6VNwKTS4ZTnfMgtKzuejaKn5202eY6y32n+h4XjNIsNQWMhNu1sgFnK2/TynHfDchoLZxUfnI9Hr1fzn3xUTnQPEzUay7E049pJVx2601qjEbeDZhgD7XwiuSH41rh8DmJO344d0rTmf0PwLbsYgzXAZBLpap7WtJbNXs6wvUwbeO0UHIdKnvMKzVwUMwP0esHZJpHnZJfiPQEch2auOc7Mf2E3u1CO7dQ8Di1Z23acGf7CbnZp8cIcCMdjpQvXnN3JeU4Ybe390rI0swmtrfLg2m7ki8/s+0VpZlNgpGo4tkX1gge6Oeyuls/LZDb1UF26tu1E0da63e5S8ZIiF8+jwkpX7ne2tsL9hd3u4cqyKce/r+ZWubXb2QhpWusebi4Wk1IxvjEy6dLNrQ4WUIAbgo+b3c3u6u0LspcJoHzSdzc6G52dnQDynM3Nj4eHK8VyUrwExFzCrKztbnX20Y3PPAfNPD84eP56sVg3ZFoOGiOTeli6vbOxs7//4oS7tTcHb96+WV0tXsgYIISFZqXK6dLdmy/2nz7dwY8xZ87rt73eW/w4WFm5d6VcTso8FglzifNmvVKsoCMsnWc/h+j1egc99PPyzp3bxeJy3UqcFy3RoxtGBqlfR6544N/1DHLR0OXAnykaYljJZNI0zVQqhZ/4tzWnaeJFEARBEARBEARBEARBEARBEARBEASBMr8ADJvUZ0bGgJQAAAAASUVORK5CYII=`;

  // src/adapters/here.ts
  var import_core = __toESM(require_build(), 1);

  // ../../node_modules/base58-js/base58_chars.mjs
  var base58_chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  var base58_chars_default = base58_chars;

  // ../../node_modules/base58-js/base58_to_binary.mjs
  function base58_to_binary(base58String) {
    if (!base58String || typeof base58String !== "string")
      throw new Error(`Expected base58 string but got \u201C${base58String}\u201D`);
    if (base58String.match(/[IOl0]/gmu))
      throw new Error(
        `Invalid base58 character \u201C${base58String.match(/[IOl0]/gmu)}\u201D`
      );
    const lz = base58String.match(/^1+/gmu);
    const psz = lz ? lz[0].length : 0;
    const size = (base58String.length - psz) * (Math.log(58) / Math.log(256)) + 1 >>> 0;
    return new Uint8Array([
      ...new Uint8Array(psz),
      ...base58String.match(/.{1}/gmu).map((i) => base58_chars_default.indexOf(i)).reduce((acc, i) => {
        acc = acc.map((j) => {
          const x = j * 58 + i;
          i = x >> 8;
          return x;
        });
        return acc;
      }, new Uint8Array(size)).reverse().filter(
        /* @__PURE__ */ ((lastValue) => (value) => (
          // @ts-ignore
          lastValue = lastValue || value
        ))(false)
      )
    ]);
  }
  var base58_to_binary_default = base58_to_binary;

  // ../../node_modules/base58-js/create_base58_map.mjs
  var create_base58_map = () => {
    const base58M = Array(256).fill(-1);
    for (let i = 0; i < base58_chars_default.length; ++i)
      base58M[base58_chars_default.charCodeAt(i)] = i;
    return base58M;
  };
  var create_base58_map_default = create_base58_map;

  // ../../node_modules/base58-js/binary_to_base58.mjs
  var base58Map = create_base58_map_default();
  function binary_to_base58(uint8array) {
    const result = [];
    for (const byte of uint8array) {
      let carry = byte;
      for (let j = 0; j < result.length; ++j) {
        const x = (base58Map[result[j]] << 8) + carry;
        result[j] = base58_chars_default.charCodeAt(x % 58);
        carry = x / 58 | 0;
      }
      while (carry) {
        result.push(base58_chars_default.charCodeAt(carry % 58));
        carry = carry / 58 | 0;
      }
    }
    for (const byte of uint8array)
      if (byte) break;
      else result.push("1".charCodeAt(0));
    result.reverse();
    return String.fromCharCode(...result);
  }
  var binary_to_base58_default = binary_to_base58;

  // src/utils/utils.ts
  var import_base64_js = __toESM(require_base64_js(), 1);
  var keyFromString = (key) => base58_to_binary_default(
    key.includes(":") ? (() => {
      const [curve, keyPart] = key.split(":");
      if (curve !== "ed25519") {
        throw new Error(`Unsupported curve: ${curve}`);
      }
      return keyPart;
    })() : key
  );
  function fromBase64(base64) {
    return (0, import_base64_js.toByteArray)(base64);
  }

  // src/utils/actionToWalletSelector.ts
  var mapActionForWalletSelector = (action) => {
    const type = action.type;
    switch (type) {
      case "CreateAccount":
        return action;
      case "DeployContract": {
        return { type, params: { code: fromBase64(action.codeBase64) } };
      }
      case "FunctionCall": {
        return {
          type,
          params: {
            methodName: action.methodName,
            args: action.argsBase64 ? fromBase64(action.argsBase64) : action.args,
            gas: action.gas,
            deposit: action.deposit
          }
        };
      }
      case "Transfer": {
        return { type, params: { deposit: action.deposit } };
      }
      case "Stake": {
        return {
          type,
          params: { stake: action.stake, publicKey: action.publicKey }
        };
      }
      case "AddKey": {
        return {
          type,
          params: {
            publicKey: action.publicKey,
            accessKey: action.accessKey
          }
        };
      }
      case "DeleteKey": {
        return { type, params: { publicKey: action.publicKey } };
      }
      case "DeleteAccount": {
        return { type, params: { beneficiaryId: action.beneficiaryId } };
      }
      default:
        throw new Error("Invalid action type");
    }
  };

  // src/adapters/here.ts
  function createHereAdapter() {
    return {
      async signIn({ networkId, contractId, publicKey }) {
        const here = await import_core.HereWallet.connect({ networkId });
        const accountId = await here.signIn({ contractId });
        const key = await here.authStorage.getKey(networkId, accountId);
        return {
          state: {
            accountId,
            privateKey: key.toString(),
            networkId
          }
        };
      },
      async sendTransactions({ state, transactions }) {
        if (!state?.accountId) {
          throw new Error("Not signed in");
        }
        const wallet = await import_core.HereWallet.connect({ networkId: state?.networkId });
        try {
          const response = await wallet.signAndSendTransactions({
            transactions: transactions.map(
              ({ signerId, receiverId, actions }) => {
                if (signerId && signerId !== state.accountId) {
                  throw new Error("Invalid signer");
                }
                return {
                  signerId: state.accountId,
                  receiverId,
                  actions: actions.map(mapActionForWalletSelector)
                };
              }
            )
          });
          return { outcomes: response };
        } catch (error) {
          console.log(error);
          throw new Error(error);
        }
      }
    };
  }

  // ../../node_modules/borsh/lib/esm/types.js
  var integers = ["u8", "u16", "u32", "u64", "u128", "i8", "i16", "i32", "i64", "i128", "f32", "f64"];

  // ../../node_modules/borsh/lib/esm/buffer.js
  var EncodeBuffer = (
    /** @class */
    function() {
      function EncodeBuffer2() {
        this.offset = 0;
        this.buffer_size = 256;
        this.buffer = new ArrayBuffer(this.buffer_size);
        this.view = new DataView(this.buffer);
      }
      EncodeBuffer2.prototype.resize_if_necessary = function(needed_space) {
        if (this.buffer_size - this.offset < needed_space) {
          this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
          var new_buffer = new ArrayBuffer(this.buffer_size);
          new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
          this.buffer = new_buffer;
          this.view = new DataView(new_buffer);
        }
      };
      EncodeBuffer2.prototype.get_used_buffer = function() {
        return new Uint8Array(this.buffer).slice(0, this.offset);
      };
      EncodeBuffer2.prototype.store_value = function(value, type) {
        var bSize = type.substring(1);
        var size = parseInt(bSize) / 8;
        this.resize_if_necessary(size);
        var toCall = type[0] === "f" ? "setFloat".concat(bSize) : type[0] === "i" ? "setInt".concat(bSize) : "setUint".concat(bSize);
        this.view[toCall](this.offset, value, true);
        this.offset += size;
      };
      EncodeBuffer2.prototype.store_bytes = function(from) {
        this.resize_if_necessary(from.length);
        new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
        this.offset += from.length;
      };
      return EncodeBuffer2;
    }()
  );
  var DecodeBuffer = (
    /** @class */
    function() {
      function DecodeBuffer2(buf) {
        this.offset = 0;
        this.buffer_size = buf.length;
        this.buffer = new ArrayBuffer(buf.length);
        new Uint8Array(this.buffer).set(buf);
        this.view = new DataView(this.buffer);
      }
      DecodeBuffer2.prototype.assert_enough_buffer = function(size) {
        if (this.offset + size > this.buffer.byteLength) {
          throw new Error("Error in schema, the buffer is smaller than expected");
        }
      };
      DecodeBuffer2.prototype.consume_value = function(type) {
        var bSize = type.substring(1);
        var size = parseInt(bSize) / 8;
        this.assert_enough_buffer(size);
        var toCall = type[0] === "f" ? "getFloat".concat(bSize) : type[0] === "i" ? "getInt".concat(bSize) : "getUint".concat(bSize);
        var ret = this.view[toCall](this.offset, true);
        this.offset += size;
        return ret;
      };
      DecodeBuffer2.prototype.consume_bytes = function(size) {
        this.assert_enough_buffer(size);
        var ret = this.buffer.slice(this.offset, this.offset + size);
        this.offset += size;
        return ret;
      };
      return DecodeBuffer2;
    }()
  );

  // ../../node_modules/borsh/lib/esm/utils.js
  var __extends = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  function isArrayLike(value) {
    return Array.isArray(value) || !!value && typeof value === "object" && "length" in value && typeof value.length === "number" && (value.length === 0 || value.length > 0 && value.length - 1 in value);
  }
  function expect_type(value, type, fieldPath) {
    if (typeof value !== type) {
      throw new Error("Expected ".concat(type, " not ").concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
    }
  }
  function expect_bigint(value, fieldPath) {
    var basicType = ["number", "string", "bigint", "boolean"].includes(typeof value);
    var strObject = typeof value === "object" && value !== null && "toString" in value;
    if (!basicType && !strObject) {
      throw new Error("Expected bigint, number, boolean or string not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
    }
  }
  function expect_same_size(length, expected, fieldPath) {
    if (length !== expected) {
      throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join(".")));
    }
  }
  function expect_enum(value, fieldPath) {
    if (typeof value !== "object" || value === null) {
      throw new Error("Expected object not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
    }
  }
  var VALID_STRING_TYPES = integers.concat(["bool", "string"]);
  var VALID_OBJECT_KEYS = ["option", "enum", "array", "set", "map", "struct"];
  var ErrorSchema = (
    /** @class */
    function(_super) {
      __extends(ErrorSchema2, _super);
      function ErrorSchema2(schema, expected) {
        var message = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
        return _super.call(this, message) || this;
      }
      return ErrorSchema2;
    }(Error)
  );
  function validate_schema(schema) {
    if (typeof schema === "string" && VALID_STRING_TYPES.includes(schema)) {
      return;
    }
    if (schema && typeof schema === "object") {
      var keys = Object.keys(schema);
      if (keys.length === 1 && VALID_OBJECT_KEYS.includes(keys[0])) {
        var key = keys[0];
        if (key === "option")
          return validate_schema(schema[key]);
        if (key === "enum")
          return validate_enum_schema(schema[key]);
        if (key === "array")
          return validate_array_schema(schema[key]);
        if (key === "set")
          return validate_schema(schema[key]);
        if (key === "map")
          return validate_map_schema(schema[key]);
        if (key === "struct")
          return validate_struct_schema(schema[key]);
      }
    }
    throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(", ") + " or " + VALID_STRING_TYPES.join(", "));
  }
  function validate_enum_schema(schema) {
    if (!Array.isArray(schema))
      throw new ErrorSchema(schema, "Array");
    for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
      var sch = schema_1[_i];
      if (typeof sch !== "object" || !("struct" in sch)) {
        throw new Error('Missing "struct" key in enum schema');
      }
      if (typeof sch.struct !== "object" || Object.keys(sch.struct).length !== 1) {
        throw new Error('The "struct" in each enum must have a single key');
      }
      validate_schema({ struct: sch.struct });
    }
  }
  function validate_array_schema(schema) {
    if (typeof schema !== "object")
      throw new ErrorSchema(schema, "{ type, len? }");
    if (schema.len && typeof schema.len !== "number") {
      throw new Error("Invalid schema: ".concat(schema));
    }
    if ("type" in schema)
      return validate_schema(schema.type);
    throw new ErrorSchema(schema, "{ type, len? }");
  }
  function validate_map_schema(schema) {
    if (typeof schema === "object" && "key" in schema && "value" in schema) {
      validate_schema(schema.key);
      validate_schema(schema.value);
    } else {
      throw new ErrorSchema(schema, "{ key, value }");
    }
  }
  function validate_struct_schema(schema) {
    if (typeof schema !== "object")
      throw new ErrorSchema(schema, "object");
    for (var key in schema) {
      validate_schema(schema[key]);
    }
  }

  // ../../node_modules/borsh/lib/esm/serialize.js
  var BorshSerializer = (
    /** @class */
    function() {
      function BorshSerializer2(checkTypes) {
        this.encoded = new EncodeBuffer();
        this.fieldPath = ["value"];
        this.checkTypes = checkTypes;
      }
      BorshSerializer2.prototype.encode = function(value, schema) {
        this.encode_value(value, schema);
        return this.encoded.get_used_buffer();
      };
      BorshSerializer2.prototype.encode_value = function(value, schema) {
        if (typeof schema === "string") {
          if (integers.includes(schema))
            return this.encode_integer(value, schema);
          if (schema === "string")
            return this.encode_string(value);
          if (schema === "bool")
            return this.encode_boolean(value);
        }
        if (typeof schema === "object") {
          if ("option" in schema)
            return this.encode_option(value, schema);
          if ("enum" in schema)
            return this.encode_enum(value, schema);
          if ("array" in schema)
            return this.encode_array(value, schema);
          if ("set" in schema)
            return this.encode_set(value, schema);
          if ("map" in schema)
            return this.encode_map(value, schema);
          if ("struct" in schema)
            return this.encode_struct(value, schema);
        }
      };
      BorshSerializer2.prototype.encode_integer = function(value, schema) {
        var size = parseInt(schema.substring(1));
        if (size <= 32 || schema == "f64") {
          this.checkTypes && expect_type(value, "number", this.fieldPath);
          this.encoded.store_value(value, schema);
        } else {
          this.checkTypes && expect_bigint(value, this.fieldPath);
          this.encode_bigint(BigInt(value), size);
        }
      };
      BorshSerializer2.prototype.encode_bigint = function(value, size) {
        var buffer_len = size / 8;
        var buffer = new Uint8Array(buffer_len);
        for (var i = 0; i < buffer_len; i++) {
          buffer[i] = Number(value & BigInt(255));
          value = value >> BigInt(8);
        }
        this.encoded.store_bytes(new Uint8Array(buffer));
      };
      BorshSerializer2.prototype.encode_string = function(value) {
        this.checkTypes && expect_type(value, "string", this.fieldPath);
        var _value = value;
        var utf8Bytes = [];
        for (var i = 0; i < _value.length; i++) {
          var charCode = _value.charCodeAt(i);
          if (charCode < 128) {
            utf8Bytes.push(charCode);
          } else if (charCode < 2048) {
            utf8Bytes.push(192 | charCode >> 6, 128 | charCode & 63);
          } else if (charCode < 55296 || charCode >= 57344) {
            utf8Bytes.push(224 | charCode >> 12, 128 | charCode >> 6 & 63, 128 | charCode & 63);
          } else {
            i++;
            charCode = 65536 + ((charCode & 1023) << 10 | _value.charCodeAt(i) & 1023);
            utf8Bytes.push(240 | charCode >> 18, 128 | charCode >> 12 & 63, 128 | charCode >> 6 & 63, 128 | charCode & 63);
          }
        }
        this.encoded.store_value(utf8Bytes.length, "u32");
        this.encoded.store_bytes(new Uint8Array(utf8Bytes));
      };
      BorshSerializer2.prototype.encode_boolean = function(value) {
        this.checkTypes && expect_type(value, "boolean", this.fieldPath);
        this.encoded.store_value(value ? 1 : 0, "u8");
      };
      BorshSerializer2.prototype.encode_option = function(value, schema) {
        if (value === null || value === void 0) {
          this.encoded.store_value(0, "u8");
        } else {
          this.encoded.store_value(1, "u8");
          this.encode_value(value, schema.option);
        }
      };
      BorshSerializer2.prototype.encode_enum = function(value, schema) {
        this.checkTypes && expect_enum(value, this.fieldPath);
        var valueKey = Object.keys(value)[0];
        for (var i = 0; i < schema["enum"].length; i++) {
          var valueSchema = schema["enum"][i];
          if (valueKey === Object.keys(valueSchema.struct)[0]) {
            this.encoded.store_value(i, "u8");
            return this.encode_struct(value, valueSchema);
          }
        }
        throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join(".")));
      };
      BorshSerializer2.prototype.encode_array = function(value, schema) {
        if (isArrayLike(value))
          return this.encode_arraylike(value, schema);
        if (value instanceof ArrayBuffer)
          return this.encode_buffer(value, schema);
        throw new Error("Expected Array-like not ".concat(typeof value, "(").concat(value, ") at ").concat(this.fieldPath.join(".")));
      };
      BorshSerializer2.prototype.encode_arraylike = function(value, schema) {
        if (schema.array.len) {
          expect_same_size(value.length, schema.array.len, this.fieldPath);
        } else {
          this.encoded.store_value(value.length, "u32");
        }
        for (var i = 0; i < value.length; i++) {
          this.encode_value(value[i], schema.array.type);
        }
      };
      BorshSerializer2.prototype.encode_buffer = function(value, schema) {
        if (schema.array.len) {
          expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
        } else {
          this.encoded.store_value(value.byteLength, "u32");
        }
        this.encoded.store_bytes(new Uint8Array(value));
      };
      BorshSerializer2.prototype.encode_set = function(value, schema) {
        this.checkTypes && expect_type(value, "object", this.fieldPath);
        var isSet = value instanceof Set;
        var values = isSet ? Array.from(value.values()) : Object.values(value);
        this.encoded.store_value(values.length, "u32");
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
          var value_1 = values_1[_i];
          this.encode_value(value_1, schema.set);
        }
      };
      BorshSerializer2.prototype.encode_map = function(value, schema) {
        this.checkTypes && expect_type(value, "object", this.fieldPath);
        var isMap = value instanceof Map;
        var keys = isMap ? Array.from(value.keys()) : Object.keys(value);
        this.encoded.store_value(keys.length, "u32");
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          this.encode_value(key, schema.map.key);
          this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
        }
      };
      BorshSerializer2.prototype.encode_struct = function(value, schema) {
        this.checkTypes && expect_type(value, "object", this.fieldPath);
        for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
          var key = _a[_i];
          this.fieldPath.push(key);
          this.encode_value(value[key], schema.struct[key]);
          this.fieldPath.pop();
        }
      };
      return BorshSerializer2;
    }()
  );

  // ../../node_modules/borsh/lib/esm/deserialize.js
  var BorshDeserializer = (
    /** @class */
    function() {
      function BorshDeserializer2(bufferArray) {
        this.buffer = new DecodeBuffer(bufferArray);
      }
      BorshDeserializer2.prototype.decode = function(schema) {
        return this.decode_value(schema);
      };
      BorshDeserializer2.prototype.decode_value = function(schema) {
        if (typeof schema === "string") {
          if (integers.includes(schema))
            return this.decode_integer(schema);
          if (schema === "string")
            return this.decode_string();
          if (schema === "bool")
            return this.decode_boolean();
        }
        if (typeof schema === "object") {
          if ("option" in schema)
            return this.decode_option(schema);
          if ("enum" in schema)
            return this.decode_enum(schema);
          if ("array" in schema)
            return this.decode_array(schema);
          if ("set" in schema)
            return this.decode_set(schema);
          if ("map" in schema)
            return this.decode_map(schema);
          if ("struct" in schema)
            return this.decode_struct(schema);
        }
        throw new Error("Unsupported type: ".concat(schema));
      };
      BorshDeserializer2.prototype.decode_integer = function(schema) {
        var size = parseInt(schema.substring(1));
        if (size <= 32 || schema == "f64") {
          return this.buffer.consume_value(schema);
        }
        return this.decode_bigint(size, schema.startsWith("i"));
      };
      BorshDeserializer2.prototype.decode_bigint = function(size, signed) {
        if (signed === void 0) {
          signed = false;
        }
        var buffer_len = size / 8;
        var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
        var bits = buffer.reduceRight(function(r, x) {
          return r + x.toString(16).padStart(2, "0");
        }, "");
        if (signed && buffer[buffer_len - 1]) {
          return BigInt.asIntN(size, BigInt("0x".concat(bits)));
        }
        return BigInt("0x".concat(bits));
      };
      BorshDeserializer2.prototype.decode_string = function() {
        var len = this.decode_integer("u32");
        var buffer = new Uint8Array(this.buffer.consume_bytes(len));
        var codePoints = [];
        for (var i = 0; i < len; ++i) {
          var byte = buffer[i];
          if (byte < 128) {
            codePoints.push(byte);
          } else if (byte < 224) {
            codePoints.push((byte & 31) << 6 | buffer[++i] & 63);
          } else if (byte < 240) {
            codePoints.push((byte & 15) << 12 | (buffer[++i] & 63) << 6 | buffer[++i] & 63);
          } else {
            var codePoint = (byte & 7) << 18 | (buffer[++i] & 63) << 12 | (buffer[++i] & 63) << 6 | buffer[++i] & 63;
            codePoints.push(codePoint);
          }
        }
        return String.fromCodePoint.apply(String, codePoints);
      };
      BorshDeserializer2.prototype.decode_boolean = function() {
        return this.buffer.consume_value("u8") > 0;
      };
      BorshDeserializer2.prototype.decode_option = function(schema) {
        var option = this.buffer.consume_value("u8");
        if (option === 1) {
          return this.decode_value(schema.option);
        }
        if (option !== 0) {
          throw new Error("Invalid option ".concat(option));
        }
        return null;
      };
      BorshDeserializer2.prototype.decode_enum = function(schema) {
        var _a;
        var valueIndex = this.buffer.consume_value("u8");
        if (valueIndex > schema["enum"].length) {
          throw new Error("Enum option ".concat(valueIndex, " is not available"));
        }
        var struct = schema["enum"][valueIndex].struct;
        var key = Object.keys(struct)[0];
        return _a = {}, _a[key] = this.decode_value(struct[key]), _a;
      };
      BorshDeserializer2.prototype.decode_array = function(schema) {
        var result = [];
        var len = schema.array.len ? schema.array.len : this.decode_integer("u32");
        for (var i = 0; i < len; ++i) {
          result.push(this.decode_value(schema.array.type));
        }
        return result;
      };
      BorshDeserializer2.prototype.decode_set = function(schema) {
        var len = this.decode_integer("u32");
        var result = /* @__PURE__ */ new Set();
        for (var i = 0; i < len; ++i) {
          result.add(this.decode_value(schema.set));
        }
        return result;
      };
      BorshDeserializer2.prototype.decode_map = function(schema) {
        var len = this.decode_integer("u32");
        var result = /* @__PURE__ */ new Map();
        for (var i = 0; i < len; ++i) {
          var key = this.decode_value(schema.map.key);
          var value = this.decode_value(schema.map.value);
          result.set(key, value);
        }
        return result;
      };
      BorshDeserializer2.prototype.decode_struct = function(schema) {
        var result = {};
        for (var key in schema.struct) {
          result[key] = this.decode_value(schema.struct[key]);
        }
        return result;
      };
      return BorshDeserializer2;
    }()
  );

  // ../../node_modules/borsh/lib/esm/index.js
  function serialize(schema, value, validate) {
    if (validate === void 0) {
      validate = true;
    }
    if (validate)
      validate_schema(schema);
    var serializer = new BorshSerializer(validate);
    return serializer.encode(value, schema);
  }
  function deserialize(schema, buffer, validate) {
    if (validate === void 0) {
      validate = true;
    }
    if (validate)
      validate_schema(schema);
    var deserializer = new BorshDeserializer(buffer);
    return deserializer.decode(schema);
  }

  // src/utils/transaction.ts
  function mapTransaction(jsonTransaction) {
    return {
      signerId: jsonTransaction.signerId,
      publicKey: {
        ed25519Key: {
          data: keyFromString(jsonTransaction.publicKey)
        }
      },
      nonce: BigInt(jsonTransaction.nonce),
      receiverId: jsonTransaction.receiverId,
      blockHash: base58_to_binary_default(jsonTransaction.blockHash),
      actions: jsonTransaction.actions.map(mapActionForBorsh)
    };
  }
  function serializeTransaction(jsonTransaction) {
    const transaction = mapTransaction(jsonTransaction);
    return serialize(SCHEMA.Transaction, transaction);
  }
  function mapActionForBorsh(action) {
    switch (action.type) {
      case "CreateAccount": {
        return {
          createAccount: {}
        };
      }
      case "DeployContract": {
        return {
          deployContract: {
            code: fromBase64(action.codeBase64)
          }
        };
      }
      case "FunctionCall": {
        return {
          functionCall: {
            methodName: action.methodName,
            args: action.argsBase64 ? fromBase64(action.argsBase64) : Buffer.from(JSON.stringify(action.args)),
            gas: BigInt(action.gas),
            deposit: BigInt(action.deposit)
          }
        };
      }
      case "Transfer": {
        return {
          transfer: {
            deposit: BigInt(action.deposit)
          }
        };
      }
      case "Stake": {
        return {
          stake: {
            stake: BigInt(action.stake),
            publicKey: {
              ed25519Key: {
                data: keyFromString(action.publicKey)
              }
            }
          }
        };
      }
      case "AddKey": {
        return {
          addKey: {
            publicKey: {
              ed25519Key: {
                data: keyFromString(action.publicKey)
              }
            },
            accessKey: {
              nonce: BigInt(action.accessKey.nonce),
              permission: action.accessKey.permission === "FullAccess" ? { fullAccess: {} } : {
                functionCall: {
                  allowance: action.accessKey.allowance ? BigInt(action.accessKey.allowance) : null,
                  receiverId: action.accessKey.receiverId,
                  methodNames: action.accessKey.methodNames
                }
              }
            }
          }
        };
      }
      case "DeleteKey": {
        return {
          deleteKey: {
            publicKey: {
              ed25519Key: {
                data: keyFromString(action.publicKey)
              }
            }
          }
        };
      }
      case "DeleteAccount": {
        return {
          deleteAccount: {
            beneficiaryId: action.beneficiaryId
          }
        };
      }
      case "SignedDelegate": {
        return {
          signedDelegate: {
            delegateAction: mapActionForBorsh(action.delegateAction),
            signature: {
              ed25519Signature: base58_to_binary_default(action.signature)
            }
          }
        };
      }
      default: {
        throw new Error("Not implemented action: " + action.type);
      }
    }
  }
  var SCHEMA = new class BorshSchema {
    Ed25519Signature = {
      struct: {
        data: { array: { type: "u8", len: 64 } }
      }
    };
    Secp256k1Signature = {
      struct: {
        data: { array: { type: "u8", len: 65 } }
      }
    };
    Signature = {
      enum: [
        { struct: { ed25519Signature: this.Ed25519Signature } },
        { struct: { secp256k1Signature: this.Secp256k1Signature } }
      ]
    };
    Ed25519Data = {
      struct: {
        data: { array: { type: "u8", len: 32 } }
      }
    };
    Secp256k1Data = {
      struct: {
        data: { array: { type: "u8", len: 64 } }
      }
    };
    PublicKey = {
      enum: [
        { struct: { ed25519Key: this.Ed25519Data } },
        { struct: { secp256k1Key: this.Secp256k1Data } }
      ]
    };
    FunctionCallPermission = {
      struct: {
        allowance: { option: "u128" },
        receiverId: "string",
        methodNames: { array: { type: "string" } }
      }
    };
    FullAccessPermission = {
      struct: {}
    };
    AccessKeyPermission = {
      enum: [
        { struct: { functionCall: this.FunctionCallPermission } },
        { struct: { fullAccess: this.FullAccessPermission } }
      ]
    };
    AccessKey = {
      struct: {
        nonce: "u64",
        permission: this.AccessKeyPermission
      }
    };
    CreateAccount = {
      struct: {}
    };
    DeployContract = {
      struct: {
        code: { array: { type: "u8" } }
      }
    };
    FunctionCall = {
      struct: {
        methodName: "string",
        args: { array: { type: "u8" } },
        gas: "u64",
        deposit: "u128"
      }
    };
    Transfer = {
      struct: {
        deposit: "u128"
      }
    };
    Stake = {
      struct: {
        stake: "u128",
        publicKey: this.PublicKey
      }
    };
    AddKey = {
      struct: {
        publicKey: this.PublicKey,
        accessKey: this.AccessKey
      }
    };
    DeleteKey = {
      struct: {
        publicKey: this.PublicKey
      }
    };
    DeleteAccount = {
      struct: {
        beneficiaryId: "string"
      }
    };
    ClassicAction = {
      enum: [
        { struct: { createAccount: this.CreateAccount } },
        { struct: { deployContract: this.DeployContract } },
        { struct: { functionCall: this.FunctionCall } },
        { struct: { transfer: this.Transfer } },
        { struct: { stake: this.Stake } },
        { struct: { addKey: this.AddKey } },
        { struct: { deleteKey: this.DeleteKey } },
        { struct: { deleteAccount: this.DeleteAccount } }
      ]
    };
    DelegateAction = {
      struct: {
        senderId: "string",
        receiverId: "string",
        actions: { array: { type: this.ClassicAction } },
        nonce: "u64",
        maxBlockHeight: "u64",
        publicKey: this.PublicKey
      }
    };
    SignedDelegate = {
      struct: {
        delegateAction: this.DelegateAction,
        signature: this.Signature
      }
    };
    Action = {
      enum: [
        { struct: { createAccount: this.CreateAccount } },
        { struct: { deployContract: this.DeployContract } },
        { struct: { functionCall: this.FunctionCall } },
        { struct: { transfer: this.Transfer } },
        { struct: { stake: this.Stake } },
        { struct: { addKey: this.AddKey } },
        { struct: { deleteKey: this.DeleteKey } },
        { struct: { deleteAccount: this.DeleteAccount } },
        { struct: { signedDelegate: this.SignedDelegate } }
      ]
    };
    Transaction = {
      struct: {
        signerId: "string",
        publicKey: this.PublicKey,
        nonce: "u64",
        receiverId: "string",
        blockHash: { array: { type: "u8", len: 32 } },
        actions: { array: { type: this.Action } }
      }
    };
    SignedTransaction = {
      struct: {
        transaction: this.Transaction,
        signature: this.Signature
      }
    };
  }();

  // src/adapters/near.ts
  var walletUrl = (networkId) => networkId === "testnet" ? "https://testnet.mynearwallet.com" : "https://app.mynearwallet.com";
  function createNearAdapter() {
    return {
      async signIn({ networkId, contractId, callbackUrl, publicKey }) {
        const url = new URL(`${walletUrl(networkId)}/login`);
        url.searchParams.set("contract_id", contractId);
        url.searchParams.set("public_key", publicKey);
        url.searchParams.set("success_url", callbackUrl);
        url.searchParams.set("failure_url", callbackUrl);
        return {
          url: url.toString(),
          state: {
            publicKey,
            networkId
          }
        };
      },
      async sendTransactions({ state, transactions, callbackUrl }) {
        console.log(
          "sendTransactions",
          JSON.stringify({ state, transactions, callbackUrl })
        );
        if (!state?.accountId) {
          throw new Error("Not signed in");
        }
        const url = new URL("sign", walletUrl(state?.networkId));
        transactions = transactions.map(({ signerId, receiverId, actions }) => {
          if (signerId && signerId !== state.accountId) {
            throw new Error("Invalid signer");
          }
          return {
            signerId: state.accountId,
            receiverId,
            actions,
            publicKey: `ed25519:${binary_to_base58_default(new Uint8Array(32))}`,
            nonce: 0,
            blockHash: binary_to_base58_default(new Uint8Array(32))
          };
        });
        url.searchParams.set(
          "transactions",
          transactions.map((transaction) => serializeTransaction(transaction)).map((serialized) => Buffer.from(serialized).toString("base64")).join(",")
        );
        url.searchParams.set("callbackUrl", callbackUrl);
        return { url: url.toString() };
      }
    };
  }

  // ../../node_modules/meer-api-js/dist/esm/meer-api-js/src/key_stores/index.js
  var key_stores_exports = {};
  __export(key_stores_exports, {
    BrowserLocalStorageKeyStore: () => BrowserLocalStorageKeyStore,
    InMemoryKeyStore: () => InMemoryKeyStore,
    KeyStore: () => KeyStore,
    MergeKeyStore: () => MergeKeyStore
  });

  // ../../node_modules/@meer-js/crypto/dist/esm/crypto/src/constants.js
  var KeyType;
  (function(KeyType3) {
    KeyType3[KeyType3["ED25519"] = 0] = "ED25519";
    KeyType3[KeyType3["SECP256K1"] = 1] = "SECP256K1";
  })(KeyType || (KeyType = {}));
  var KeySize = {
    SECRET_KEY: 32,
    ED25519_PUBLIC_KEY: 32,
    SECP256k1_PUBLIC_KEY: 64
  };

  // ../../node_modules/@meer-js/crypto/dist/esm/crypto/src/key_pair_base.js
  var KeyPairBase = class {
  };

  // ../../node_modules/@meer-js/utils/dist/esm/utils/src/constants.js
  var DEFAULT_FUNCTION_CALL_GAS = 30000000000000n;

  // ../../node_modules/@meer-js/types/dist/esm/types/src/enum.js
  var Enum = class {
    constructor(properties) {
      if (Object.keys(properties).length !== 1) {
        throw new Error("Enum can only take single value");
      }
      Object.keys(properties).map((key) => {
        this[key] = properties[key];
      });
    }
  };

  // ../../node_modules/@meer-js/types/dist/esm/types/src/errors.js
  var PositionalArgsError = class extends Error {
    constructor() {
      super("Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }");
    }
  };
  var TypedError = class extends Error {
    type;
    context;
    constructor(message, type, context) {
      super(message);
      this.type = type || "UntypedError";
      this.context = context;
    }
  };
  var ErrorContext = class {
    transactionHash;
    constructor(transactionHash) {
      this.transactionHash = transactionHash;
    }
  };

  // ../../node_modules/@meer-js/types/dist/esm/types/src/provider/light_client.js
  var IdType;
  (function(IdType3) {
    IdType3["Transaction"] = "transaction";
    IdType3["Receipt"] = "receipt";
  })(IdType || (IdType = {}));

  // ../../node_modules/@meer-js/types/dist/esm/types/src/provider/response.js
  var ExecutionStatusBasic;
  (function(ExecutionStatusBasic3) {
    ExecutionStatusBasic3["Unknown"] = "Unknown";
    ExecutionStatusBasic3["Pending"] = "Pending";
    ExecutionStatusBasic3["Failure"] = "Failure";
  })(ExecutionStatusBasic || (ExecutionStatusBasic = {}));
  var FinalExecutionStatusBasic;
  (function(FinalExecutionStatusBasic3) {
    FinalExecutionStatusBasic3["NotStarted"] = "NotStarted";
    FinalExecutionStatusBasic3["Started"] = "Started";
    FinalExecutionStatusBasic3["Failure"] = "Failure";
  })(FinalExecutionStatusBasic || (FinalExecutionStatusBasic = {}));

  // ../../node_modules/@meer-js/utils/node_modules/mustache/mustache.mjs
  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill(object) {
    return objectToString.call(object) === "[object Array]";
  };
  function isFunction(object) {
    return typeof object === "function";
  }
  function typeStr(obj) {
    return isArray(obj) ? "array" : typeof obj;
  }
  function escapeRegExp(string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }
  function hasProperty(obj, propName) {
    return obj != null && typeof obj === "object" && propName in obj;
  }
  function primitiveHasOwnProperty(primitive, propName) {
    return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
  }
  var regExpTest = RegExp.prototype.test;
  function testRegExp(re, string) {
    return regExpTest.call(re, string);
  }
  var nonSpaceRe = /\S/;
  function isWhitespace(string) {
    return !testRegExp(nonSpaceRe, string);
  }
  var entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;",
    "`": "&#x60;",
    "=": "&#x3D;"
  };
  function escapeHtml(string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
      return entityMap[s];
    });
  }
  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;
  function parseTemplate(template, tags) {
    if (!template)
      return [];
    var lineHasNonSpace = false;
    var sections = [];
    var tokens = [];
    var spaces = [];
    var hasTag = false;
    var nonSpace = false;
    var indentation = "";
    var tagIndex = 0;
    function stripSpace() {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }
      hasTag = false;
      nonSpace = false;
    }
    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags(tagsToCompile) {
      if (typeof tagsToCompile === "string")
        tagsToCompile = tagsToCompile.split(spaceRe, 2);
      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error("Invalid tags: " + tagsToCompile);
      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
      closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
    }
    compileTags(tags || mustache.tags);
    var scanner = new Scanner(template);
    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;
      value = scanner.scanUntil(openingTagRe);
      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);
          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
            indentation += chr;
          } else {
            nonSpace = true;
            lineHasNonSpace = true;
            indentation += " ";
          }
          tokens.push(["text", chr, start, start + 1]);
          start += 1;
          if (chr === "\n") {
            stripSpace();
            indentation = "";
            tagIndex = 0;
            lineHasNonSpace = false;
          }
        }
      }
      if (!scanner.scan(openingTagRe))
        break;
      hasTag = true;
      type = scanner.scan(tagRe) || "name";
      scanner.scan(whiteRe);
      if (type === "=") {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === "{") {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = "&";
      } else {
        value = scanner.scanUntil(closingTagRe);
      }
      if (!scanner.scan(closingTagRe))
        throw new Error("Unclosed tag at " + scanner.pos);
      if (type == ">") {
        token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
      } else {
        token = [type, value, start, scanner.pos];
      }
      tagIndex++;
      tokens.push(token);
      if (type === "#" || type === "^") {
        sections.push(token);
      } else if (type === "/") {
        openSection = sections.pop();
        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);
        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === "name" || type === "{" || type === "&") {
        nonSpace = true;
      } else if (type === "=") {
        compileTags(value);
      }
    }
    stripSpace();
    openSection = sections.pop();
    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
    return nestTokens(squashTokens(tokens));
  }
  function squashTokens(tokens) {
    var squashedTokens = [];
    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];
      if (token) {
        if (token[0] === "text" && lastToken && lastToken[0] === "text") {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }
    return squashedTokens;
  }
  function nestTokens(tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];
    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];
      switch (token[0]) {
        case "#":
        case "^":
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case "/":
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }
    return nestedTokens;
  }
  function Scanner(string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }
  Scanner.prototype.eos = function eos() {
    return this.tail === "";
  };
  Scanner.prototype.scan = function scan(re) {
    var match = this.tail.match(re);
    if (!match || match.index !== 0)
      return "";
    var string = match[0];
    this.tail = this.tail.substring(string.length);
    this.pos += string.length;
    return string;
  };
  Scanner.prototype.scanUntil = function scanUntil(re) {
    var index = this.tail.search(re), match;
    switch (index) {
      case -1:
        match = this.tail;
        this.tail = "";
        break;
      case 0:
        match = "";
        break;
      default:
        match = this.tail.substring(0, index);
        this.tail = this.tail.substring(index);
    }
    this.pos += match.length;
    return match;
  };
  function Context(view, parentContext) {
    this.view = view;
    this.cache = { ".": this.view };
    this.parent = parentContext;
  }
  Context.prototype.push = function push(view) {
    return new Context(view, this);
  };
  Context.prototype.lookup = function lookup(name) {
    var cache = this.cache;
    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, intermediateValue, names, index, lookupHit = false;
      while (context) {
        if (name.indexOf(".") > 0) {
          intermediateValue = context.view;
          names = name.split(".");
          index = 0;
          while (intermediateValue != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
            intermediateValue = intermediateValue[names[index++]];
          }
        } else {
          intermediateValue = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }
        if (lookupHit) {
          value = intermediateValue;
          break;
        }
        context = context.parent;
      }
      cache[name] = value;
    }
    if (isFunction(value))
      value = value.call(this.view);
    return value;
  };
  function Writer() {
    this.templateCache = {
      _cache: {},
      set: function set(key, value) {
        this._cache[key] = value;
      },
      get: function get(key) {
        return this._cache[key];
      },
      clear: function clear() {
        this._cache = {};
      }
    };
  }
  Writer.prototype.clearCache = function clearCache() {
    if (typeof this.templateCache !== "undefined") {
      this.templateCache.clear();
    }
  };
  Writer.prototype.parse = function parse(template, tags) {
    var cache = this.templateCache;
    var cacheKey = template + ":" + (tags || mustache.tags).join(":");
    var isCacheEnabled = typeof cache !== "undefined";
    var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
    if (tokens == void 0) {
      tokens = parseTemplate(template, tags);
      isCacheEnabled && cache.set(cacheKey, tokens);
    }
    return tokens;
  };
  Writer.prototype.render = function render(template, view, partials, config) {
    var tags = this.getConfigTags(config);
    var tokens = this.parse(template, tags);
    var context = view instanceof Context ? view : new Context(view, void 0);
    return this.renderTokens(tokens, context, partials, template, config);
  };
  Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
    var buffer = "";
    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = void 0;
      token = tokens[i];
      symbol = token[0];
      if (symbol === "#") value = this.renderSection(token, context, partials, originalTemplate, config);
      else if (symbol === "^") value = this.renderInverted(token, context, partials, originalTemplate, config);
      else if (symbol === ">") value = this.renderPartial(token, context, partials, config);
      else if (symbol === "&") value = this.unescapedValue(token, context);
      else if (symbol === "name") value = this.escapedValue(token, context, config);
      else if (symbol === "text") value = this.rawValue(token);
      if (value !== void 0)
        buffer += value;
    }
    return buffer;
  };
  Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
    var self2 = this;
    var buffer = "";
    var value = context.lookup(token[1]);
    function subRender(template) {
      return self2.render(template, context, partials, config);
    }
    if (!value) return;
    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
      }
    } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== "string")
        throw new Error("Cannot use higher-order sections without the original template");
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
    }
    return buffer;
  };
  Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
    var value = context.lookup(token[1]);
    if (!value || isArray(value) && value.length === 0)
      return this.renderTokens(token[4], context, partials, originalTemplate, config);
  };
  Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
    var filteredIndentation = indentation.replace(/[^ \t]/g, "");
    var partialByNl = partial.split("\n");
    for (var i = 0; i < partialByNl.length; i++) {
      if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
        partialByNl[i] = filteredIndentation + partialByNl[i];
      }
    }
    return partialByNl.join("\n");
  };
  Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
    if (!partials) return;
    var tags = this.getConfigTags(config);
    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null) {
      var lineHasNonSpace = token[6];
      var tagIndex = token[5];
      var indentation = token[4];
      var indentedValue = value;
      if (tagIndex == 0 && indentation) {
        indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
      }
      var tokens = this.parse(indentedValue, tags);
      return this.renderTokens(tokens, context, partials, indentedValue, config);
    }
  };
  Writer.prototype.unescapedValue = function unescapedValue(token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };
  Writer.prototype.escapedValue = function escapedValue(token, context, config) {
    var escape2 = this.getConfigEscape(config) || mustache.escape;
    var value = context.lookup(token[1]);
    if (value != null)
      return typeof value === "number" && escape2 === mustache.escape ? String(value) : escape2(value);
  };
  Writer.prototype.rawValue = function rawValue(token) {
    return token[1];
  };
  Writer.prototype.getConfigTags = function getConfigTags(config) {
    if (isArray(config)) {
      return config;
    } else if (config && typeof config === "object") {
      return config.tags;
    } else {
      return void 0;
    }
  };
  Writer.prototype.getConfigEscape = function getConfigEscape(config) {
    if (config && typeof config === "object" && !isArray(config)) {
      return config.escape;
    } else {
      return void 0;
    }
  };
  var mustache = {
    name: "mustache.js",
    version: "4.2.0",
    tags: ["{{", "}}"],
    clearCache: void 0,
    escape: void 0,
    parse: void 0,
    render: void 0,
    Scanner: void 0,
    Context: void 0,
    Writer: void 0,
    /**
     * Allows a user to override the default caching strategy, by providing an
     * object with set, get and clear methods. This can also be used to disable
     * the cache by setting it to the literal `undefined`.
     */
    set templateCache(cache) {
      defaultWriter.templateCache = cache;
    },
    /**
     * Gets the default or overridden caching object from the default writer.
     */
    get templateCache() {
      return defaultWriter.templateCache;
    }
  };
  var defaultWriter = new Writer();
  mustache.clearCache = function clearCache2() {
    return defaultWriter.clearCache();
  };
  mustache.parse = function parse2(template, tags) {
    return defaultWriter.parse(template, tags);
  };
  mustache.render = function render2(template, view, partials, config) {
    if (typeof template !== "string") {
      throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
    }
    return defaultWriter.render(template, view, partials, config);
  };
  mustache.escape = escapeHtml;
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;
  var mustache_default = mustache;

  // ../../node_modules/base-x/src/esm/index.js
  function base(ALPHABET2) {
    if (ALPHABET2.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    const BASE_MAP = new Uint8Array(256);
    for (let j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (let i = 0; i < ALPHABET2.length; i++) {
      const x = ALPHABET2.charAt(i);
      const xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    const BASE = ALPHABET2.length;
    const LEADER = ALPHABET2.charAt(0);
    const FACTOR = Math.log(BASE) / Math.log(256);
    const iFACTOR = Math.log(256) / Math.log(BASE);
    function encode(source) {
      if (source instanceof Uint8Array) {
      } else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      let zeroes = 0;
      let length = 0;
      let pbegin = 0;
      const pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      const b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        let carry = source[pbegin];
        let i = 0;
        for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i;
        pbegin++;
      }
      let it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      let str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET2.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      let psz = 0;
      let zeroes = 0;
      let length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      const size = (source.length - psz) * FACTOR + 1 >>> 0;
      const b256 = new Uint8Array(size);
      while (source[psz]) {
        let carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        let i = 0;
        for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i;
        psz++;
      }
      let it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      const vch = new Uint8Array(zeroes + (size - it4));
      let j = zeroes;
      while (it4 !== size) {
        vch[j++] = b256[it4++];
      }
      return vch;
    }
    function decode(string) {
      const buffer = decodeUnsafe(string);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE + " character");
    }
    return {
      encode,
      decodeUnsafe,
      decode
    };
  }
  var esm_default = base;

  // ../../node_modules/@meer-js/utils/node_modules/bs58/src/esm/index.js
  var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  var esm_default2 = esm_default(ALPHABET);

  // ../../node_modules/@meer-js/utils/dist/esm/utils/src/format.js
  var NEAR_NOMINATION_EXP = 24;
  var NEAR_NOMINATION = 10n ** BigInt(NEAR_NOMINATION_EXP);
  var ROUNDING_OFFSETS = [];
  var BN10 = 10n;
  for (let i = 0, offset = 5n; i < NEAR_NOMINATION_EXP; i++, offset = offset * BN10) {
    ROUNDING_OFFSETS[i] = offset;
  }
  function formatNearAmount(balance, fracDigits = NEAR_NOMINATION_EXP) {
    let balanceBN = BigInt(balance);
    if (fracDigits !== NEAR_NOMINATION_EXP) {
      const roundingExp = NEAR_NOMINATION_EXP - fracDigits - 1;
      if (roundingExp > 0) {
        balanceBN += ROUNDING_OFFSETS[roundingExp];
      }
    }
    balance = balanceBN.toString();
    const wholeStr = balance.substring(0, balance.length - NEAR_NOMINATION_EXP) || "0";
    const fractionStr = balance.substring(balance.length - NEAR_NOMINATION_EXP).padStart(NEAR_NOMINATION_EXP, "0").substring(0, fracDigits);
    return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
  }
  function parseNearAmount(amt) {
    if (!amt) {
      return null;
    }
    amt = cleanupAmount(amt);
    const split3 = amt.split(".");
    const wholePart = split3[0];
    const fracPart = split3[1] || "";
    if (split3.length > 2 || fracPart.length > NEAR_NOMINATION_EXP) {
      throw new Error(`Cannot parse '${amt}' as NEAR amount`);
    }
    return trimLeadingZeroes(wholePart + fracPart.padEnd(NEAR_NOMINATION_EXP, "0"));
  }
  function cleanupAmount(amount) {
    return amount.replace(/,/g, "").trim();
  }
  function trimTrailingZeroes(value) {
    return value.replace(/\.?0*$/, "");
  }
  function trimLeadingZeroes(value) {
    value = value.replace(/^0+/, "");
    if (value === "") {
      return "0";
    }
    return value;
  }
  function formatWithCommas(value) {
    const pattern = /(-?\d+)(\d{3})/;
    while (pattern.test(value)) {
      value = value.replace(pattern, "$1,$2");
    }
    return value;
  }
  function baseEncode(value) {
    if (typeof value === "string") {
      const bytes2 = [];
      for (let c = 0; c < value.length; c++) {
        bytes2.push(value.charCodeAt(c));
      }
      value = new Uint8Array(bytes2);
    }
    return esm_default2.encode(value);
  }
  function baseDecode(value) {
    return new Uint8Array(esm_default2.decode(value));
  }

  // ../../node_modules/@meer-js/utils/dist/esm/utils/src/errors/error_messages.js
  var errorMessages = {
    "GasLimitExceeded": "Exceeded the maximum amount of gas allowed to burn per contract",
    "MethodEmptyName": "Method name is empty",
    "WasmerCompileError": "Wasmer compilation error: {{msg}}",
    "GuestPanic": "Smart contract panicked: {{panic_msg}}",
    "Memory": "Error creating Wasm memory",
    "GasExceeded": "Exceeded the prepaid gas",
    "MethodUTF8Error": "Method name is not valid UTF8 string",
    "BadUTF16": "String encoding is bad UTF-16 sequence",
    "WasmTrap": "WebAssembly trap: {{msg}}",
    "GasInstrumentation": "Gas instrumentation failed or contract has denied instructions.",
    "InvalidPromiseIndex": "{{promise_idx}} does not correspond to existing promises",
    "InvalidPromiseResultIndex": "Accessed invalid promise result index: {{result_idx}}",
    "Deserialization": "Error happened while deserializing the module",
    "MethodNotFound": "Contract method is not found",
    "InvalidRegisterId": "Accessed invalid register id: {{register_id}}",
    "InvalidReceiptIndex": "VM Logic returned an invalid receipt index: {{receipt_index}}",
    "EmptyMethodName": "Method name is empty in contract call",
    "CannotReturnJointPromise": "Returning joint promise is currently prohibited",
    "StackHeightInstrumentation": "Stack instrumentation failed",
    "CodeDoesNotExist": "Cannot find contract code for account {{account_id}}",
    "MethodInvalidSignature": "Invalid method signature",
    "IntegerOverflow": "Integer overflow happened during contract execution",
    "MemoryAccessViolation": "MemoryAccessViolation",
    "InvalidIteratorIndex": "Iterator index {{iterator_index}} does not exist",
    "IteratorWasInvalidated": "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
    "InvalidAccountId": "VM Logic returned an invalid account id",
    "Serialization": "Error happened while serializing the module",
    "CannotAppendActionToJointPromise": "Actions can only be appended to non-joint promise.",
    "InternalMemoryDeclared": "Internal memory declaration has been found in the module",
    "Instantiate": "Error happened during instantiation",
    "ProhibitedInView": "{{method_name}} is not allowed in view calls",
    "InvalidMethodName": "VM Logic returned an invalid method name",
    "BadUTF8": "String encoding is bad UTF-8 sequence",
    "BalanceExceeded": "Exceeded the account balance",
    "LinkError": "Wasm contract link error: {{msg}}",
    "InvalidPublicKey": "VM Logic provided an invalid public key",
    "ActorNoPermission": "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
    "LackBalanceForState": "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
    "ReceiverMismatch": "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
    "CostOverflow": "Transaction gas or balance cost is too high",
    "InvalidSignature": "Transaction is not signed with the given public key",
    "AccessKeyNotFound": `Signer "{{account_id}}" doesn't have access key with the given public_key {{public_key}}`,
    "NotEnoughBalance": "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
    "NotEnoughAllowance": "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
    "Expired": "Transaction has expired",
    "DeleteAccountStaking": "Account {{account_id}} is staking and can not be deleted",
    "SignerDoesNotExist": "Signer {{signer_id}} does not exist",
    "TriesToStake": "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
    "AddKeyAlreadyExists": "The public key {{public_key}} is already used for an existing access key",
    "InvalidSigner": "Invalid signer account ID {{signer_id}} according to requirements",
    "CreateAccountNotAllowed": "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
    "RequiresFullAccess": "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
    "TriesToUnstake": "Account {{account_id}} is not yet staked, but tried to unstake",
    "InvalidNonce": "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
    "AccountAlreadyExists": "Can't create a new account {{account_id}}, because it already exists",
    "InvalidChain": "Transaction parent block hash doesn't belong to the current chain",
    "AccountDoesNotExist": "Can't complete the action because account {{account_id}} doesn't exist",
    "AccessKeyDoesNotExist": "Can't complete the action because access key {{public_key}} doesn't exist",
    "MethodNameMismatch": "Transaction method name {{method_name}} isn't allowed by the access key",
    "DeleteAccountHasRent": "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
    "DeleteAccountHasEnoughBalance": "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
    "InvalidReceiver": "Invalid receiver account ID {{receiver_id}} according to requirements",
    "DeleteKeyDoesNotExist": "Account {{account_id}} tries to remove an access key that doesn't exist",
    "Timeout": "Timeout exceeded",
    "Closed": "Connection closed",
    "ShardCongested": "Shard {{shard_id}} rejected the transaction due to congestion level {{congestion_level}}, try again later",
    "ShardStuck": "Shard {{shard_id}} rejected the transaction because it missed {{missed_chunks}} chunks and needs to recover before accepting new transactions, try again later"
  };

  // ../../node_modules/@meer-js/utils/dist/esm/utils/src/errors/errors.js
  var ErrorMessages = errorMessages;

  // ../../node_modules/@meer-js/utils/dist/esm/utils/src/errors/rpc_error_schema.js
  var rpcErrorSchema = {
    "schema": {
      "AccessKeyNotFound": {
        "name": "AccessKeyNotFound",
        "subtypes": [],
        "props": {
          "account_id": "",
          "public_key": ""
        }
      },
      "AccountAlreadyExists": {
        "name": "AccountAlreadyExists",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "AccountDoesNotExist": {
        "name": "AccountDoesNotExist",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "ActionError": {
        "name": "ActionError",
        "subtypes": [
          "AccountAlreadyExists",
          "AccountDoesNotExist",
          "CreateAccountOnlyByRegistrar",
          "CreateAccountNotAllowed",
          "ActorNoPermission",
          "DeleteKeyDoesNotExist",
          "AddKeyAlreadyExists",
          "DeleteAccountStaking",
          "LackBalanceForState",
          "TriesToUnstake",
          "TriesToStake",
          "InsufficientStake",
          "FunctionCallError",
          "NewReceiptValidationError",
          "OnlyImplicitAccountCreationAllowed",
          "DeleteAccountWithLargeState",
          "DelegateActionInvalidSignature",
          "DelegateActionSenderDoesNotMatchTxReceiver",
          "DelegateActionExpired",
          "DelegateActionAccessKeyError",
          "DelegateActionInvalidNonce",
          "DelegateActionNonceTooLarge"
        ],
        "props": {
          "index": ""
        }
      },
      "ActionsValidationError": {
        "name": "ActionsValidationError",
        "subtypes": [
          "DeleteActionMustBeFinal",
          "TotalPrepaidGasExceeded",
          "TotalNumberOfActionsExceeded",
          "AddKeyMethodNamesNumberOfBytesExceeded",
          "AddKeyMethodNameLengthExceeded",
          "IntegerOverflow",
          "InvalidAccountId",
          "ContractSizeExceeded",
          "FunctionCallMethodNameLengthExceeded",
          "FunctionCallArgumentsLengthExceeded",
          "UnsuitableStakingKey",
          "FunctionCallZeroAttachedGas",
          "DelegateActionMustBeOnlyOne",
          "UnsupportedProtocolFeature"
        ],
        "props": {}
      },
      "ActorNoPermission": {
        "name": "ActorNoPermission",
        "subtypes": [],
        "props": {
          "account_id": "",
          "actor_id": ""
        }
      },
      "AddKeyAlreadyExists": {
        "name": "AddKeyAlreadyExists",
        "subtypes": [],
        "props": {
          "account_id": "",
          "public_key": ""
        }
      },
      "AddKeyMethodNameLengthExceeded": {
        "name": "AddKeyMethodNameLengthExceeded",
        "subtypes": [],
        "props": {
          "length": "",
          "limit": ""
        }
      },
      "AddKeyMethodNamesNumberOfBytesExceeded": {
        "name": "AddKeyMethodNamesNumberOfBytesExceeded",
        "subtypes": [],
        "props": {
          "limit": "",
          "total_number_of_bytes": ""
        }
      },
      "AltBn128InvalidInput": {
        "name": "AltBn128InvalidInput",
        "subtypes": [],
        "props": {
          "msg": ""
        }
      },
      "BadUTF16": {
        "name": "BadUTF16",
        "subtypes": [],
        "props": {}
      },
      "BadUTF8": {
        "name": "BadUTF8",
        "subtypes": [],
        "props": {}
      },
      "BalanceExceeded": {
        "name": "BalanceExceeded",
        "subtypes": [],
        "props": {}
      },
      "BalanceMismatchError": {
        "name": "BalanceMismatchError",
        "subtypes": [],
        "props": {
          "final_accounts_balance": "",
          "final_postponed_receipts_balance": "",
          "forwarded_buffered_receipts_balance": "",
          "incoming_receipts_balance": "",
          "incoming_validator_rewards": "",
          "initial_accounts_balance": "",
          "initial_postponed_receipts_balance": "",
          "new_buffered_receipts_balance": "",
          "new_delayed_receipts_balance": "",
          "other_burnt_amount": "",
          "outgoing_receipts_balance": "",
          "processed_delayed_receipts_balance": "",
          "slashed_burnt_amount": "",
          "tx_burnt_amount": ""
        }
      },
      "CallIndirectOOB": {
        "name": "CallIndirectOOB",
        "subtypes": [],
        "props": {}
      },
      "CannotAppendActionToJointPromise": {
        "name": "CannotAppendActionToJointPromise",
        "subtypes": [],
        "props": {}
      },
      "CannotReturnJointPromise": {
        "name": "CannotReturnJointPromise",
        "subtypes": [],
        "props": {}
      },
      "CodeDoesNotExist": {
        "name": "CodeDoesNotExist",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "CompilationError": {
        "name": "CompilationError",
        "subtypes": [
          "CodeDoesNotExist",
          "PrepareError",
          "WasmerCompileError"
        ],
        "props": {}
      },
      "ContractSizeExceeded": {
        "name": "ContractSizeExceeded",
        "subtypes": [],
        "props": {
          "limit": "",
          "size": ""
        }
      },
      "CostOverflow": {
        "name": "CostOverflow",
        "subtypes": [],
        "props": {}
      },
      "CreateAccountNotAllowed": {
        "name": "CreateAccountNotAllowed",
        "subtypes": [],
        "props": {
          "account_id": "",
          "predecessor_id": ""
        }
      },
      "CreateAccountOnlyByRegistrar": {
        "name": "CreateAccountOnlyByRegistrar",
        "subtypes": [],
        "props": {
          "account_id": "",
          "predecessor_id": "",
          "registrar_account_id": ""
        }
      },
      "DelegateActionExpired": {
        "name": "DelegateActionExpired",
        "subtypes": [],
        "props": {}
      },
      "DelegateActionInvalidNonce": {
        "name": "DelegateActionInvalidNonce",
        "subtypes": [],
        "props": {
          "ak_nonce": "",
          "delegate_nonce": ""
        }
      },
      "DelegateActionInvalidSignature": {
        "name": "DelegateActionInvalidSignature",
        "subtypes": [],
        "props": {}
      },
      "DelegateActionMustBeOnlyOne": {
        "name": "DelegateActionMustBeOnlyOne",
        "subtypes": [],
        "props": {}
      },
      "DelegateActionNonceTooLarge": {
        "name": "DelegateActionNonceTooLarge",
        "subtypes": [],
        "props": {
          "delegate_nonce": "",
          "upper_bound": ""
        }
      },
      "DelegateActionSenderDoesNotMatchTxReceiver": {
        "name": "DelegateActionSenderDoesNotMatchTxReceiver",
        "subtypes": [],
        "props": {
          "receiver_id": "",
          "sender_id": ""
        }
      },
      "DeleteAccountStaking": {
        "name": "DeleteAccountStaking",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "DeleteAccountWithLargeState": {
        "name": "DeleteAccountWithLargeState",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "DeleteActionMustBeFinal": {
        "name": "DeleteActionMustBeFinal",
        "subtypes": [],
        "props": {}
      },
      "DeleteKeyDoesNotExist": {
        "name": "DeleteKeyDoesNotExist",
        "subtypes": [],
        "props": {
          "account_id": "",
          "public_key": ""
        }
      },
      "DepositWithFunctionCall": {
        "name": "DepositWithFunctionCall",
        "subtypes": [],
        "props": {}
      },
      "Deprecated": {
        "name": "Deprecated",
        "subtypes": [],
        "props": {
          "method_name": ""
        }
      },
      "Deserialization": {
        "name": "Deserialization",
        "subtypes": [],
        "props": {}
      },
      "ECRecoverError": {
        "name": "ECRecoverError",
        "subtypes": [],
        "props": {
          "msg": ""
        }
      },
      "Ed25519VerifyInvalidInput": {
        "name": "Ed25519VerifyInvalidInput",
        "subtypes": [],
        "props": {
          "msg": ""
        }
      },
      "EmptyMethodName": {
        "name": "EmptyMethodName",
        "subtypes": [],
        "props": {}
      },
      "Expired": {
        "name": "Expired",
        "subtypes": [],
        "props": {}
      },
      "FunctionCallArgumentsLengthExceeded": {
        "name": "FunctionCallArgumentsLengthExceeded",
        "subtypes": [],
        "props": {
          "length": "",
          "limit": ""
        }
      },
      "FunctionCallMethodNameLengthExceeded": {
        "name": "FunctionCallMethodNameLengthExceeded",
        "subtypes": [],
        "props": {
          "length": "",
          "limit": ""
        }
      },
      "FunctionCallZeroAttachedGas": {
        "name": "FunctionCallZeroAttachedGas",
        "subtypes": [],
        "props": {}
      },
      "GasExceeded": {
        "name": "GasExceeded",
        "subtypes": [],
        "props": {}
      },
      "GasInstrumentation": {
        "name": "GasInstrumentation",
        "subtypes": [],
        "props": {}
      },
      "GasLimitExceeded": {
        "name": "GasLimitExceeded",
        "subtypes": [],
        "props": {}
      },
      "GenericTrap": {
        "name": "GenericTrap",
        "subtypes": [],
        "props": {}
      },
      "GuestPanic": {
        "name": "GuestPanic",
        "subtypes": [],
        "props": {
          "panic_msg": ""
        }
      },
      "HostError": {
        "name": "HostError",
        "subtypes": [
          "BadUTF16",
          "BadUTF8",
          "GasExceeded",
          "GasLimitExceeded",
          "BalanceExceeded",
          "EmptyMethodName",
          "GuestPanic",
          "IntegerOverflow",
          "InvalidPromiseIndex",
          "CannotAppendActionToJointPromise",
          "CannotReturnJointPromise",
          "InvalidPromiseResultIndex",
          "InvalidRegisterId",
          "IteratorWasInvalidated",
          "MemoryAccessViolation",
          "InvalidReceiptIndex",
          "InvalidIteratorIndex",
          "InvalidAccountId",
          "InvalidMethodName",
          "InvalidPublicKey",
          "ProhibitedInView",
          "NumberOfLogsExceeded",
          "KeyLengthExceeded",
          "ValueLengthExceeded",
          "TotalLogLengthExceeded",
          "NumberPromisesExceeded",
          "NumberInputDataDependenciesExceeded",
          "ReturnedValueLengthExceeded",
          "ContractSizeExceeded",
          "Deprecated",
          "ECRecoverError",
          "AltBn128InvalidInput",
          "Ed25519VerifyInvalidInput"
        ],
        "props": {}
      },
      "IllegalArithmetic": {
        "name": "IllegalArithmetic",
        "subtypes": [],
        "props": {}
      },
      "IncorrectCallIndirectSignature": {
        "name": "IncorrectCallIndirectSignature",
        "subtypes": [],
        "props": {}
      },
      "IndirectCallToNull": {
        "name": "IndirectCallToNull",
        "subtypes": [],
        "props": {}
      },
      "Instantiate": {
        "name": "Instantiate",
        "subtypes": [],
        "props": {}
      },
      "InsufficientStake": {
        "name": "InsufficientStake",
        "subtypes": [],
        "props": {
          "account_id": "",
          "minimum_stake": "",
          "stake": ""
        }
      },
      "IntegerOverflow": {
        "name": "IntegerOverflow",
        "subtypes": [],
        "props": {}
      },
      "InternalMemoryDeclared": {
        "name": "InternalMemoryDeclared",
        "subtypes": [],
        "props": {}
      },
      "InvalidAccessKeyError": {
        "name": "InvalidAccessKeyError",
        "subtypes": [
          "AccessKeyNotFound",
          "ReceiverMismatch",
          "MethodNameMismatch",
          "RequiresFullAccess",
          "NotEnoughAllowance",
          "DepositWithFunctionCall"
        ],
        "props": {}
      },
      "InvalidAccountId": {
        "name": "InvalidAccountId",
        "subtypes": [],
        "props": {}
      },
      "InvalidChain": {
        "name": "InvalidChain",
        "subtypes": [],
        "props": {}
      },
      "InvalidDataReceiverId": {
        "name": "InvalidDataReceiverId",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "InvalidIteratorIndex": {
        "name": "InvalidIteratorIndex",
        "subtypes": [],
        "props": {
          "iterator_index": ""
        }
      },
      "InvalidMethodName": {
        "name": "InvalidMethodName",
        "subtypes": [],
        "props": {}
      },
      "InvalidNonce": {
        "name": "InvalidNonce",
        "subtypes": [],
        "props": {
          "ak_nonce": "",
          "tx_nonce": ""
        }
      },
      "InvalidPredecessorId": {
        "name": "InvalidPredecessorId",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "InvalidPromiseIndex": {
        "name": "InvalidPromiseIndex",
        "subtypes": [],
        "props": {
          "promise_idx": ""
        }
      },
      "InvalidPromiseResultIndex": {
        "name": "InvalidPromiseResultIndex",
        "subtypes": [],
        "props": {
          "result_idx": ""
        }
      },
      "InvalidPublicKey": {
        "name": "InvalidPublicKey",
        "subtypes": [],
        "props": {}
      },
      "InvalidReceiptIndex": {
        "name": "InvalidReceiptIndex",
        "subtypes": [],
        "props": {
          "receipt_index": ""
        }
      },
      "InvalidReceiverId": {
        "name": "InvalidReceiverId",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "InvalidRegisterId": {
        "name": "InvalidRegisterId",
        "subtypes": [],
        "props": {
          "register_id": ""
        }
      },
      "InvalidSignature": {
        "name": "InvalidSignature",
        "subtypes": [],
        "props": {}
      },
      "InvalidSignerId": {
        "name": "InvalidSignerId",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "InvalidTxError": {
        "name": "InvalidTxError",
        "subtypes": [
          "InvalidAccessKeyError",
          "InvalidSignerId",
          "SignerDoesNotExist",
          "InvalidNonce",
          "NonceTooLarge",
          "InvalidReceiverId",
          "InvalidSignature",
          "NotEnoughBalance",
          "LackBalanceForState",
          "CostOverflow",
          "InvalidChain",
          "Expired",
          "ActionsValidation",
          "TransactionSizeExceeded",
          "StorageError",
          "ShardCongested",
          "ShardStuck"
        ],
        "props": {}
      },
      "IteratorWasInvalidated": {
        "name": "IteratorWasInvalidated",
        "subtypes": [],
        "props": {
          "iterator_index": ""
        }
      },
      "KeyLengthExceeded": {
        "name": "KeyLengthExceeded",
        "subtypes": [],
        "props": {
          "length": "",
          "limit": ""
        }
      },
      "LackBalanceForState": {
        "name": "LackBalanceForState",
        "subtypes": [],
        "props": {
          "account_id": "",
          "amount": ""
        }
      },
      "Memory": {
        "name": "Memory",
        "subtypes": [],
        "props": {}
      },
      "MemoryAccessViolation": {
        "name": "MemoryAccessViolation",
        "subtypes": [],
        "props": {}
      },
      "MemoryOutOfBounds": {
        "name": "MemoryOutOfBounds",
        "subtypes": [],
        "props": {}
      },
      "MethodEmptyName": {
        "name": "MethodEmptyName",
        "subtypes": [],
        "props": {}
      },
      "MethodInvalidSignature": {
        "name": "MethodInvalidSignature",
        "subtypes": [],
        "props": {}
      },
      "MethodNameMismatch": {
        "name": "MethodNameMismatch",
        "subtypes": [],
        "props": {
          "method_name": ""
        }
      },
      "MethodNotFound": {
        "name": "MethodNotFound",
        "subtypes": [],
        "props": {}
      },
      "MethodResolveError": {
        "name": "MethodResolveError",
        "subtypes": [
          "MethodEmptyName",
          "MethodNotFound",
          "MethodInvalidSignature"
        ],
        "props": {}
      },
      "MisalignedAtomicAccess": {
        "name": "MisalignedAtomicAccess",
        "subtypes": [],
        "props": {}
      },
      "NonceTooLarge": {
        "name": "NonceTooLarge",
        "subtypes": [],
        "props": {
          "tx_nonce": "",
          "upper_bound": ""
        }
      },
      "NotEnoughAllowance": {
        "name": "NotEnoughAllowance",
        "subtypes": [],
        "props": {
          "account_id": "",
          "allowance": "",
          "cost": "",
          "public_key": ""
        }
      },
      "NotEnoughBalance": {
        "name": "NotEnoughBalance",
        "subtypes": [],
        "props": {
          "balance": "",
          "cost": "",
          "signer_id": ""
        }
      },
      "NumberInputDataDependenciesExceeded": {
        "name": "NumberInputDataDependenciesExceeded",
        "subtypes": [],
        "props": {
          "limit": "",
          "number_of_input_data_dependencies": ""
        }
      },
      "NumberOfLogsExceeded": {
        "name": "NumberOfLogsExceeded",
        "subtypes": [],
        "props": {
          "limit": ""
        }
      },
      "NumberPromisesExceeded": {
        "name": "NumberPromisesExceeded",
        "subtypes": [],
        "props": {
          "limit": "",
          "number_of_promises": ""
        }
      },
      "OnlyImplicitAccountCreationAllowed": {
        "name": "OnlyImplicitAccountCreationAllowed",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "PrepareError": {
        "name": "PrepareError",
        "subtypes": [
          "Serialization",
          "Deserialization",
          "InternalMemoryDeclared",
          "GasInstrumentation",
          "StackHeightInstrumentation",
          "Instantiate",
          "Memory",
          "TooManyFunctions",
          "TooManyLocals"
        ],
        "props": {}
      },
      "ProhibitedInView": {
        "name": "ProhibitedInView",
        "subtypes": [],
        "props": {
          "method_name": ""
        }
      },
      "ReceiptSizeExceeded": {
        "name": "ReceiptSizeExceeded",
        "subtypes": [],
        "props": {
          "limit": "",
          "size": ""
        }
      },
      "ReceiptValidationError": {
        "name": "ReceiptValidationError",
        "subtypes": [
          "InvalidPredecessorId",
          "InvalidReceiverId",
          "InvalidSignerId",
          "InvalidDataReceiverId",
          "ReturnedValueLengthExceeded",
          "NumberInputDataDependenciesExceeded",
          "ActionsValidation",
          "ReceiptSizeExceeded"
        ],
        "props": {}
      },
      "ReceiverMismatch": {
        "name": "ReceiverMismatch",
        "subtypes": [],
        "props": {
          "ak_receiver": "",
          "tx_receiver": ""
        }
      },
      "RequiresFullAccess": {
        "name": "RequiresFullAccess",
        "subtypes": [],
        "props": {}
      },
      "ReturnedValueLengthExceeded": {
        "name": "ReturnedValueLengthExceeded",
        "subtypes": [],
        "props": {
          "length": "",
          "limit": ""
        }
      },
      "Serialization": {
        "name": "Serialization",
        "subtypes": [],
        "props": {}
      },
      "ShardCongested": {
        "name": "ShardCongested",
        "subtypes": [],
        "props": {
          "congestion_level": "",
          "shard_id": ""
        }
      },
      "ShardStuck": {
        "name": "ShardStuck",
        "subtypes": [],
        "props": {
          "missed_chunks": "",
          "shard_id": ""
        }
      },
      "SignerDoesNotExist": {
        "name": "SignerDoesNotExist",
        "subtypes": [],
        "props": {
          "signer_id": ""
        }
      },
      "StackHeightInstrumentation": {
        "name": "StackHeightInstrumentation",
        "subtypes": [],
        "props": {}
      },
      "StackOverflow": {
        "name": "StackOverflow",
        "subtypes": [],
        "props": {}
      },
      "TooManyFunctions": {
        "name": "TooManyFunctions",
        "subtypes": [],
        "props": {}
      },
      "TooManyLocals": {
        "name": "TooManyLocals",
        "subtypes": [],
        "props": {}
      },
      "TotalLogLengthExceeded": {
        "name": "TotalLogLengthExceeded",
        "subtypes": [],
        "props": {
          "length": "",
          "limit": ""
        }
      },
      "TotalNumberOfActionsExceeded": {
        "name": "TotalNumberOfActionsExceeded",
        "subtypes": [],
        "props": {
          "limit": "",
          "total_number_of_actions": ""
        }
      },
      "TotalPrepaidGasExceeded": {
        "name": "TotalPrepaidGasExceeded",
        "subtypes": [],
        "props": {
          "limit": "",
          "total_prepaid_gas": ""
        }
      },
      "TransactionSizeExceeded": {
        "name": "TransactionSizeExceeded",
        "subtypes": [],
        "props": {
          "limit": "",
          "size": ""
        }
      },
      "TriesToStake": {
        "name": "TriesToStake",
        "subtypes": [],
        "props": {
          "account_id": "",
          "balance": "",
          "locked": "",
          "stake": ""
        }
      },
      "TriesToUnstake": {
        "name": "TriesToUnstake",
        "subtypes": [],
        "props": {
          "account_id": ""
        }
      },
      "TxExecutionError": {
        "name": "TxExecutionError",
        "subtypes": [
          "ActionError",
          "InvalidTxError"
        ],
        "props": {}
      },
      "Unreachable": {
        "name": "Unreachable",
        "subtypes": [],
        "props": {}
      },
      "UnsuitableStakingKey": {
        "name": "UnsuitableStakingKey",
        "subtypes": [],
        "props": {
          "public_key": ""
        }
      },
      "UnsupportedProtocolFeature": {
        "name": "UnsupportedProtocolFeature",
        "subtypes": [],
        "props": {
          "protocol_feature": "",
          "version": ""
        }
      },
      "ValueLengthExceeded": {
        "name": "ValueLengthExceeded",
        "subtypes": [],
        "props": {
          "length": "",
          "limit": ""
        }
      },
      "WasmTrap": {
        "name": "WasmTrap",
        "subtypes": [
          "Unreachable",
          "IncorrectCallIndirectSignature",
          "MemoryOutOfBounds",
          "CallIndirectOOB",
          "IllegalArithmetic",
          "MisalignedAtomicAccess",
          "IndirectCallToNull",
          "StackOverflow",
          "GenericTrap"
        ],
        "props": {}
      },
      "WasmerCompileError": {
        "name": "WasmerCompileError",
        "subtypes": [],
        "props": {
          "msg": ""
        }
      },
      "Closed": {
        "name": "Closed",
        "subtypes": [],
        "props": {}
      },
      "ServerError": {
        "name": "ServerError",
        "subtypes": [
          "TxExecutionError",
          "Timeout",
          "Closed"
        ],
        "props": {}
      },
      "Timeout": {
        "name": "Timeout",
        "subtypes": [],
        "props": {}
      }
    }
  };

  // ../../node_modules/@meer-js/utils/dist/esm/utils/src/errors/rpc_errors.js
  var mustacheHelpers = {
    formatNear: () => (n, render3) => formatNearAmount(render3(n))
  };
  var ServerError = class extends TypedError {
  };
  var ServerTransactionError = class extends ServerError {
    transaction_outcome;
  };
  function parseRpcError(errorObj) {
    const result = {};
    const errorClassName = walkSubtype(errorObj, rpcErrorSchema.schema, result, "");
    const error = new ServerError(formatError(errorClassName, result), errorClassName);
    Object.assign(error, result);
    return error;
  }
  function parseResultError(result) {
    const server_error = parseRpcError(result.status.Failure);
    const server_tx_error = new ServerTransactionError();
    Object.assign(server_tx_error, server_error);
    server_tx_error.type = server_error.type;
    server_tx_error.message = server_error.message;
    server_tx_error.transaction_outcome = result.transaction_outcome;
    return server_tx_error;
  }
  function formatError(errorClassName, errorData) {
    if (typeof ErrorMessages[errorClassName] === "string") {
      return mustache_default.render(ErrorMessages[errorClassName], {
        ...errorData,
        ...mustacheHelpers
      });
    }
    return JSON.stringify(errorData);
  }
  function walkSubtype(errorObj, schema, result, typeName) {
    let error;
    let type;
    let errorTypeName;
    for (const errorName in schema) {
      if (isString(errorObj[errorName])) {
        return errorObj[errorName];
      }
      if (isObject(errorObj[errorName])) {
        error = errorObj[errorName];
        type = schema[errorName];
        errorTypeName = errorName;
      } else if (isObject(errorObj.kind) && isObject(errorObj.kind[errorName])) {
        error = errorObj.kind[errorName];
        type = schema[errorName];
        errorTypeName = errorName;
      } else {
        continue;
      }
    }
    if (error && type) {
      for (const prop of Object.keys(type.props)) {
        result[prop] = error[prop];
      }
      return walkSubtype(error, schema, result, errorTypeName);
    } else {
      result.kind = errorObj;
      return typeName;
    }
  }
  function getErrorTypeFromErrorMessage(errorMessage, errorType) {
    switch (true) {
      case /^account .*? does not exist while viewing$/.test(errorMessage):
        return "AccountDoesNotExist";
      case /^Account .*? doesn't exist$/.test(errorMessage):
        return "AccountDoesNotExist";
      case /^access key .*? does not exist while viewing$/.test(errorMessage):
        return "AccessKeyDoesNotExist";
      case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
        return "CodeDoesNotExist";
      case /wasm execution failed with error: CompilationError\(CodeDoesNotExist/.test(errorMessage):
        return "CodeDoesNotExist";
      case /wasm execution failed with error: FunctionCallError\(MethodResolveError\(MethodNotFound/.test(errorMessage):
        return "MethodNotFound";
      case /wasm execution failed with error: MethodResolveError\(MethodNotFound/.test(errorMessage):
        return "MethodNotFound";
      case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
        return "InvalidNonce";
      default:
        return errorType;
    }
  }
  function isObject(n) {
    return Object.prototype.toString.call(n) === "[object Object]";
  }
  function isString(n) {
    return Object.prototype.toString.call(n) === "[object String]";
  }

  // ../../node_modules/@meer-js/utils/dist/esm/utils/src/logger/console.logger.js
  var ConsoleLogger = class {
    logLevels;
    constructor(logLevels) {
      this.logLevels = logLevels;
    }
    isLevelEnabled = (level) => {
      return this.logLevels.includes(level);
    };
    print(level, message, ...optionalParams) {
      switch (level) {
        case "error":
        case "fatal":
          return console.error(message, ...optionalParams);
        case "warn":
          return console.warn(message, ...optionalParams);
        case "log":
          return console.log(message, ...optionalParams);
        case "debug":
        case "verbose":
          return console.debug(message, ...optionalParams);
      }
    }
    verbose(message, ...optionalParams) {
      if (!this.isLevelEnabled("verbose"))
        return;
      this.print("verbose", message, ...optionalParams);
    }
    debug(message, ...optionalParams) {
      if (!this.isLevelEnabled("debug"))
        return;
      this.print("debug", message, ...optionalParams);
    }
    log(message, ...optionalParams) {
      if (!this.isLevelEnabled("log"))
        return;
      this.print("log", message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
      if (!this.isLevelEnabled("warn"))
        return;
      this.print("warn", message, ...optionalParams);
    }
    error(message, ...optionalParams) {
      if (!this.isLevelEnabled("error"))
        return;
      this.print("error", message, ...optionalParams);
    }
    fatal(message, ...optionalParams) {
      if (!this.isLevelEnabled("fatal"))
        return;
      this.print("fatal", message, ...optionalParams);
    }
  };

  // ../../node_modules/@meer-js/utils/dist/esm/utils/src/logger/logger.js
  var DEFAULT_LOG_LEVELS = [
    "verbose",
    "debug",
    "log",
    "warn",
    "error",
    "fatal"
  ];
  var DEFAULT_LOGGER = new ConsoleLogger(DEFAULT_LOG_LEVELS);
  var Logger = class {
    static instanceRef = DEFAULT_LOGGER;
    static overrideLogger = (logger) => {
      this.instanceRef = logger;
    };
    static error(message, ...optionalParams) {
      this.instanceRef?.error(message, ...optionalParams);
    }
    /**
     * Write a 'log' level log.
     */
    static log(message, ...optionalParams) {
      this.instanceRef?.log(message, ...optionalParams);
    }
    /**
     * Write a 'warn' level log.
     */
    static warn(message, ...optionalParams) {
      this.instanceRef?.warn(message, ...optionalParams);
    }
    /**
     * Write a 'debug' level log.
     */
    static debug(message, ...optionalParams) {
      this.instanceRef?.debug?.(message, ...optionalParams);
    }
    /**
     * Write a 'verbose' level log.
     */
    static verbose(message, ...optionalParams) {
      this.instanceRef?.verbose?.(message, ...optionalParams);
    }
    static fatal(message, ...optionalParams) {
      this.instanceRef?.fatal?.(message, ...optionalParams);
    }
  };

  // ../../node_modules/@meer-js/utils/dist/esm/utils/src/logging.js
  function printTxOutcomeLogsAndFailures({ contractId, outcome }) {
    const flatLogs = [outcome.transaction_outcome, ...outcome.receipts_outcome].reduce((acc, it) => {
      const status = it.outcome.status;
      const isFailure = typeof status === "object" && "Failure" in status;
      if (it.outcome.logs.length || isFailure) {
        const newEntry = {
          receiptIds: it.outcome.receipt_ids ?? [],
          logs: it.outcome.logs ?? [],
          // TODO what's this toString i had to add. what will it do
          failure: isFailure && status.Failure ? parseRpcError(status.Failure).toString() : null
        };
        return [...acc, newEntry];
      } else {
        return acc;
      }
    }, []);
    for (const result of flatLogs) {
      Logger.log(`Receipt${result.receiptIds.length > 1 ? "s" : ""}: ${result.receiptIds.join(", ")}`);
      printTxOutcomeLogs({
        contractId,
        logs: result.logs,
        prefix: "	"
      });
      if (result.failure) {
        Logger.warn(`	Failure [${contractId}]: ${result.failure}`);
      }
    }
  }
  function printTxOutcomeLogs({ contractId, logs, prefix = "" }) {
    for (const log of logs) {
      Logger.log(`${prefix}Log [${contractId}]: ${log}`);
    }
  }

  // ../../node_modules/@meer-js/utils/dist/esm/utils/src/validators.js
  var import_depd = __toESM(require_browser(), 1);

  // ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }

  // ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js
  var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

  // ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error("utf8ToBytes expected string, got " + typeof str);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    abytes(data);
    return data;
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto2 && typeof crypto2.getRandomValues === "function") {
      return crypto2.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto2 && typeof crypto2.randomBytes === "function") {
      return crypto2.randomBytes(bytesLength);
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n3 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n3 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  var HashMD = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  var shrSH = (h, _l, s) => h >>> s;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  var rotr32H = (_h, l) => l;
  var rotr32L = (h, _l) => h;
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  var u64_default = u64;

  // ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha512.js
  var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64_default.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  var SHA512 = class extends HashMD {
    constructor() {
      super(128, 64, 16, false);
      this.Ah = 1779033703 | 0;
      this.Al = 4089235720 | 0;
      this.Bh = 3144134277 | 0;
      this.Bl = 2227873595 | 0;
      this.Ch = 1013904242 | 0;
      this.Cl = 4271175723 | 0;
      this.Dh = 2773480762 | 0;
      this.Dl = 1595750129 | 0;
      this.Eh = 1359893119 | 0;
      this.El = 2917565137 | 0;
      this.Fh = 2600822924 | 0;
      this.Fl = 725511199 | 0;
      this.Gh = 528734635 | 0;
      this.Gl = 4215389547 | 0;
      this.Hh = 1541459225 | 0;
      this.Hl = 327033209 | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
        const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
        const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
        const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
        const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
        const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64_default.add3L(T1l, sigma0l, MAJl);
        Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      SHA512_W_H.fill(0);
      SHA512_W_L.fill(0);
    }
    destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());

  // ../../node_modules/@noble/curves/esm/abstract/utils.js
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  function isBytes2(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abytes2(item) {
    if (!isBytes2(item))
      throw new Error("Uint8Array expected");
  }
  function abool(title, value) {
    if (typeof value !== "boolean")
      throw new Error(title + " boolean expected, got " + value);
  }
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(bytes2) {
    abytes2(bytes2);
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes[bytes2[i]];
    }
    return hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n : BigInt("0x" + hex);
  }
  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber(bytesToHex(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    abytes2(bytes2);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
      }
    } else if (isBytes2(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(title + " must be hex string or Uint8Array");
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes2(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
  function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
  }
  function aInRange(title, n, min, max) {
    if (!inRange(n, min, max))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
      ;
    return len;
  }
  var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error("invalid validator function");
      const val = object[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object)) {
        throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object;
  }
  function memoized(fn) {
    const map = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }

  // ../../node_modules/@noble/curves/esm/abstract/modular.js
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  var _2n2 = /* @__PURE__ */ BigInt(2);
  var _3n = /* @__PURE__ */ BigInt(3);
  var _4n = /* @__PURE__ */ BigInt(4);
  var _5n = /* @__PURE__ */ BigInt(5);
  var _8n = /* @__PURE__ */ BigInt(8);
  var _9n = /* @__PURE__ */ BigInt(9);
  var _16n = /* @__PURE__ */ BigInt(16);
  function mod(a, b) {
    const result = a % b;
    return result >= _0n2 ? result : b + result;
  }
  function pow(num, power, modulo) {
    if (power < _0n2)
      throw new Error("invalid exponent, negatives unsupported");
    if (modulo <= _0n2)
      throw new Error("invalid modulus");
    if (modulo === _1n2)
      return _0n2;
    let res = _1n2;
    while (power > _0n2) {
      if (power & _1n2)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n2;
    }
    return res;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number, modulo) {
    if (number === _0n2)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n2)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
    while (a !== _0n2) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n2)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function tonelliShanks(P) {
    const legendreC = (P - _1n2) / _2n2;
    let Q, S, Z;
    for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
      ;
    for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++) {
      if (Z > 1e3)
        throw new Error("Cannot find square root: likely non-prime P");
    }
    if (S === 1) {
      const p1div4 = (P + _1n2) / _4n;
      return function tonelliFast(Fp3, n) {
        const root = Fp3.pow(n, p1div4);
        if (!Fp3.eql(Fp3.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n2) / _2n2;
    return function tonelliSlow(Fp3, n) {
      if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE))
        throw new Error("Cannot find square root");
      let r = S;
      let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
      let x = Fp3.pow(n, Q1div2);
      let b = Fp3.pow(n, Q);
      while (!Fp3.eql(b, Fp3.ONE)) {
        if (Fp3.eql(b, Fp3.ZERO))
          return Fp3.ZERO;
        let m = 1;
        for (let t2 = Fp3.sqr(b); m < r; m++) {
          if (Fp3.eql(t2, Fp3.ONE))
            break;
          t2 = Fp3.sqr(t2);
        }
        const ge = Fp3.pow(g, _1n2 << BigInt(r - m - 1));
        g = Fp3.sqr(ge);
        x = Fp3.mul(x, ge);
        b = Fp3.mul(b, g);
        r = m;
      }
      return x;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n) {
      const p1div4 = (P + _1n2) / _4n;
      return function sqrt3mod4(Fp3, n) {
        const root = Fp3.pow(n, p1div4);
        if (!Fp3.eql(Fp3.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n === _5n) {
      const c1 = (P - _5n) / _8n;
      return function sqrt5mod8(Fp3, n) {
        const n2 = Fp3.mul(n, _2n2);
        const v = Fp3.pow(n2, c1);
        const nv = Fp3.mul(n, v);
        const i = Fp3.mul(Fp3.mul(nv, _2n2), v);
        const root = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
        if (!Fp3.eql(Fp3.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _16n === _9n) {
    }
    return tonelliShanks(P);
  }
  var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(f, num, power) {
    if (power < _0n2)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n2)
      return f.ONE;
    if (power === _1n2)
      return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n2) {
      if (power & _1n2)
        p = f.mul(p, d);
      d = f.sqr(d);
      power >>= _1n2;
    }
    return p;
  }
  function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = acc;
      return f.mul(acc, num);
    }, f.ONE);
    const inverted = f.inv(lastMultiplied);
    nums.reduceRight((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = f.mul(acc, tmp[i]);
      return f.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength(n, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n2)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n2,
      ONE: _1n2,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof num);
        return _0n2 <= num && num < ORDER;
      },
      is0: (num) => num === _0n2,
      isOdd: (num) => (num & _1n2) === _1n2,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n) => {
        if (!sqrtP)
          sqrtP = FpSqrt(ORDER);
        return sqrtP(f, n);
      }),
      invertBatch: (lst) => FpInvertBatch(f, lst),
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: (a, b, c) => c ? b : a,
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
        return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
      }
    });
    return Object.freeze(f);
  }

  // ../../node_modules/@noble/curves/esm/abstract/curve.js
  var _0n3 = BigInt(0);
  var _1n3 = BigInt(1);
  function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts(W, bits) {
    validateW(W, bits);
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  }
  function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
      throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c))
        throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
      throw new Error("array of scalars expected");
    scalars.forEach((s, i) => {
      if (!field.isValid(s))
        throw new Error("invalid scalar at index " + i);
    });
  }
  var pointPrecomputes = /* @__PURE__ */ new WeakMap();
  var pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function wNAF(c, bits) {
    return {
      constTimeNegate,
      hasPrecomputes(elm) {
        return getW(elm) !== 1;
      },
      // non-const time multiplication ladder
      unsafeLadder(elm, n, p = c.ZERO) {
        let d = elm;
        while (n > _0n3) {
          if (n & _1n3)
            p = p.add(d);
          d = d.double();
          n >>= _1n3;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param elm Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W) {
        const { windows, windowSize } = calcWOpts(W, bits);
        const points = [];
        let p = elm;
        let base2 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base2 = p;
          points.push(base2);
          for (let i = 1; i < windowSize; i++) {
            base2 = base2.add(p);
            points.push(base2);
          }
          p = base2.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        const { windows, windowSize } = calcWOpts(W, bits);
        let p = c.ZERO;
        let f = c.BASE;
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n3;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f = f.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p, f };
      },
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
        const { windows, windowSize } = calcWOpts(W, bits);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          if (n === _0n3)
            break;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n3;
          }
          if (wbits === 0)
            continue;
          let curr = precomputes[offset + Math.abs(wbits) - 1];
          if (wbits < 0)
            curr = curr.negate();
          acc = acc.add(curr);
        }
        return acc;
      },
      getPrecomputes(W, P, transform) {
        let comp = pointPrecomputes.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1)
            pointPrecomputes.set(P, transform(comp));
        }
        return comp;
      },
      wNAFCached(P, n, transform) {
        const W = getW(P);
        return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
      },
      wNAFCachedUnsafe(P, n, transform, prev) {
        const W = getW(P);
        if (W === 1)
          return this.unsafeLadder(P, n, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
      },
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      setWindowSize(P, W) {
        validateW(W, bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
    };
  }
  function pippenger(c, fieldN, points, scalars) {
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    if (points.length !== scalars.length)
      throw new Error("arrays of points and scalars must have equal length");
    const zero = c.ZERO;
    const wbits = bitLen(BigInt(points.length));
    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
    const MASK = (1 << windowSize) - 1;
    const buckets = new Array(MASK + 1).fill(zero);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero);
      for (let j = 0; j < scalars.length; j++) {
        const scalar = scalars[j];
        const wbits2 = Number(scalar >> BigInt(i) & BigInt(MASK));
        buckets[wbits2] = buckets[wbits2].add(points[j]);
      }
      let resI = zero;
      for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0)
        for (let j = 0; j < windowSize; j++)
          sum = sum.double();
    }
    return sum;
  }
  function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }

  // ../../node_modules/@noble/curves/esm/abstract/edwards.js
  var _0n4 = BigInt(0);
  var _1n4 = BigInt(1);
  var _2n3 = BigInt(2);
  var _8n2 = BigInt(8);
  var VERIFY_DEFAULT = { zip215: true };
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(curve, {
      hash: "function",
      a: "bigint",
      d: "bigint",
      randomBytes: "function"
    }, {
      adjustScalarBytes: "function",
      domain: "function",
      uvRatio: "function",
      mapToCurve: "function"
    });
    return Object.freeze({ ...opts });
  }
  function twistedEdwards(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp3, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes3, nByteLength, h: cofactor } = CURVE;
    const MASK = _2n3 << BigInt(nByteLength * 8) - _1n4;
    const modP = Fp3.create;
    const Fn = Field(CURVE.n, CURVE.nBitLength);
    const uvRatio3 = CURVE.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp3.sqrt(u * Fp3.inv(v)) };
      } catch (e) {
        return { isValid: false, value: _0n4 };
      }
    });
    const adjustScalarBytes3 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
    const domain = CURVE.domain || ((data, ctx, phflag) => {
      abool("phflag", phflag);
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    function aCoordinate(title, n) {
      aInRange("coordinate " + title, n, _0n4, MASK);
    }
    function assertPoint(other) {
      if (!(other instanceof Point))
        throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = memoized((p, iz) => {
      const { ex: x, ey: y, ez: z } = p;
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? _8n2 : Fp3.inv(z);
      const ax = modP(x * iz);
      const ay = modP(y * iz);
      const zz = modP(z * iz);
      if (is0)
        return { x: _0n4, y: _1n4 };
      if (zz !== _1n4)
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = memoized((p) => {
      const { a, d } = CURVE;
      if (p.is0())
        throw new Error("bad point: ZERO");
      const { ex: X, ey: Y, ez: Z, et: T } = p;
      const X2 = modP(X * X);
      const Y2 = modP(Y * Y);
      const Z2 = modP(Z * Z);
      const Z4 = modP(Z2 * Z2);
      const aX2 = modP(X2 * a);
      const left = modP(Z2 * modP(aX2 + Y2));
      const right = modP(Z4 + modP(d * modP(X2 * Y2)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X * Y);
      const ZT = modP(Z * T);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
      return true;
    });
    class Point {
      constructor(ex, ey, ez, et) {
        this.ex = ex;
        this.ey = ey;
        this.ez = ez;
        this.et = et;
        aCoordinate("x", ex);
        aCoordinate("y", ey);
        aCoordinate("z", ez);
        aCoordinate("t", et);
        Object.freeze(this);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p) {
        if (p instanceof Point)
          throw new Error("extended point not allowed");
        const { x, y } = p || {};
        aCoordinate("x", x);
        aCoordinate("y", y);
        return new Point(x, y, _1n4, modP(x * y));
      }
      static normalizeZ(points) {
        const toInv = Fp3.invertBatch(points.map((p) => p.ez));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      }
      // Multiscalar Multiplication
      static msm(points, scalars) {
        return pippenger(Point, Fn, points, scalars);
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        wnaf.setWindowSize(this, windowSize);
      }
      // Not required for fromHex(), which always creates valid points.
      // Could be useful for fromAffine().
      assertValidity() {
        assertValidMemo(this);
      }
      // Compare one point to another.
      equals(other) {
        assertPoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      negate() {
        return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
      }
      // Fast algo for doubling Extended Point.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
      // Cost: 4M + 4S + 1*a + 6add + 1*2.
      double() {
        const { a } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n3 * modP(Z1 * Z1));
        const D = modP(a * A);
        const x1y1 = X1 + Y1;
        const E = modP(modP(x1y1 * x1y1) - A - B);
        const G2 = D + B;
        const F = G2 - C;
        const H = D - B;
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point(X3, Y3, Z3, T3);
      }
      // Fast algo for adding 2 Extended Points.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
      // Cost: 9M + 1*a + 1*d + 7add.
      add(other) {
        assertPoint(other);
        const { a, d } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
        if (a === BigInt(-1)) {
          const A2 = modP((Y1 - X1) * (Y2 + X2));
          const B2 = modP((Y1 + X1) * (Y2 - X2));
          const F2 = modP(B2 - A2);
          if (F2 === _0n4)
            return this.double();
          const C2 = modP(Z1 * _2n3 * T2);
          const D2 = modP(T1 * _2n3 * Z2);
          const E2 = D2 + C2;
          const G3 = B2 + A2;
          const H2 = D2 - C2;
          const X32 = modP(E2 * F2);
          const Y32 = modP(G3 * H2);
          const T32 = modP(E2 * H2);
          const Z32 = modP(F2 * G3);
          return new Point(X32, Y32, Z32, T32);
        }
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T1 * d * T2);
        const D = modP(Z1 * Z2);
        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G2 = D + C;
        const H = modP(B - a * A);
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, n, Point.normalizeZ);
      }
      // Constant-time multiplication.
      multiply(scalar) {
        const n = scalar;
        aInRange("scalar", n, _1n4, CURVE_ORDER);
        const { p, f } = this.wNAF(n);
        return Point.normalizeZ([p, f])[0];
      }
      // Non-constant-time multiplication. Uses double-and-add algorithm.
      // It's faster, but should only be used when you don't care about
      // an exposed private key e.g. sig verification.
      // Does NOT allow scalars higher than CURVE.n.
      // Accepts optional accumulator to merge with multiply (important for sparse scalars)
      multiplyUnsafe(scalar, acc = Point.ZERO) {
        const n = scalar;
        aInRange("scalar", n, _0n4, CURVE_ORDER);
        if (n === _0n4)
          return I;
        if (this.is0() || n === _1n4)
          return this;
        return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);
      }
      // Checks if point is of small order.
      // If you add something to small order point, you will have "dirty"
      // point with torsion component.
      // Multiplies point by cofactor and checks if the result is 0.
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      // Multiplies point by curve order and checks if the result is 0.
      // Returns `false` is the point is dirty.
      isTorsionFree() {
        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
      }
      // Converts Extended point to default (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      toAffine(iz) {
        return toAffineMemo(this, iz);
      }
      clearCofactor() {
        const { h: cofactor2 } = CURVE;
        if (cofactor2 === _1n4)
          return this;
        return this.multiplyUnsafe(cofactor2);
      }
      // Converts hash string or Uint8Array to Point.
      // Uses algo from RFC8032 5.1.3.
      static fromHex(hex, zip215 = false) {
        const { d, a } = CURVE;
        const len = Fp3.BYTES;
        hex = ensureBytes("pointHex", hex, len);
        abool("zip215", zip215);
        const normed = hex.slice();
        const lastByte = hex[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y = bytesToNumberLE(normed);
        const max = zip215 ? MASK : Fp3.ORDER;
        aInRange("pointHex.y", y, _0n4, max);
        const y2 = modP(y * y);
        const u = modP(y2 - _1n4);
        const v = modP(d * y2 - a);
        let { isValid, value: x } = uvRatio3(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n4) === _1n4;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n4 && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP(-x);
        return Point.fromAffine({ x, y });
      }
      static fromPrivateKey(privKey) {
        return getExtendedPublicKey(privKey).point;
      }
      toRawBytes() {
        const { x, y } = this.toAffine();
        const bytes2 = numberToBytesLE(y, Fp3.BYTES);
        bytes2[bytes2.length - 1] |= x & _1n4 ? 128 : 0;
        return bytes2;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
    Point.ZERO = new Point(_0n4, _1n4, _1n4, _0n4);
    const { BASE: G, ZERO: I } = Point;
    const wnaf = wNAF(Point, nByteLength * 8);
    function modN(a) {
      return mod(a, CURVE_ORDER);
    }
    function modN_LE(hash) {
      return modN(bytesToNumberLE(hash));
    }
    function getExtendedPublicKey(key) {
      const len = Fp3.BYTES;
      key = ensureBytes("private key", key, len);
      const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes3(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      const point = G.multiply(scalar);
      const pointBytes = point.toRawBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
      const msg = concatBytes(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
    }
    function sign(msg, privKey, options = {}) {
      msg = ensureBytes("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R = G.multiply(r).toRawBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s = modN(r + k * scalar);
      aInRange("signature.s", s, _0n4, CURVE_ORDER);
      const res = concatBytes(R, numberToBytesLE(s, Fp3.BYTES));
      return ensureBytes("result", res, Fp3.BYTES * 2);
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = Fp3.BYTES;
      sig = ensureBytes("signature", sig, 2 * len);
      msg = ensureBytes("message", msg);
      publicKey = ensureBytes("publicKey", publicKey, len);
      if (zip215 !== void 0)
        abool("zip215", zip215);
      if (prehash)
        msg = prehash(msg);
      const s = bytesToNumberLE(sig.slice(len, 2 * len));
      let A, R, SB;
      try {
        A = Point.fromHex(publicKey, zip215);
        R = Point.fromHex(sig.slice(0, len), zip215);
        SB = G.multiplyUnsafe(s);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
    }
    G._setWindowSize(8);
    const utils = {
      getExtendedPublicKey,
      // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
      randomPrivateKey: () => randomBytes3(Fp3.BYTES),
      /**
       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
       * values. This slows down first getPublicKey() by milliseconds (see Speed section),
       * but allows to speed-up subsequent getPublicKey() calls up to 20x.
       * @param windowSize 2, 4, 8, 16
       */
      precompute(windowSize = 8, point = Point.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    return {
      CURVE,
      getPublicKey,
      sign,
      verify,
      ExtendedPoint: Point,
      utils
    };
  }

  // ../../node_modules/@noble/curves/esm/ed25519.js
  var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
  var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  var _0n5 = BigInt(0);
  var _1n5 = BigInt(1);
  var _2n4 = BigInt(2);
  var _3n2 = BigInt(3);
  var _5n2 = BigInt(5);
  var _8n3 = BigInt(8);
  function ed25519_pow_2_252_3(x) {
    const _10n2 = BigInt(10), _20n2 = BigInt(20), _40n2 = BigInt(40), _80n2 = BigInt(80);
    const P = ED25519_P;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2(b2, _2n4, P) * b2 % P;
    const b5 = pow2(b4, _1n5, P) * x % P;
    const b10 = pow2(b5, _5n2, P) * b5 % P;
    const b20 = pow2(b10, _10n2, P) * b10 % P;
    const b40 = pow2(b20, _20n2, P) * b20 % P;
    const b80 = pow2(b40, _40n2, P) * b40 % P;
    const b160 = pow2(b80, _80n2, P) * b80 % P;
    const b240 = pow2(b160, _80n2, P) * b80 % P;
    const b250 = pow2(b240, _10n2, P) * b10 % P;
    const pow_p_5_8 = pow2(b250, _2n4, P) * x % P;
    return { pow_p_5_8, b2 };
  }
  function adjustScalarBytes(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  }
  function uvRatio(u, v) {
    const P = ED25519_P;
    const v3 = mod(v * v * v, P);
    const v7 = mod(v3 * v3 * v, P);
    const pow4 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod(u * v3 * pow4, P);
    const vx2 = mod(v * x * x, P);
    const root1 = x;
    const root2 = mod(x * ED25519_SQRT_M1, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod(-u, P);
    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (isNegativeLE(x, P))
      x = mod(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  }
  var Fp = /* @__PURE__ */ (() => Field(ED25519_P, void 0, true))();
  var ed25519Defaults = /* @__PURE__ */ (() => ({
    // Param: a
    a: BigInt(-1),
    // Fp.create(-1) is proper; our way still works and is faster
    // d is equal to -121665/121666 over finite field.
    // Negative number is P - number, and division is invert(number, P)
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
    Fp,
    // Subgroup order: how many points curve has
    // 2n**252n + 27742317777372353535851937790883648493n;
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    // Cofactor
    h: _8n3,
    // Base point (x, y) aka generator point
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: sha512,
    randomBytes,
    adjustScalarBytes,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/√v
    uvRatio
  }))();
  var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();

  // ../../node_modules/@meer-js/crypto/dist/esm/crypto/src/key_pair_ed25519.js
  var import_randombytes = __toESM(require_browser2(), 1);
  var KeyPairEd25519 = class _KeyPairEd25519 extends KeyPairBase {
    secretKey;
    extendedSecretKey;
    publicKey;
    constructor(extendedSecretKey) {
      super();
      const decoded = baseDecode(extendedSecretKey);
      const secretKey = new Uint8Array(decoded.slice(0, KeySize.SECRET_KEY));
      const publicKey = ed25519.getPublicKey(new Uint8Array(secretKey));
      this.publicKey = { keyType: KeyType.ED25519, data: publicKey };
      this.secretKey = baseEncode(secretKey);
      this.extendedSecretKey = extendedSecretKey;
    }
    // Static factory method should remain public
    static fromRandom() {
      const secretKey = (0, import_randombytes.default)(KeySize.SECRET_KEY);
      const publicKey = ed25519.getPublicKey(new Uint8Array(secretKey));
      const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
      return new _KeyPairEd25519(baseEncode(extendedSecretKey));
    }
    // These methods should be public as they're core functionality
    sign(message) {
      const signature = ed25519.sign(message, baseDecode(this.secretKey));
      return { signature, publicKey: this.publicKey };
    }
    verify(message, signature) {
      if (this.publicKey?.verify) {
        return this.publicKey.verify(message, signature);
      }
      throw new Error("Public key or verify method is not defined.");
    }
    // These should be public as they're part of the interface
    toString() {
      return `ed25519:${this.extendedSecretKey}`;
    }
    getPublicKey() {
      return this.publicKey;
    }
  };

  // ../../node_modules/@meer-js/crypto/dist/esm/crypto/src/key_pair_secp256k1.js
  var import_secp256k1 = __toESM(require_elliptic3(), 1);
  var import_randombytes2 = __toESM(require_browser2(), 1);
  var KeyPairSecp256k1 = class _KeyPairSecp256k1 extends KeyPairBase {
    publicKey;
    secretKey;
    extendedSecretKey;
    /**
     * Construct an instance of key pair given a secret key.
     * It's generally assumed that these are encoded in base58.
     * @param {string} extendedSecretKey
     */
    constructor(extendedSecretKey) {
      super();
      const decoded = baseDecode(extendedSecretKey);
      const secretKey = new Uint8Array(decoded.slice(0, KeySize.SECRET_KEY));
      const withHeader = import_secp256k1.default.publicKeyCreate(new Uint8Array(secretKey), false);
      const data = withHeader.subarray(1, withHeader.length);
      this.publicKey = {
        keyType: KeyType.SECP256K1,
        data
      };
      this.secretKey = baseEncode(secretKey);
      this.extendedSecretKey = extendedSecretKey;
    }
    /**
     * Generate a new random keypair.
     * @example
     * const keyRandom = KeyPair.fromRandom();
     * keyRandom.publicKey
     * // returns [PUBLIC_KEY]
     *
     * keyRandom.secretKey
     * // returns [SECRET_KEY]
     */
    static fromRandom() {
      const secretKey = (0, import_randombytes2.default)(KeySize.SECRET_KEY);
      const withHeader = import_secp256k1.default.publicKeyCreate(new Uint8Array(secretKey), false);
      const publicKey = withHeader.subarray(1, withHeader.length);
      const extendedSecretKey = new Uint8Array([...secretKey, ...publicKey]);
      return new _KeyPairSecp256k1(baseEncode(extendedSecretKey));
    }
    sign(message) {
      const { signature, recid } = import_secp256k1.default.ecdsaSign(message, baseDecode(this.secretKey));
      return { signature: new Uint8Array([...signature, recid]), publicKey: this.publicKey };
    }
    verify(message, signature) {
      if (this.publicKey?.verify) {
        return this.publicKey.verify(message, signature);
      } else {
        throw new Error("Public key or verify method is not defined.");
      }
    }
    toString() {
      return `secp256k1:${this.extendedSecretKey}`;
    }
    getPublicKey() {
      return this.publicKey;
    }
  };

  // ../../node_modules/@meer-js/crypto/dist/esm/crypto/src/key_pair.js
  var KeyPair = class extends KeyPairBase {
    /**
     * @param curve Name of elliptical curve, case-insensitive
     * @returns Random KeyPair based on the curve
     */
    static fromRandom(curve) {
      switch (curve.toUpperCase()) {
        case "ED25519":
          return KeyPairEd25519.fromRandom();
        case "SECP256K1":
          return KeyPairSecp256k1.fromRandom();
        default:
          throw new Error(`Unknown curve ${curve}`);
      }
    }
    /**
     * Creates a key pair from an encoded key string.
     * @param encodedKey The encoded key string.
     * @returns {KeyPair} The key pair created from the encoded key string.
     */
    static fromString(encodedKey) {
      const parts = encodedKey.split(":");
      if (parts.length === 2) {
        switch (parts[0].toUpperCase()) {
          case "ED25519":
            return new KeyPairEd25519(parts[1]);
          case "SECP256K1":
            return new KeyPairSecp256k1(parts[1]);
          default:
            throw new Error(`Unknown curve: ${parts[0]}`);
        }
      } else {
        throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
      }
    }
  };

  // ../../node_modules/@meer-js/crypto/dist/esm/crypto/src/public_key.js
  var import_secp256k12 = __toESM(require_elliptic3(), 1);
  function strToKeyType(keyType) {
    switch (keyType.toLowerCase()) {
      case "ed25519":
        return KeyType.ED25519;
      case "secp256k1":
        return KeyType.SECP256K1;
      default:
        throw new Error(`Unknown key type ${keyType}`);
    }
  }
  function publicKeyFrom(value) {
    if (typeof value === "string") {
      return publicKeyFromString(value);
    }
    return value;
  }
  function publicKeyFromString(encodedKey) {
    const parts = encodedKey.split(":");
    let publicKeyPart;
    let keyType;
    if (parts.length === 1) {
      publicKeyPart = parts[0];
    } else if (parts.length === 2) {
      keyType = strToKeyType(parts[0]);
      publicKeyPart = parts[1];
    } else {
      throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
    }
    const decodedPublicKey = baseDecode(publicKeyPart);
    if (!keyType) {
      keyType = decodedPublicKey.length === KeySize.SECP256k1_PUBLIC_KEY ? KeyType.SECP256K1 : KeyType.ED25519;
    }
    const expectedKeySize = keyType === KeyType.ED25519 ? KeySize.ED25519_PUBLIC_KEY : KeySize.SECP256k1_PUBLIC_KEY;
    if (decodedPublicKey.length !== expectedKeySize) {
      throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${expectedKeySize}`);
    }
    return { keyType, data: decodedPublicKey };
  }

  // ../../node_modules/@meer-js/keystores/dist/esm/keystores/src/keystore.js
  var KeyStore = class {
  };

  // ../../node_modules/@meer-js/keystores/dist/esm/keystores/src/in_memory_key_store.js
  var InMemoryKeyStore = class extends KeyStore {
    /** @hidden */
    keys;
    constructor() {
      super();
      this.keys = {};
    }
    /**
     * Stores a {@link KeyPair} in in-memory storage item
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    async setKey(networkId, accountId, keyPair) {
      this.keys[`${accountId}:${networkId}`] = keyPair.toString();
    }
    /**
     * Gets a {@link KeyPair} from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId, accountId) {
      const value = this.keys[`${accountId}:${networkId}`];
      if (!value) {
        return null;
      }
      return KeyPair.fromString(value);
    }
    /**
     * Removes a {@link KeyPair} from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId, accountId) {
      delete this.keys[`${accountId}:${networkId}`];
    }
    /**
     * Removes all {@link KeyPair} from in-memory storage
     */
    async clear() {
      this.keys = {};
    }
    /**
     * Get the network(s) from in-memory storage
     * @returns {Promise<string[]>}
     */
    async getNetworks() {
      const result = /* @__PURE__ */ new Set();
      Object.keys(this.keys).forEach((key) => {
        const parts = key.split(":");
        result.add(parts[1]);
      });
      return Array.from(result.values());
    }
    /**
     * Gets the account(s) from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     */
    async getAccounts(networkId) {
      const result = new Array();
      Object.keys(this.keys).forEach((key) => {
        const parts = key.split(":");
        if (parts[parts.length - 1] === networkId) {
          result.push(parts.slice(0, parts.length - 1).join(":"));
        }
      });
      return result;
    }
    /** @hidden */
    toString() {
      return "InMemoryKeyStore";
    }
  };

  // ../../node_modules/@meer-js/keystores/dist/esm/keystores/src/merge_key_store.js
  var MergeKeyStore = class extends KeyStore {
    options;
    keyStores;
    /**
     * @param keyStores read calls are attempted from start to end of array
     * @param options KeyStore options
     * @param options.writeKeyStoreIndex the keystore index that will receive all write calls
     */
    constructor(keyStores, options = { writeKeyStoreIndex: 0 }) {
      super();
      this.options = options;
      this.keyStores = keyStores;
    }
    /**
     * Store a {@link KeyPair} to the first index of a key store array
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    async setKey(networkId, accountId, keyPair) {
      await this.keyStores[this.options.writeKeyStoreIndex].setKey(networkId, accountId, keyPair);
    }
    /**
     * Gets a {@link KeyPair} from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId, accountId) {
      for (const keyStore of this.keyStores) {
        const keyPair = await keyStore.getKey(networkId, accountId);
        if (keyPair) {
          return keyPair;
        }
      }
      return null;
    }
    /**
     * Removes a {@link KeyPair} from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId, accountId) {
      for (const keyStore of this.keyStores) {
        await keyStore.removeKey(networkId, accountId);
      }
    }
    /**
     * Removes all items from each key store
     */
    async clear() {
      for (const keyStore of this.keyStores) {
        await keyStore.clear();
      }
    }
    /**
     * Get the network(s) from the array of key stores
     * @returns {Promise<string[]>}
     */
    async getNetworks() {
      const result = /* @__PURE__ */ new Set();
      for (const keyStore of this.keyStores) {
        for (const network of await keyStore.getNetworks()) {
          result.add(network);
        }
      }
      return Array.from(result);
    }
    /**
     * Gets the account(s) from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     */
    async getAccounts(networkId) {
      const result = /* @__PURE__ */ new Set();
      for (const keyStore of this.keyStores) {
        for (const account of await keyStore.getAccounts(networkId)) {
          result.add(account);
        }
      }
      return Array.from(result);
    }
    /** @hidden */
    toString() {
      return `MergeKeyStore(${this.keyStores.join(", ")})`;
    }
  };

  // ../../node_modules/@meer-js/keystores-browser/dist/esm/keystores-browser/src/browser_local_storage_key_store.js
  var LOCAL_STORAGE_KEY_PREFIX = "meer-api-js:keystore:";
  var BrowserLocalStorageKeyStore = class extends KeyStore {
    /** @hidden */
    localStorage;
    /** @hidden */
    prefix;
    /**
     * @param localStorage defaults to window.localStorage
     * @param prefix defaults to `meer-api-js:keystore:`
     */
    constructor(localStorage2 = window.localStorage, prefix = LOCAL_STORAGE_KEY_PREFIX) {
      super();
      this.localStorage = localStorage2;
      this.prefix = prefix;
    }
    /**
     * Stores a {@link KeyPair} in local storage.
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    async setKey(networkId, accountId, keyPair) {
      this.localStorage.setItem(this.storageKeyForSecretKey(networkId, accountId), keyPair.toString());
    }
    /**
     * Gets a {@link KeyPair} from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId, accountId) {
      const value = this.localStorage.getItem(this.storageKeyForSecretKey(networkId, accountId));
      if (!value) {
        return null;
      }
      return KeyPair.fromString(value);
    }
    /**
     * Removes a {@link KeyPair} from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId, accountId) {
      this.localStorage.removeItem(this.storageKeyForSecretKey(networkId, accountId));
    }
    /**
     * Removes all items that start with `prefix` from local storage
     */
    async clear() {
      for (const key of this.storageKeys()) {
        if (key.startsWith(this.prefix)) {
          this.localStorage.removeItem(key);
        }
      }
    }
    /**
     * Get the network(s) from local storage
     * @returns {Promise<string[]>}
     */
    async getNetworks() {
      const result = /* @__PURE__ */ new Set();
      for (const key of this.storageKeys()) {
        if (key.startsWith(this.prefix)) {
          const parts = key.substring(this.prefix.length).split(":");
          result.add(parts[1]);
        }
      }
      return Array.from(result.values());
    }
    /**
     * Gets the account(s) from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     */
    async getAccounts(networkId) {
      const result = new Array();
      for (const key of this.storageKeys()) {
        if (key.startsWith(this.prefix)) {
          const parts = key.substring(this.prefix.length).split(":");
          if (parts[1] === networkId) {
            result.push(parts[0]);
          }
        }
      }
      return result;
    }
    /**
     * @hidden
     * Helper function to retrieve a local storage key
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account tied to the storage key that's sought
     * @returns {string} An example might be: `meer-api-js:keystore:near-friend:default`
     */
    storageKeyForSecretKey(networkId, accountId) {
      return `${this.prefix}${accountId}:${networkId}`;
    }
    /** @hidden */
    *storageKeys() {
      for (let i = 0; i < this.localStorage.length; i++) {
        yield this.localStorage.key(i);
      }
    }
  };

  // ../../node_modules/@meer-js/providers/dist/esm/providers/src/exponential-backoff.js
  async function exponentialBackoff(startWaitTime, retryNumber, waitBackoff, getResult) {
    let waitTime = startWaitTime;
    for (let i = 0; i < retryNumber; i++) {
      const result = await getResult();
      if (result) {
        return result;
      }
      await sleep(waitTime);
      waitTime *= waitBackoff;
    }
    return null;
  }
  function sleep(millis) {
    return new Promise((resolve) => setTimeout(resolve, millis));
  }

  // ../../node_modules/@meer-js/transactions/dist/esm/transactions/src/actions.js
  var FunctionCallPermission = class {
    allowance;
    receiverId;
    methodNames;
    constructor({ allowance, receiverId, methodNames }) {
      this.allowance = allowance;
      this.receiverId = receiverId;
      this.methodNames = methodNames;
    }
  };
  var FullAccessPermission = class {
  };
  var AccessKeyPermission = class extends Enum {
    enum;
    functionCall;
    fullAccess;
    constructor(props) {
      super(props);
      for (const [k, v] of Object.entries(props || {})) {
        this[k] = v;
        this.enum = k;
      }
    }
  };
  var AccessKey = class {
    nonce;
    permission;
    constructor({ nonce, permission }) {
      this.nonce = nonce;
      this.permission = permission;
    }
  };
  var CreateAccount = class {
  };
  var DeployContract = class {
    code;
    constructor({ code }) {
      this.code = code;
    }
  };
  var FunctionCall = class {
    methodName;
    args;
    gas;
    deposit;
    constructor({ methodName, args, gas, deposit }) {
      this.methodName = methodName;
      this.args = args;
      this.gas = gas;
      this.deposit = deposit;
    }
  };
  var Transfer = class {
    deposit;
    constructor({ deposit }) {
      this.deposit = deposit;
    }
  };
  var Stake = class {
    stake;
    publicKey;
    constructor({ stake: stake4, publicKey }) {
      this.stake = stake4;
      this.publicKey = publicKey;
    }
  };
  var AddKey = class {
    publicKey;
    accessKey;
    constructor({ publicKey, accessKey }) {
      this.publicKey = publicKey;
      this.accessKey = accessKey;
    }
  };
  var DeleteKey = class {
    publicKey;
    constructor({ publicKey }) {
      this.publicKey = publicKey;
    }
  };
  var DeleteAccount = class {
    beneficiaryId;
    constructor({ beneficiaryId }) {
      this.beneficiaryId = beneficiaryId;
    }
  };
  var SignedDelegate = class {
    delegateAction;
    signature;
    constructor({ delegateAction, signature }) {
      this.delegateAction = delegateAction;
      this.signature = signature;
    }
  };
  var Action = class extends Enum {
    enum;
    createAccount;
    deployContract;
    functionCall;
    transfer;
    stake;
    addKey;
    deleteKey;
    deleteAccount;
    signedDelegate;
    constructor(props) {
      super(props);
      for (const [k, v] of Object.entries(props || {})) {
        this[k] = v;
        this.enum = k;
      }
    }
  };

  // ../../node_modules/@meer-js/transactions/dist/esm/transactions/src/action_creators.js
  function fullAccessKey() {
    return new AccessKey({
      nonce: 0n,
      permission: new AccessKeyPermission({
        fullAccess: new FullAccessPermission()
      })
    });
  }
  function functionCallAccessKey(receiverId, methodNames, allowance) {
    return new AccessKey({
      nonce: 0n,
      permission: new AccessKeyPermission({
        functionCall: new FunctionCallPermission({
          receiverId,
          allowance,
          methodNames
        })
      })
    });
  }
  function createAccount() {
    return new Action({ createAccount: new CreateAccount() });
  }
  function deployContract(code) {
    return new Action({ deployContract: new DeployContract({ code }) });
  }
  function stringifyJsonOrBytes(args) {
    const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
    return isUint8Array ? args : Buffer.from(JSON.stringify(args));
  }
  function functionCall(methodName, args, gas = 0n, deposit = 0n, stringify = stringifyJsonOrBytes, jsContract = false) {
    console.log("alohanaj action creator functionCall", methodName, args, gas, deposit);
    if (jsContract) {
      return new Action({
        functionCall: new FunctionCall({ methodName, args, gas, deposit })
      });
    }
    console.log("alohanaj jic after jsContract thing");
    return new Action({
      functionCall: new FunctionCall({
        methodName,
        args: stringify(args),
        gas,
        deposit
      })
    });
  }
  function transfer(deposit = 0n) {
    return new Action({ transfer: new Transfer({ deposit }) });
  }
  function stake(stake4 = 0n, publicKey) {
    return new Action({ stake: new Stake({ stake: stake4, publicKey }) });
  }
  function addKey(publicKey, accessKey) {
    return new Action({ addKey: new AddKey({ publicKey, accessKey }) });
  }
  function deleteKey(publicKey) {
    return new Action({ deleteKey: new DeleteKey({ publicKey }) });
  }
  function deleteAccount(beneficiaryId) {
    return new Action({ deleteAccount: new DeleteAccount({ beneficiaryId }) });
  }
  function signedDelegate({ delegateAction, signature }) {
    return new Action({
      signedDelegate: new SignedDelegate({ delegateAction, signature })
    });
  }
  var actionCreators = {
    addKey,
    createAccount,
    deleteAccount,
    deleteKey,
    deployContract,
    fullAccessKey,
    functionCall,
    functionCallAccessKey,
    signedDelegate,
    stake,
    transfer
  };

  // ../../node_modules/@meer-js/transactions/dist/esm/transactions/src/schema.js
  function encodeDelegateAction(delegateAction) {
    return new Uint8Array([
      ...serialize(SCHEMA2.DelegateActionPrefix, {}),
      ...serialize(SCHEMA2.DelegateAction, delegateAction)
    ]);
  }
  function encodeTransaction(transaction) {
    const schema = "signature" in transaction ? SCHEMA2.SignedTransaction : SCHEMA2.Transaction;
    return serialize(schema, transaction);
  }
  function decodeTransaction(bytes2) {
    return deserialize(SCHEMA2.Transaction, bytes2);
  }
  function decodeSignedTransaction(bytes2) {
    return deserialize(SCHEMA2.SignedTransaction, bytes2);
  }
  var Transaction = class {
    signerId;
    publicKey;
    nonce;
    receiverId;
    actions;
    blockHash;
    constructor({ signerId, publicKey, nonce, receiverId, actions, blockHash }) {
      this.signerId = signerId;
      this.publicKey = publicKey;
      this.nonce = nonce;
      this.receiverId = receiverId;
      this.actions = actions;
      this.blockHash = blockHash;
    }
    encode() {
      return encodeTransaction(this);
    }
    static decode(bytes2) {
      return decodeTransaction(bytes2);
    }
  };
  var SignedTransaction = class {
    transaction;
    signature;
    constructor({ transaction, signature }) {
      this.transaction = transaction;
      this.signature = signature;
    }
    encode() {
      return encodeTransaction(this.transaction);
    }
    static decode(bytes2) {
      return decodeSignedTransaction(bytes2);
    }
  };
  var SCHEMA2 = {
    Ed25519Signature: {
      struct: {
        data: { array: { type: "u8", len: 64 } }
      }
    },
    Secp256k1Signature: {
      struct: {
        data: { array: { type: "u8", len: 65 } }
      }
    },
    Signature: {
      enum: [
        { struct: { ed25519Signature: "Ed25519Signature" } },
        { struct: { secp256k1Signature: "Secp256k1Signature" } }
      ]
    },
    Ed25519Data: {
      struct: {
        data: { array: { type: "u8", len: 32 } }
      }
    },
    Secp256k1Data: {
      struct: {
        data: { array: { type: "u8", len: 64 } }
      }
    },
    PublicKey: {
      enum: [
        { struct: { ed25519Key: "Ed25519Data" } },
        { struct: { secp256k1Key: "Secp256k1Data" } }
      ]
    },
    FunctionCallPermission: {
      struct: {
        allowance: { option: "u128" },
        receiverId: "string",
        methodNames: { array: { type: "string" } }
      }
    },
    FullAccessPermission: {
      struct: {}
    },
    AccessKeyPermission: {
      enum: [
        { struct: { functionCall: "FunctionCallPermission" } },
        { struct: { fullAccess: "FullAccessPermission" } }
      ]
    },
    AccessKey: {
      struct: {
        nonce: "u64",
        permission: "AccessKeyPermission"
      }
    },
    CreateAccount: {
      struct: {}
    },
    DeployContract: {
      struct: {
        code: { array: { type: "u8" } }
      }
    },
    FunctionCall: {
      struct: {
        methodName: "string",
        args: { array: { type: "u8" } },
        gas: "u64",
        deposit: "u128"
      }
    },
    Transfer: {
      struct: {
        deposit: "u128"
      }
    },
    Stake: {
      struct: {
        stake: "u128",
        publicKey: "PublicKey"
      }
    },
    AddKey: {
      struct: {
        publicKey: "PublicKey",
        accessKey: "AccessKey"
      }
    },
    DeleteKey: {
      struct: {
        publicKey: "PublicKey"
      }
    },
    DeleteAccount: {
      struct: {
        beneficiaryId: "string"
      }
    },
    DelegateActionPrefix: {
      struct: {
        prefix: "u32"
      }
    },
    ClassicActions: {
      enum: [
        { struct: { createAccount: "CreateAccount" } },
        { struct: { deployContract: "DeployContract" } },
        { struct: { functionCall: "FunctionCall" } },
        { struct: { transfer: "Transfer" } },
        { struct: { stake: "Stake" } },
        { struct: { addKey: "AddKey" } },
        { struct: { deleteKey: "DeleteKey" } },
        { struct: { deleteAccount: "DeleteAccount" } }
      ]
    },
    DelegateAction: {
      struct: {
        senderId: "string",
        receiverId: "string",
        actions: { array: { type: "ClassicActions" } },
        nonce: "u64",
        maxBlockHeight: "u64",
        publicKey: "PublicKey"
      }
    },
    SignedDelegate: {
      struct: {
        delegateAction: "DelegateAction",
        signature: "Signature"
      }
    },
    Action: {
      enum: [
        { struct: { createAccount: "CreateAccount" } },
        { struct: { deployContract: "DeployContract" } },
        { struct: { functionCall: "FunctionCall" } },
        { struct: { transfer: "Transfer" } },
        { struct: { stake: "Stake" } },
        { struct: { addKey: "AddKey" } },
        { struct: { deleteKey: "DeleteKey" } },
        { struct: { deleteAccount: "DeleteAccount" } },
        { struct: { signedDelegate: "SignedDelegate" } }
      ]
    },
    Transaction: {
      struct: {
        signerId: "string",
        publicKey: "PublicKey",
        nonce: "u64",
        receiverId: "string",
        blockHash: { array: { type: "u8", len: 32 } },
        actions: { array: { type: "Action" } }
      }
    },
    SignedTransaction: {
      struct: {
        transaction: "Transaction",
        signature: "Signature"
      }
    }
  };

  // ../../node_modules/@meer-js/transactions/dist/esm/transactions/src/create_transaction.js
  function createTransaction(signerId, publicKey, receiverId, nonce, actions, blockHash) {
    const txNonce = typeof nonce === "bigint" ? nonce : BigInt(nonce);
    return new Transaction({
      signerId,
      publicKey,
      nonce: txNonce,
      receiverId,
      actions,
      blockHash
    });
  }

  // ../../node_modules/@meer-js/transactions/dist/esm/transactions/src/delegate.js
  var DelegateAction = class {
    senderId;
    receiverId;
    actions;
    nonce;
    maxBlockHeight;
    publicKey;
    constructor({ senderId, receiverId, actions, nonce, maxBlockHeight, publicKey }) {
      this.senderId = senderId;
      this.receiverId = receiverId;
      this.actions = actions;
      this.nonce = nonce;
      this.maxBlockHeight = maxBlockHeight;
      this.publicKey = publicKey;
    }
  };
  var { addKey: addKey2, createAccount: createAccount2, deleteAccount: deleteAccount2, deleteKey: deleteKey2, deployContract: deployContract2, functionCall: functionCall2, stake: stake2, transfer: transfer2 } = actionCreators;
  function buildDelegateAction({ actions, maxBlockHeight, nonce, publicKey, receiverId, senderId }) {
    return new DelegateAction({
      senderId,
      receiverId,
      actions: actions.map((a) => {
        if (!a.type && !a.params) {
          return a;
        }
        switch (a.type) {
          case "AddKey": {
            const { publicKey: publicKey2, accessKey } = a.params;
            return addKey2(publicKey2, accessKey);
          }
          case "CreateAccount": {
            return createAccount2(a.params.createAccount);
          }
          case "DeleteAccount": {
            return deleteAccount2(a.params.deleteAccount);
          }
          case "DeleteKey": {
            return deleteKey2(a.params.publicKey);
          }
          case "DeployContract": {
            return deployContract2(a.params.code);
          }
          case "FunctionCall": {
            const { methodName, args, gas, deposit } = a.params;
            return functionCall2(methodName, args, gas, deposit);
          }
          case "Stake": {
            return stake2(a.params.stake, a.params.publicKey);
          }
          case "Transfer": {
            const { deposit } = a.params;
            return transfer2(deposit);
          }
        }
        throw new Error("Unrecognized action");
      }),
      nonce,
      maxBlockHeight,
      publicKey
    });
  }

  // ../../node_modules/@noble/hashes/esm/_assert.js
  function isBytes3(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abytes3(b, ...lengths) {
    if (!isBytes3(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function aexists2(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput2(out, instance) {
    abytes3(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }

  // ../../node_modules/@noble/hashes/esm/utils.js
  var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  function utf8ToBytes2(str) {
    if (typeof str !== "string")
      throw new Error("utf8ToBytes expected string, got " + typeof str);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes2(data) {
    if (typeof data === "string")
      data = utf8ToBytes2(data);
    abytes3(data);
    return data;
  }
  var Hash2 = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  function wrapConstructor2(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }

  // ../../node_modules/@noble/hashes/esm/_md.js
  function setBigUint642(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n3 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n3 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  var Chi = (a, b, c) => a & b ^ ~a & c;
  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  var HashMD2 = class extends Hash2 {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView2(this.buffer);
    }
    update(data) {
      aexists2(this);
      const { view, buffer, blockLen } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView2(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists2(this);
      aoutput2(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView2(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../../node_modules/@noble/hashes/esm/sha256.js
  var SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends HashMD2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha256 = /* @__PURE__ */ wrapConstructor2(() => new SHA256());

  // ../../node_modules/@meer-js/transactions/dist/esm/transactions/src/ISignatureTx.js
  function resolveEnumKeyName(keyType) {
    switch (keyType) {
      case KeyType.ED25519:
        return "ed25519Signature";
      case KeyType.SECP256K1:
        return "secp256k1Signature";
      default:
        throw Error(`unknown type ${keyType}`);
    }
  }
  function createSignature(signature) {
    const keyName = resolveEnumKeyName(signature.keyType);
    return { [keyName]: signature };
  }

  // ../../node_modules/@meer-js/transactions/dist/esm/transactions/src/sign.js
  async function signTransactionObject(transaction, signer, accountId, networkId) {
    const message = encodeTransaction(transaction);
    const hash = new Uint8Array(sha256(message));
    const signature = await signer.signMessage(message, accountId, networkId);
    const keyType = transaction.publicKey.keyType;
    const signedTx = new SignedTransaction({
      transaction,
      signature: createSignature({ keyType, data: signature.signature })
    });
    return [hash, signedTx];
  }
  async function signTransaction(...args) {
    if (args[0].constructor === Transaction) {
      const [transaction, signer, accountId, networkId] = args;
      return signTransactionObject(transaction, signer, accountId, networkId);
    } else {
      const [receiverId, nonce, actions, blockHash, signer, accountId, networkId] = args;
      const publicKey = await signer.getPublicKey(accountId, networkId);
      const transaction = createTransaction(accountId, publicKey, receiverId, nonce, actions, blockHash);
      return signTransactionObject(transaction, signer, accountId, networkId);
    }
  }
  async function signDelegateAction({ delegateAction, signer }) {
    const message = encodeDelegateAction(delegateAction);
    const signature = await signer.sign(message);
    const keyType = delegateAction.publicKey.keyType;
    const delegateSignature = createSignature({
      keyType,
      data: signature
    });
    const signedDelegateAction = {
      delegateAction,
      signature: delegateSignature
    };
    return {
      hash: new Uint8Array(sha256(message)),
      signedDelegateAction
    };
  }

  // ../../node_modules/@meer-js/providers/dist/esm/providers/src/provider.js
  var Provider = class {
  };

  // ../../node_modules/@meer-js/providers/dist/esm/providers/src/json-rpc-provider.js
  var REQUEST_RETRY_NUMBER = 12;
  var REQUEST_RETRY_WAIT = 500;
  var REQUEST_RETRY_WAIT_BACKOFF = 1.5;
  var _nextId = 123;
  var JsonRpcProvider = class extends Provider {
    /** @hidden */
    connection;
    /** @hidden */
    options;
    /**
     * @param connectionInfo Connection info
     */
    constructor(connectionInfo, options) {
      super();
      this.connection = connectionInfo || { url: "" };
      const defaultOptions = {
        retries: REQUEST_RETRY_NUMBER,
        wait: REQUEST_RETRY_WAIT,
        backoff: REQUEST_RETRY_WAIT_BACKOFF
      };
      this.options = Object.assign({}, defaultOptions, options);
    }
    /**
     * Gets the RPC's status
     * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
     */
    async status() {
      return this.sendJsonRpc("status", []);
    }
    /**
     * Sends a signed transaction to the RPC
     *
     * @param signedTransaction The signed transaction being sent
     * @param waitUntil
     */
    async sendTransactionUntil(signedTransaction, waitUntil) {
      const bytes2 = encodeTransaction(signedTransaction.transaction);
      return this.sendJsonRpc("send_tx", { signed_tx_base64: Buffer.from(bytes2).toString("base64"), wait_until: waitUntil });
    }
    /**
     * Sends a signed transaction to the RPC and waits until transaction is fully complete
     * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
     *
     * @param signedTransaction The signed transaction being sent
     */
    async sendTransaction(signedTransaction) {
      return this.sendTransactionUntil(signedTransaction, "EXECUTED_OPTIMISTIC");
    }
    /**
     * Sends a signed transaction to the RPC and immediately returns transaction hash
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
     * @param signedTransaction The signed transaction being sent
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async sendTransactionAsync(signedTransaction) {
      return this.sendTransactionUntil(signedTransaction, "NONE");
    }
    /**
     * Gets a transaction's status from the RPC
     * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
     *
     * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
     * @param accountId The NEAR account that signed the transaction
     * @param waitUntil
     */
    async txStatus(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
      if (typeof txHash === "string") {
        return this.txStatusString(txHash, accountId, waitUntil);
      } else {
        return this.txStatusUint8Array(txHash, accountId, waitUntil);
      }
    }
    async txStatusUint8Array(txHash, accountId, waitUntil) {
      return this.sendJsonRpc("tx", { tx_hash: baseEncode(txHash), sender_account_id: accountId, wait_until: waitUntil });
    }
    async txStatusString(txHash, accountId, waitUntil) {
      return this.sendJsonRpc("tx", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
    }
    /**
     * Gets a transaction's status from the RPC with receipts
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
     * @param txHash The hash of the transaction
     * @param accountId The NEAR account that signed the transaction
     * @param waitUntil
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async txStatusReceipts(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
      if (typeof txHash === "string") {
        return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
      } else {
        return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: baseEncode(txHash), sender_account_id: accountId, wait_until: waitUntil });
      }
    }
    /**
     * Query the RPC by passing an {@link "@near-js/types".provider/request.RpcQueryRequest | RpcQueryRequest }
     * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
     *
     * @typeParam T the shape of the returned query response
     */
    async query(...args) {
      let result;
      if (args.length === 1) {
        const { block_id, blockId, ...otherParams } = args[0];
        result = await this.sendJsonRpc("query", { ...otherParams, block_id: block_id || blockId });
      } else {
        const [path, data] = args;
        result = await this.sendJsonRpc("query", [path, data]);
      }
      if (result && result.error) {
        throw new TypedError(`Querying failed: ${result.error}.
${JSON.stringify(result, null, 2)}`, getErrorTypeFromErrorMessage(result.error, result.error.name));
      }
      return result;
    }
    /**
     * Query for block info from the RPC
     * pass block_id OR finality as blockQuery, not both
     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
     *
     * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
     */
    async block(blockQuery) {
      const { finality } = blockQuery;
      const { blockId } = blockQuery;
      return this.sendJsonRpc("block", { block_id: blockId, finality });
    }
    /**
     * Query changes in block from the RPC
     * pass block_id OR finality as blockQuery, not both
     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
     */
    async blockChanges(blockQuery) {
      const { finality } = blockQuery;
      const { blockId } = blockQuery;
      return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", { block_id: blockId, finality });
    }
    /**
     * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
     *
     * @param chunkId Hash of a chunk ID or shard ID
     */
    async chunk(chunkId) {
      return this.sendJsonRpc("chunk", [chunkId]);
    }
    /**
     * Query validators of the epoch defined by the given block id.
     * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
     *
     * @param blockId Block hash or height, or null for latest.
     */
    async validators(blockId) {
      return this.sendJsonRpc("validators", [blockId]);
    }
    /**
     * Gets the protocol config at a block from RPC
     *
     * @param blockReference specifies the block to get the protocol config for
     */
    async experimental_protocolConfig(blockReference) {
      const { blockId, ...otherParams } = blockReference;
      return await this.sendJsonRpc("EXPERIMENTAL_protocol_config", { ...otherParams, block_id: blockId });
    }
    /**
     * Gets a light client execution proof for verifying execution outcomes
     * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
     */
    async lightClientProof(request) {
      return await this.sendJsonRpc("EXPERIMENTAL_light_client_proof", request);
    }
    /**
     * Returns the next light client block as far in the future as possible from the last known hash
     * to still be able to validate from that hash. This will either return the last block of the
     * next epoch, or the last final known block.
     *
     * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
     */
    async nextLightClientBlock(request) {
      return await this.sendJsonRpc("next_light_client_block", request);
    }
    /**
     * Gets access key changes for a given array of accountIds
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
     * @returns {Promise<ChangeResult>}
     */
    async accessKeyChanges(accountIdArray, blockQuery) {
      const { finality } = blockQuery;
      const { blockId } = blockQuery;
      return this.sendJsonRpc("EXPERIMENTAL_changes", {
        changes_type: "all_access_key_changes",
        account_ids: accountIdArray,
        block_id: blockId,
        finality
      });
    }
    /**
     * Gets single access key changes for a given array of access keys
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
     * @returns {Promise<ChangeResult>}
     */
    async singleAccessKeyChanges(accessKeyArray, blockQuery) {
      const { finality } = blockQuery;
      const { blockId } = blockQuery;
      return this.sendJsonRpc("EXPERIMENTAL_changes", {
        changes_type: "single_access_key_changes",
        keys: accessKeyArray,
        block_id: blockId,
        finality
      });
    }
    /**
     * Gets account changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
     * @returns {Promise<ChangeResult>}
     */
    async accountChanges(accountIdArray, blockQuery) {
      const { finality } = blockQuery;
      const { blockId } = blockQuery;
      return this.sendJsonRpc("EXPERIMENTAL_changes", {
        changes_type: "account_changes",
        account_ids: accountIdArray,
        block_id: blockId,
        finality
      });
    }
    /**
     * Gets contract state changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: If you pass a keyPrefix it must be base64 encoded
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
     * @returns {Promise<ChangeResult>}
     */
    async contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
      const { finality } = blockQuery;
      const { blockId } = blockQuery;
      return this.sendJsonRpc("EXPERIMENTAL_changes", {
        changes_type: "data_changes",
        account_ids: accountIdArray,
        key_prefix_base64: keyPrefix,
        block_id: blockId,
        finality
      });
    }
    /**
     * Gets contract code changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: Change is returned in a base64 encoded WASM file
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
     * @returns {Promise<ChangeResult>}
     */
    async contractCodeChanges(accountIdArray, blockQuery) {
      const { finality } = blockQuery;
      const { blockId } = blockQuery;
      return this.sendJsonRpc("EXPERIMENTAL_changes", {
        changes_type: "contract_code_changes",
        account_ids: accountIdArray,
        block_id: blockId,
        finality
      });
    }
    /**
     * Returns gas price for a specific block_height or block_hash.
     * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
     *
     * @param blockId Block hash or height, or null for latest.
     */
    async gasPrice(blockId) {
      return await this.sendJsonRpc("gas_price", [blockId]);
    }
    async sendJsonRpc(method, params2) {
      const response = await exponentialBackoff(this.options.wait, this.options.retries, this.options.backoff, async () => {
        try {
          const request = {
            method,
            params: params2,
            id: _nextId++,
            jsonrpc: "2.0"
          };
          const fetchResponse = await fetch(this.connection.url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              ...this.connection.headers || {}
            },
            body: JSON.stringify(request)
          });
          if (!fetchResponse.ok) {
            const errorText = await fetchResponse.text();
            throw new TypedError(`HTTP error! status: ${fetchResponse.status} - ${errorText}`, "HTTPError");
          }
          const response2 = await fetchResponse.json();
          if (response2.error) {
            if (typeof response2.error.data === "object") {
              if (typeof response2.error.data.error_message === "string" && typeof response2.error.data.error_type === "string") {
                throw new TypedError(response2.error.data.error_message, response2.error.data.error_type);
              }
              throw parseRpcError(response2.error.data);
            } else {
              const errorMessage = `[${response2.error.code}] ${response2.error.message}: ${response2.error.data}`;
              if (response2.error.data === "Timeout" || errorMessage.includes("Timeout error") || errorMessage.includes("query has timed out")) {
                throw new TypedError(errorMessage, "TimeoutError");
              }
              const errorType = getErrorTypeFromErrorMessage(response2.error.data, "");
              if (errorType) {
                throw new TypedError(formatError(errorType, params2), errorType);
              }
              throw new TypedError(errorMessage, response2.error.name);
            }
          } else if (typeof response2.result?.error === "string") {
            const errorType = getErrorTypeFromErrorMessage(response2.result.error, "");
            if (errorType) {
              throw new ServerError(formatError(errorType, params2), errorType);
            }
          }
          return response2;
        } catch (error) {
          if (error instanceof TypedError) {
            throw error;
          }
          if (error.message?.includes("Timeout") || error.message?.includes("NetworkError") || error.message?.includes("Failed to fetch")) {
            Logger.warn(`Retrying request to ${method} as it has timed out or failed`, params2);
            return null;
          }
          throw new TypedError(error.message || "Unknown error occurred", error.name || "UnknownError");
        }
      });
      const { result } = response;
      if (typeof result === "undefined") {
        throw new TypedError(`Exceeded ${this.options.retries} attempts for request to ${method}.`, "RetriesExceeded");
      }
      return result;
    }
  };

  // ../../node_modules/@meer-js/providers/dist/esm/providers/src/failover-rpc-provider.js
  var FailoverRpcProvider = class extends Provider {
    /** @hidden */
    providers;
    currentProviderIndex;
    /**
     * @param providers list of providers
     */
    constructor(providers) {
      super();
      if (providers.length === 0) {
        throw new Error("At least one provider must be specified");
      }
      this.providers = providers;
      this.currentProviderIndex = 0;
    }
    switchToNextProvider() {
      if (this.providers.length === 1)
        return;
      if (this.providers.length - 1 <= this.currentProviderIndex) {
        this.currentProviderIndex = 0;
      } else {
        this.currentProviderIndex += 1;
      }
      Logger.debug(`Switched to provider at the index ${this.currentProviderIndex}`);
    }
    get currentProvider() {
      const provider = this.providers[this.currentProviderIndex];
      if (!provider)
        throw new Error(`Provider wasn't found at index ${this.currentProviderIndex}`);
      return provider;
    }
    async withBackoff(getResult) {
      for (let i = 0; i < this.providers.length; i++) {
        try {
          const result = await getResult(this.currentProvider);
          if (result)
            return result;
        } catch {
          this.switchToNextProvider();
        }
      }
      throw new TypedError(`Exceeded ${this.providers.length} providers to execute request`, "RetriesExceeded");
    }
    /**
     * Gets the RPC's status
     * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
     */
    async status() {
      return this.withBackoff((currentProvider) => currentProvider.status());
    }
    async sendTransactionUntil(signedTransaction, waitUntil) {
      return this.withBackoff((currentProvider) => currentProvider.sendTransactionUntil(signedTransaction, waitUntil));
    }
    /**
     * Sends a signed transaction to the RPC and waits until transaction is fully complete
     * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
     *
     * @param signedTransaction The signed transaction being sent
     */
    async sendTransaction(signedTransaction) {
      return this.withBackoff((currentProvider) => currentProvider.sendTransaction(signedTransaction));
    }
    /**
     * Sends a signed transaction to the RPC and immediately returns transaction hash
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
     * @param signedTransaction The signed transaction being sent
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async sendTransactionAsync(signedTransaction) {
      return this.withBackoff((currentProvider) => currentProvider.sendTransactionAsync(signedTransaction));
    }
    /**
     * Gets a transaction's status from the RPC
     * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
     *
     * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
     * @param accountId The NEAR account that signed the transaction
     */
    async txStatus(txHash, accountId, waitUntil) {
      return this.withBackoff((currentProvider) => currentProvider.txStatus(txHash, accountId, waitUntil));
    }
    /**
     * Gets a transaction's status from the RPC with receipts
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
     * @param txHash The hash of the transaction
     * @param accountId The NEAR account that signed the transaction
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async txStatusReceipts(txHash, accountId, waitUntil) {
      return this.withBackoff((currentProvider) => currentProvider.txStatusReceipts(txHash, accountId, waitUntil));
    }
    async query(paramsOrPath, data) {
      if (data) {
        return this.withBackoff((currentProvider) => currentProvider.query(paramsOrPath, data));
      }
      return this.withBackoff((currentProvider) => currentProvider.query(paramsOrPath));
    }
    /**
     * Query for block info from the RPC
     * pass block_id OR finality as blockQuery, not both
     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
     *
     * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
     */
    async block(blockQuery) {
      return this.withBackoff((currentProvider) => currentProvider.block(blockQuery));
    }
    /**
     * Query changes in block from the RPC
     * pass block_id OR finality as blockQuery, not both
     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
     */
    async blockChanges(blockQuery) {
      return this.withBackoff((currentProvider) => currentProvider.blockChanges(blockQuery));
    }
    /**
     * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
     *
     * @param chunkId Hash of a chunk ID or shard ID
     */
    async chunk(chunkId) {
      return this.withBackoff((currentProvider) => currentProvider.chunk(chunkId));
    }
    /**
     * Query validators of the epoch defined by the given block id.
     * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
     *
     * @param blockId Block hash or height, or null for latest.
     */
    async validators(blockId) {
      return this.withBackoff((currentProvider) => currentProvider.validators(blockId));
    }
    /**
     * Gets the protocol config at a block from RPC
     *
     * @param blockReference specifies the block to get the protocol config for
     */
    async experimental_protocolConfig(blockReference) {
      return this.withBackoff((currentProvider) => currentProvider.experimental_protocolConfig(blockReference));
    }
    /**
     * Gets a light client execution proof for verifying execution outcomes
     * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
     */
    async lightClientProof(request) {
      return this.withBackoff((currentProvider) => currentProvider.lightClientProof(request));
    }
    /**
     * Returns the next light client block as far in the future as possible from the last known hash
     * to still be able to validate from that hash. This will either return the last block of the
     * next epoch, or the last final known block.
     *
     * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
     */
    async nextLightClientBlock(request) {
      return this.withBackoff((currentProvider) => currentProvider.nextLightClientBlock(request));
    }
    /**
     * Gets access key changes for a given array of accountIds
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
     * @returns {Promise<ChangeResult>}
     */
    async accessKeyChanges(accountIdArray, blockQuery) {
      return this.withBackoff((currentProvider) => currentProvider.accessKeyChanges(accountIdArray, blockQuery));
    }
    /**
     * Gets single access key changes for a given array of access keys
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
     * @returns {Promise<ChangeResult>}
     */
    async singleAccessKeyChanges(accessKeyArray, blockQuery) {
      return this.withBackoff((currentProvider) => currentProvider.singleAccessKeyChanges(accessKeyArray, blockQuery));
    }
    /**
     * Gets account changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
     * @returns {Promise<ChangeResult>}
     */
    async accountChanges(accountIdArray, blockQuery) {
      return this.withBackoff((currentProvider) => currentProvider.accountChanges(accountIdArray, blockQuery));
    }
    /**
     * Gets contract state changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: If you pass a keyPrefix it must be base64 encoded
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
     * @returns {Promise<ChangeResult>}
     */
    async contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
      return this.withBackoff((currentProvider) => currentProvider.contractStateChanges(accountIdArray, blockQuery, keyPrefix));
    }
    /**
     * Gets contract code changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: Change is returned in a base64 encoded WASM file
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
     * @returns {Promise<ChangeResult>}
     */
    async contractCodeChanges(accountIdArray, blockQuery) {
      return this.withBackoff((currentProvider) => currentProvider.contractCodeChanges(accountIdArray, blockQuery));
    }
    /**
     * Returns gas price for a specific block_height or block_hash.
     * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
     *
     * @param blockId Block hash or height, or null for latest.
     */
    async gasPrice(blockId) {
      return this.withBackoff((currentProvider) => currentProvider.gasPrice(blockId));
    }
  };

  // ../../node_modules/@meer-js/accounts/dist/esm/accounts/src/utils.js
  function parseJsonFromRawResponse(response) {
    return JSON.parse(Buffer.from(response).toString());
  }
  function bytesJsonStringify(input) {
    return Buffer.from(JSON.stringify(input));
  }
  function validateArgs(args) {
    const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
    if (isUint8Array) {
      return;
    }
    if (Array.isArray(args) || typeof args !== "object") {
      throw new PositionalArgsError();
    }
  }
  function encodeJSContractArgs(contractId, method, args) {
    return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);
  }
  async function viewState(connection, accountId, prefix, blockQuery = { finality: "optimistic" }) {
    const { values } = await connection.provider.query({
      request_type: "view_state",
      ...blockQuery,
      account_id: accountId,
      prefix_base64: Buffer.from(prefix).toString("base64")
    });
    return values.map(({ key, value }) => ({
      key: Buffer.from(key, "base64"),
      value: Buffer.from(value, "base64")
    }));
  }
  async function viewFunction(connection, { contractId, methodName, args = {}, parse: parse3 = parseJsonFromRawResponse, stringify = bytesJsonStringify, jsContract = false, blockQuery = { finality: "optimistic" } }) {
    let encodedArgs;
    validateArgs(args);
    if (jsContract) {
      encodedArgs = encodeJSContractArgs(contractId, methodName, Object.keys(args).length > 0 ? JSON.stringify(args) : "");
    } else {
      encodedArgs = stringify(args);
    }
    const result = await connection.provider.query({
      request_type: "call_function",
      ...blockQuery,
      account_id: jsContract ? connection.jsvmAccountId : contractId,
      method_name: jsContract ? "view_js_contract" : methodName,
      args_base64: encodedArgs.toString("base64")
    });
    if (result.logs) {
      printTxOutcomeLogs({ contractId, logs: result.logs });
    }
    return result.result && result.result.length > 0 && parse3(Buffer.from(result.result));
  }

  // ../../node_modules/@meer-js/accounts/dist/esm/accounts/src/account.js
  var { addKey: addKey3, createAccount: createAccount3, deleteAccount: deleteAccount3, deleteKey: deleteKey3, deployContract: deployContract3, fullAccessKey: fullAccessKey2, functionCall: functionCall3, functionCallAccessKey: functionCallAccessKey2, stake: stake3, transfer: transfer3 } = actionCreators;
  var TX_NONCE_RETRY_NUMBER = 12;
  var TX_NONCE_RETRY_WAIT = 500;
  var TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;
  var Account = class _Account {
    connection;
    accountId;
    constructor(connection, accountId) {
      this.connection = connection;
      this.accountId = accountId;
    }
    getConnection() {
      return this.connection;
    }
    /**
     * Returns basic NEAR account information via the `view_account` RPC query method
     * @see [https://docs.near.org/api/rpc/contracts#view-account](https://docs.near.org/api/rpc/contracts#view-account)
     */
    async state() {
      return this.connection.provider.query({
        request_type: "view_account",
        account_id: this.accountId,
        finality: "optimistic"
      });
    }
    /**
     * Create a signed transaction which can be broadcast to the network
     * @param receiverId NEAR account receiving the transaction
     * @param actions list of actions to perform as part of the transaction
     * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}
     */
    async signTransaction(receiverId, actions) {
      const accessKeyInfo = await this.findAccessKey(receiverId, actions);
      if (!accessKeyInfo) {
        throw new TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, "KeyNotFound");
      }
      const { accessKey } = accessKeyInfo;
      const block = await this.connection.provider.block({ finality: "final" });
      const blockHash = block.header.hash;
      const nonce = accessKey.nonce + 1n;
      return await signTransaction(receiverId, nonce, actions, baseDecode(blockHash), this.connection.signer, this.accountId, this.connection.networkId);
    }
    /**
     * Sign a transaction to perform a list of actions and broadcast it using the RPC API.
     * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider | JsonRpcProvider }
     *
     * @param options The options for signing and sending the transaction.
     * @param options.receiverId The NEAR account ID of the transaction receiver.
     * @param options.actions The list of actions to be performed in the transaction.
     * @param options.returnError Whether to return an error if the transaction fails.
     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
     */
    async signAndSendTransaction({ receiverId, actions, returnError }) {
      let txHash, signedTx;
      const result = await exponentialBackoff(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, async () => {
        [txHash, signedTx] = await this.signTransaction(receiverId, actions);
        const publicKey = signedTx.transaction.publicKey;
        try {
          return await this.connection.provider.sendTransaction(signedTx);
        } catch (error) {
          if (error.type === "InvalidNonce") {
            Logger.warn(`Retrying transaction ${receiverId}:${baseEncode(txHash)} with new nonce.`);
            delete this.accessKeyByPublicKeyCache[publicKey.toString()];
            return null;
          }
          if (error.type === "Expired") {
            Logger.warn(`Retrying transaction ${receiverId}:${baseEncode(txHash)} due to expired block hash`);
            return null;
          }
          error.context = new ErrorContext(baseEncode(txHash));
          throw error;
        }
      });
      if (!result) {
        throw new TypedError("nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.", "RetriesExceeded");
      }
      printTxOutcomeLogsAndFailures({ contractId: signedTx.transaction.receiverId, outcome: result });
      if (!returnError && typeof result.status === "object" && typeof result.status.Failure === "object" && result.status.Failure !== null) {
        if (result.status.Failure.error_message && result.status.Failure.error_type) {
          throw new TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);
        } else {
          throw parseResultError(result);
        }
      }
      return result;
    }
    /** @hidden */
    accessKeyByPublicKeyCache = {};
    /**
     * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link "@near-js/keystores".keystore.KeyStore | Keystore}.
     *
     * @todo Find matching access key based on transaction (i.e. receiverId and actions)
     *
     * @param receiverId currently unused (see todo)
     * @param actions currently unused (see todo)
     * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async findAccessKey(receiverId, actions) {
      const publicKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
      if (!publicKey) {
        throw new TypedError(`no matching key pair found in ${this.connection.signer}`, "PublicKeyNotFound");
      }
      const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];
      if (cachedAccessKey !== void 0) {
        return { publicKey, accessKey: cachedAccessKey };
      }
      try {
        const rawAccessKey = await this.connection.provider.query({
          request_type: "view_access_key",
          account_id: this.accountId,
          public_key: publicKey.toString(),
          finality: "optimistic"
        });
        const accessKey = {
          ...rawAccessKey,
          nonce: BigInt(rawAccessKey.nonce || 0)
        };
        if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {
          return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };
        }
        this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;
        return { publicKey, accessKey };
      } catch (e) {
        if (e.type == "AccessKeyDoesNotExist") {
          return null;
        }
        throw e;
      }
    }
    /**
     * Create a new account and deploy a contract to it
     *
     * @param contractId NEAR account where the contract is deployed
     * @param publicKey The public key to add to the created contract account
     * @param data The compiled contract code
     * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking
     */
    async createAndDeployContract(contractId, publicKey, data, amount) {
      const accessKey = fullAccessKey2();
      await this.signAndSendTransaction({
        receiverId: contractId,
        actions: [createAccount3(), transfer3(amount), addKey3(publicKeyFrom(publicKey), accessKey), deployContract3(data)]
      });
      const contractAccount = new _Account(this.connection, contractId);
      return contractAccount;
    }
    /**
     * @param receiverId NEAR account receiving Ⓝ
     * @param amount Amount to send in yoctoⓃ
     */
    async sendMoney(receiverId, amount) {
      return this.signAndSendTransaction({
        receiverId,
        actions: [transfer3(amount)]
      });
    }
    /**
     * @param newAccountId NEAR account name to be created
     * @param publicKey A public key created from the masterAccount
     */
    async createAccount(newAccountId, publicKey, amount) {
      const accessKey = fullAccessKey2();
      return this.signAndSendTransaction({
        receiverId: newAccountId,
        actions: [createAccount3(), transfer3(amount), addKey3(publicKeyFrom(publicKey), accessKey)]
      });
    }
    /**
     * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted
     */
    async deleteAccount(beneficiaryId) {
      Logger.log("Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting.");
      return this.signAndSendTransaction({
        receiverId: this.accountId,
        actions: [deleteAccount3(beneficiaryId)]
      });
    }
    /**
     * @param data The compiled contract code
     */
    async deployContract(data) {
      return this.signAndSendTransaction({
        receiverId: this.accountId,
        actions: [deployContract3(data)]
      });
    }
    /** @hidden */
    encodeJSContractArgs(contractId, method, args) {
      return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);
    }
    /**
      * Execute a function call.
      * @param options The options for the function call.
      * @param options.contractId The NEAR account ID of the smart contract.
      * @param options.methodName The name of the method to be called on the smart contract.
      * @param options.args The arguments to be passed to the method.
      * @param options.gas The maximum amount of gas to be used for the function call.
      * @param options.attachedDeposit The amount of NEAR tokens to be attached to the function call.
      * @param options.walletMeta Metadata for wallet integration.
      * @param options.walletCallbackUrl The callback URL for wallet integration.
      * @param options.stringify A function to convert input arguments into bytes array
      * @param options.jsContract Whether the contract is from JS SDK, automatically encodes args from JS SDK to binary.
      * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the function call.
      */
    async functionCall({ contractId, methodName, args = {}, gas = DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify, jsContract }) {
      this.validateArgs(args);
      let functionCallArgs;
      if (jsContract) {
        const encodedArgs = this.encodeJSContractArgs(contractId, methodName, JSON.stringify(args));
        functionCallArgs = ["call_js_contract", encodedArgs, gas, attachedDeposit, null, true];
      } else {
        const stringifyArg = stringify === void 0 ? stringifyJsonOrBytes : stringify;
        functionCallArgs = [methodName, args, gas, attachedDeposit, stringifyArg, false];
      }
      return this.signAndSendTransaction({
        receiverId: jsContract ? this.connection.jsvmAccountId : contractId,
        // eslint-disable-next-line prefer-spread
        actions: [functionCall3.apply(void 0, functionCallArgs)],
        walletMeta,
        walletCallbackUrl
      });
    }
    /**
     * @see [https://docs.near.org/concepts/basics/accounts/access-keys](https://docs.near.org/concepts/basics/accounts/access-keys)
     * @todo expand this API to support more options.
     * @param publicKey A public key to be associated with the contract
     * @param contractId NEAR account where the contract is deployed
     * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.
     * @param amount Payment in yoctoⓃ that is sent to the contract during this function call
     */
    async addKey(publicKey, contractId, methodNames, amount) {
      if (!methodNames) {
        methodNames = [];
      }
      if (!Array.isArray(methodNames)) {
        methodNames = [methodNames];
      }
      let accessKey;
      if (!contractId) {
        accessKey = fullAccessKey2();
      } else {
        accessKey = functionCallAccessKey2(contractId, methodNames, amount);
      }
      return this.signAndSendTransaction({
        receiverId: this.accountId,
        actions: [addKey3(publicKeyFrom(publicKey), accessKey)]
      });
    }
    /**
     * @param publicKey The public key to be deleted
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async deleteKey(publicKey) {
      return this.signAndSendTransaction({
        receiverId: this.accountId,
        actions: [deleteKey3(publicKeyFrom(publicKey))]
      });
    }
    /**
     * @see [https://near-nodes.io/validator/staking-and-delegation](https://near-nodes.io/validator/staking-and-delegation)
     *
     * @param publicKey The public key for the account that's staking
     * @param amount The account to stake in yoctoⓃ
     */
    async stake(publicKey, amount) {
      return this.signAndSendTransaction({
        receiverId: this.accountId,
        actions: [stake3(amount, publicKeyFrom(publicKey))]
      });
    }
    /**
     * Compose and sign a SignedDelegate action to be executed in a transaction on behalf of this Account instance
     *
     * @param options Options for the transaction.
     * @param options.actions Actions to be included in the meta transaction
     * @param options.blockHeightTtl Number of blocks past the current block height for which the SignedDelegate action may be included in a meta transaction
     * @param options.receiverId Receiver account of the meta transaction
     */
    async signedDelegate({ actions, blockHeightTtl, receiverId }) {
      const { provider, signer } = this.connection;
      const { header } = await provider.block({ finality: "final" });
      const { accessKey, publicKey } = await this.findAccessKey(null, null);
      const delegateAction = buildDelegateAction({
        actions,
        maxBlockHeight: BigInt(header.height) + BigInt(blockHeightTtl),
        nonce: BigInt(accessKey.nonce) + 1n,
        publicKey,
        receiverId,
        senderId: this.accountId
      });
      const { signedDelegateAction } = await signDelegateAction({
        delegateAction,
        signer: {
          sign: async (message) => {
            const { signature } = await signer.signMessage(message, delegateAction.senderId, this.connection.networkId);
            return signature;
          }
        }
      });
      return signedDelegateAction;
    }
    /** @hidden */
    validateArgs(args) {
      const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
      if (isUint8Array) {
        return;
      }
      if (Array.isArray(args) || typeof args !== "object") {
        throw new PositionalArgsError();
      }
    }
    /**
     * Invoke a contract view function using the RPC API.
     * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)
     *
     * @param options Function call options.
     * @param options.contractId NEAR account where the contract is deployed
     * @param options.methodName The view-only method (no state mutations) name on the contract as it is written in the contract code
     * @param options.args Any arguments to the view contract method, wrapped in JSON
     * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.
     * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.
     * @param options.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.
     * @param options.blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
     * @returns {Promise<any>}
     */
    async viewFunction(options) {
      return await viewFunction(this.connection, options);
    }
    /**
     * Returns the state (key value pairs) of this account's contract based on the key prefix.
     * Pass an empty string for prefix if you would like to return the entire state.
     * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)
     *
     * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.
     * @param blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
     */
    async viewState(prefix, blockQuery = { finality: "optimistic" }) {
      return await viewState(this.connection, this.accountId, prefix, blockQuery);
    }
    /**
     * Get all access keys for the account
     * @see [https://docs.near.org/api/rpc/access-keys#view-access-key-list](https://docs.near.org/api/rpc/access-keys#view-access-key-list)
     */
    async getAccessKeys() {
      const response = await this.connection.provider.query({
        request_type: "view_access_key_list",
        account_id: this.accountId,
        finality: "optimistic"
      });
      return response?.keys?.map((key) => ({ ...key, access_key: { ...key.access_key, nonce: BigInt(key.access_key.nonce) } }));
    }
    /**
     * Returns a list of authorized apps
     * @todo update the response value to return all the different keys, not just app keys.
     */
    async getAccountDetails() {
      const accessKeys = await this.getAccessKeys();
      const authorizedApps = accessKeys.filter((item) => item.access_key.permission !== "FullAccess").map((item) => {
        const perm = item.access_key.permission;
        return {
          contractId: perm.FunctionCall.receiver_id,
          amount: perm.FunctionCall.allowance,
          publicKey: item.public_key
        };
      });
      return { authorizedApps };
    }
    /**
     * Returns calculated account balance
     */
    async getAccountBalance() {
      const protocolConfig = await this.connection.provider.experimental_protocolConfig({ finality: "final" });
      const state = await this.state();
      const costPerByte = BigInt(protocolConfig.runtime_config.storage_amount_per_byte);
      const stateStaked = BigInt(state.storage_usage) * costPerByte;
      const staked = BigInt(state.locked);
      const totalBalance = BigInt(state.amount) + staked;
      const availableBalance = totalBalance - (staked > stateStaked ? staked : stateStaked);
      return {
        total: totalBalance.toString(),
        stateStaked: stateStaked.toString(),
        staked: staked.toString(),
        available: availableBalance.toString()
      };
    }
    /**
     * Returns the NEAR tokens balance and validators of a given account that is delegated to the staking pools that are part of the validators set in the current epoch.
     *
     * NOTE: If the tokens are delegated to a staking pool that is currently on pause or does not have enough tokens to participate in validation, they won't be accounted for.
     * @returns {Promise<ActiveDelegatedStakeBalance>}
     */
    async getActiveDelegatedStakeBalance() {
      const block = await this.connection.provider.block({ finality: "final" });
      const blockHash = block.header.hash;
      const epochId = block.header.epoch_id;
      const { current_validators, next_validators, current_proposals } = await this.connection.provider.validators(epochId);
      const pools = /* @__PURE__ */ new Set();
      [...current_validators, ...next_validators, ...current_proposals].forEach((validator) => pools.add(validator.account_id));
      const uniquePools = [...pools];
      const promises = uniquePools.map((validator) => this.viewFunction({
        contractId: validator,
        methodName: "get_account_total_balance",
        args: { account_id: this.accountId },
        blockQuery: { blockId: blockHash }
      }));
      const results = await Promise.allSettled(promises);
      const hasTimeoutError = results.some((result) => {
        if (result.status === "rejected" && result.reason.type === "TimeoutError") {
          return true;
        }
        return false;
      });
      if (hasTimeoutError) {
        throw new Error("Failed to get delegated stake balance");
      }
      const summary = results.reduce((result, state, index) => {
        const validatorId = uniquePools[index];
        if (state.status === "fulfilled") {
          const currentBN = BigInt(state.value);
          if (currentBN !== 0n) {
            return {
              ...result,
              stakedValidators: [...result.stakedValidators, { validatorId, amount: currentBN.toString() }],
              total: result.total + currentBN
            };
          }
        }
        if (state.status === "rejected") {
          return {
            ...result,
            failedValidators: [...result.failedValidators, { validatorId, error: state.reason }]
          };
        }
        return result;
      }, { stakedValidators: [], failedValidators: [], total: 0n });
      return {
        ...summary,
        total: summary.total.toString()
      };
    }
  };

  // ../../node_modules/@meer-js/accounts/dist/esm/accounts/src/account_2fa.js
  var import_isomorphic_unfetch = __toESM(require_browser3(), 1);

  // ../../node_modules/@meer-js/accounts/dist/esm/accounts/src/constants.js
  var MULTISIG_STORAGE_KEY = "__multisigRequest";
  var MULTISIG_ALLOWANCE = BigInt(parseNearAmount("1"));

  // ../../node_modules/@meer-js/accounts/dist/esm/accounts/src/types.js
  var MultisigDeleteRequestRejectionError;
  (function(MultisigDeleteRequestRejectionError2) {
    MultisigDeleteRequestRejectionError2["CANNOT_DESERIALIZE_STATE"] = "Cannot deserialize the contract state";
    MultisigDeleteRequestRejectionError2["MULTISIG_NOT_INITIALIZED"] = "Smart contract panicked: Multisig contract should be initialized before usage";
    MultisigDeleteRequestRejectionError2["NO_SUCH_REQUEST"] = "Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'";
    MultisigDeleteRequestRejectionError2["REQUEST_COOLDOWN_ERROR"] = "Request cannot be deleted immediately after creation.";
    MultisigDeleteRequestRejectionError2["METHOD_NOT_FOUND"] = "Contract method is not found";
  })(MultisigDeleteRequestRejectionError || (MultisigDeleteRequestRejectionError = {}));
  var MultisigStateStatus;
  (function(MultisigStateStatus2) {
    MultisigStateStatus2[MultisigStateStatus2["INVALID_STATE"] = 0] = "INVALID_STATE";
    MultisigStateStatus2[MultisigStateStatus2["STATE_NOT_INITIALIZED"] = 1] = "STATE_NOT_INITIALIZED";
    MultisigStateStatus2[MultisigStateStatus2["VALID_STATE"] = 2] = "VALID_STATE";
    MultisigStateStatus2[MultisigStateStatus2["UNKNOWN_STATE"] = 3] = "UNKNOWN_STATE";
  })(MultisigStateStatus || (MultisigStateStatus = {}));

  // ../../node_modules/@meer-js/accounts/dist/esm/accounts/src/account_multisig.js
  var { deployContract: deployContract4, functionCall: functionCall4 } = actionCreators;
  var MultisigCodeStatus;
  (function(MultisigCodeStatus2) {
    MultisigCodeStatus2[MultisigCodeStatus2["INVALID_CODE"] = 0] = "INVALID_CODE";
    MultisigCodeStatus2[MultisigCodeStatus2["VALID_CODE"] = 1] = "VALID_CODE";
    MultisigCodeStatus2[MultisigCodeStatus2["UNKNOWN_CODE"] = 2] = "UNKNOWN_CODE";
  })(MultisigCodeStatus || (MultisigCodeStatus = {}));
  var storageFallback = {
    [MULTISIG_STORAGE_KEY]: null
  };

  // ../../node_modules/@meer-js/accounts/dist/esm/accounts/src/account_2fa.js
  var { addKey: addKey4, deleteKey: deleteKey4, deployContract: deployContract5, fullAccessKey: fullAccessKey3, functionCall: functionCall5, functionCallAccessKey: functionCallAccessKey3 } = actionCreators;

  // ../../node_modules/@meer-js/accounts/dist/esm/accounts/src/account_creator.js
  var import_isomorphic_unfetch2 = __toESM(require_browser3(), 1);
  var AccountCreator = class {
  };
  var LocalAccountCreator = class extends AccountCreator {
    masterAccount;
    initialBalance;
    constructor(masterAccount, initialBalance) {
      super();
      this.masterAccount = masterAccount;
      this.initialBalance = initialBalance;
    }
    /**
     * Creates an account using a masterAccount, meaning the new account is created from an existing account
     * @param newAccountId The name of the NEAR account to be created
     * @param publicKey The public key from the masterAccount used to create this account
     * @returns {Promise<void>}
     */
    async createAccount(newAccountId, publicKey) {
      await this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);
    }
  };
  var UrlAccountCreator = class extends AccountCreator {
    connection;
    helperUrl;
    constructor(connection, helperUrl) {
      super();
      this.connection = connection;
      this.helperUrl = helperUrl;
    }
    /**
     * Creates an account using a helperUrl
     * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository
     * @param newAccountId The name of the NEAR account to be created
     * @param publicKey The public key from the masterAccount used to create this account
     * @returns {Promise<void>}
     */
    async createAccount(newAccountId, publicKey) {
      await (0, import_isomorphic_unfetch2.default)(`${this.helperUrl}/account`, {
        body: JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }),
        method: "POST"
      });
    }
  };

  // ../../node_modules/@meer-js/signers/dist/esm/signers/src/signer.js
  var Signer = class {
  };

  // ../../node_modules/@meer-js/signers/dist/esm/signers/src/in_memory_signer.js
  var InMemorySigner = class _InMemorySigner extends Signer {
    keyStore;
    constructor(keyStore) {
      super();
      this.keyStore = keyStore;
    }
    /**
     * Creates a single account Signer instance with account, network and keyPair provided.
     *
     * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).
     *
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @param accountId The NEAR account to assign the key pair to
     * @param keyPair The keyPair to use for signing
     */
    static async fromKeyPair(networkId, accountId, keyPair) {
      const keyStore = new InMemoryKeyStore();
      await keyStore.setKey(networkId, accountId, keyPair);
      return new _InMemorySigner(keyStore);
    }
    /**
     * Creates a public key for the account given
     * @param accountId The NEAR account to assign a public key to
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @returns {Promise<PublicKey>}
     */
    async createKey(accountId, networkId, keyType) {
      const keyPair = keyType === KeyType.SECP256K1 ? KeyPair.fromRandom("secp256k1") : KeyPair.fromRandom("ed25519");
      await this.keyStore.setKey(networkId, accountId, keyPair);
      return keyPair.getPublicKey();
    }
    /**
     * Gets the existing public key for a given account
     * @param accountId The NEAR account to assign a public key to
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @returns {Promise<PublicKey>} Returns the public key or null if not found
     */
    async getPublicKey(accountId, networkId) {
      const keyPair = await this.keyStore.getKey(networkId, accountId);
      if (keyPair === null) {
        return null;
      }
      return keyPair.getPublicKey();
    }
    /**
     * @param message A message to be signed, typically a serialized transaction
     * @param accountId the NEAR account signing the message
     * @param networkId The targeted network. (ex. default, betanet, etc…)
     * @returns {Promise<Signature>}
     */
    async signMessage(message, accountId, networkId) {
      const hash = new Uint8Array(sha256(message));
      if (!accountId) {
        throw new Error("InMemorySigner requires provided account id");
      }
      const keyPair = await this.keyStore.getKey(networkId, accountId);
      if (keyPair === null) {
        throw new Error(`Key for ${accountId} not found in ${networkId}`);
      }
      return keyPair.sign(hash);
    }
    toString() {
      return `InMemorySigner(${this.keyStore})`;
    }
  };

  // ../../node_modules/@meer-js/accounts/dist/esm/accounts/src/connection.js
  function getProvider(config) {
    switch (config.type) {
      case void 0:
        return config;
      case "JsonRpcProvider":
        return new JsonRpcProvider({ ...config.args });
      case "FailoverRpcProvider": {
        const providers = (config?.args || []).map((arg) => new JsonRpcProvider(arg));
        return new FailoverRpcProvider(providers);
      }
      default:
        throw new Error(`Unknown provider type ${config.type}`);
    }
  }
  function getSigner(config) {
    switch (config.type) {
      case void 0:
        return config;
      case "InMemorySigner": {
        return new InMemorySigner(config.keyStore);
      }
      default:
        throw new Error(`Unknown signer type ${config.type}`);
    }
  }
  var Connection = class _Connection {
    networkId;
    provider;
    signer;
    jsvmAccountId;
    constructor(networkId, provider, signer, jsvmAccountId) {
      this.networkId = networkId;
      this.provider = provider;
      this.signer = signer;
      this.jsvmAccountId = jsvmAccountId;
    }
    getConnection() {
      return this;
    }
    /**
     * @param config Contains connection info details
     */
    static fromConfig(config) {
      const provider = getProvider(config.provider);
      const signer = getSigner(config.signer);
      return new _Connection(config.networkId, provider, signer, config.jsvmAccountId);
    }
  };

  // ../../node_modules/@meer-js/wallet-account/dist/esm/wallet-account/src/near.js
  var Near = class {
    config;
    connection;
    accountCreator;
    constructor(config) {
      this.config = config;
      this.connection = Connection.fromConfig({
        networkId: config.networkId,
        provider: config.provider || { type: "JsonRpcProvider", args: { url: config.nodeUrl, headers: config.headers } },
        signer: config.signer || { type: "InMemorySigner", keyStore: config.keyStore || config.deps?.keyStore },
        jsvmAccountId: config.jsvmAccountId || `jsvm.${config.networkId}`
      });
      if (config.masterAccount) {
        const initialBalance = config.initialBalance ? BigInt(config.initialBalance) : 500000000000000000000000000n;
        this.accountCreator = new LocalAccountCreator(new Account(this.connection, config.masterAccount), initialBalance);
      } else if (config.helperUrl) {
        this.accountCreator = new UrlAccountCreator(this.connection, config.helperUrl);
      } else {
        this.accountCreator = null;
      }
    }
    /**
     * @param accountId near accountId used to interact with the network.
     */
    async account(accountId) {
      const account = new Account(this.connection, accountId);
      return account;
    }
    /**
     * Create an account using the {@link AccountCreator}. Either:
     * * using a masterAccount with {@link LocalAccountCreator}
     * * using the helperUrl with {@link UrlAccountCreator}
     * @see {@link NearConfig#masterAccount} and {@link NearConfig#helperUrl}
     *
     * @param accountId
     * @param publicKey
     */
    async createAccount(accountId, publicKey) {
      if (!this.accountCreator) {
        throw new Error("Must specify account creator, either via masterAccount or helperUrl configuration settings.");
      }
      await this.accountCreator.createAccount(accountId, publicKey);
      return new Account(this.connection, accountId);
    }
  };

  // ../../node_modules/meer-api-js/dist/esm/meer-api-js/src/connect.js
  async function connect(config) {
    if (config.logger === false) {
      Logger.overrideLogger(void 0);
    } else if (config.logger !== void 0 && config.logger !== null) {
      Logger.overrideLogger(config.logger);
    }
    if (config.keyStore || config.deps?.keyStore) {
      const keyStore = config.keyStore || config.deps.keyStore;
      config.keyStore = new MergeKeyStore([keyStore], { writeKeyStoreIndex: 0 });
      Logger.log(`Key store initialized for the connection configuration.`);
    }
    return new Near(config);
  }

  // src/adapters/meteor.ts
  var import_meteorwallet_sdk = __toESM(require_src(), 1);

  // ../../node_modules/@near-js/crypto/lib/esm/constants.js
  var KeyType2;
  (function(KeyType3) {
    KeyType3[KeyType3["ED25519"] = 0] = "ED25519";
    KeyType3[KeyType3["SECP256K1"] = 1] = "SECP256K1";
  })(KeyType2 || (KeyType2 = {}));
  var KeySize2 = {
    SECRET_KEY: 32,
    ED25519_PUBLIC_KEY: 32,
    SECP256k1_PUBLIC_KEY: 64
  };

  // ../../node_modules/@near-js/types/lib/esm/provider/light_client.js
  var IdType2;
  (function(IdType3) {
    IdType3["Transaction"] = "transaction";
    IdType3["Receipt"] = "receipt";
  })(IdType2 || (IdType2 = {}));

  // ../../node_modules/@near-js/types/lib/esm/provider/response.js
  var ExecutionStatusBasic2;
  (function(ExecutionStatusBasic3) {
    ExecutionStatusBasic3["Unknown"] = "Unknown";
    ExecutionStatusBasic3["Pending"] = "Pending";
    ExecutionStatusBasic3["Failure"] = "Failure";
  })(ExecutionStatusBasic2 || (ExecutionStatusBasic2 = {}));
  var FinalExecutionStatusBasic2;
  (function(FinalExecutionStatusBasic3) {
    FinalExecutionStatusBasic3["NotStarted"] = "NotStarted";
    FinalExecutionStatusBasic3["Started"] = "Started";
    FinalExecutionStatusBasic3["Failure"] = "Failure";
  })(FinalExecutionStatusBasic2 || (FinalExecutionStatusBasic2 = {}));

  // ../../node_modules/@near-js/utils/lib/esm/errors/rpc_errors.js
  var import_mustache2 = __toESM(require_mustache(), 1);

  // ../../node_modules/@near-js/utils/lib/esm/format.js
  var import_bs582 = __toESM(require_bs58(), 1);
  var NEAR_NOMINATION_EXP2 = 24;
  var NEAR_NOMINATION2 = 10n ** BigInt(NEAR_NOMINATION_EXP2);
  var ROUNDING_OFFSETS2 = [];
  var BN102 = 10n;
  for (let i = 0, offset = 5n; i < NEAR_NOMINATION_EXP2; i++, offset = offset * BN102) {
    ROUNDING_OFFSETS2[i] = offset;
  }
  function baseEncode2(value) {
    if (typeof value === "string") {
      const bytes2 = [];
      for (let c = 0; c < value.length; c++) {
        bytes2.push(value.charCodeAt(c));
      }
      value = new Uint8Array(bytes2);
    }
    return import_bs582.default.encode(value);
  }
  function baseDecode2(value) {
    return new Uint8Array(import_bs582.default.decode(value));
  }

  // ../../node_modules/@near-js/utils/lib/esm/logger/console.logger.js
  var ConsoleLogger2 = class {
    logLevels;
    constructor(logLevels) {
      this.logLevels = logLevels;
    }
    isLevelEnabled = (level) => {
      return this.logLevels.includes(level);
    };
    print(level, message, ...optionalParams) {
      switch (level) {
        case "error":
        case "fatal":
          return console.error(message, ...optionalParams);
        case "warn":
          return console.warn(message, ...optionalParams);
        case "log":
          return console.log(message, ...optionalParams);
        case "debug":
        case "verbose":
          return console.debug(message, ...optionalParams);
      }
    }
    verbose(message, ...optionalParams) {
      if (!this.isLevelEnabled("verbose"))
        return;
      this.print("verbose", message, ...optionalParams);
    }
    debug(message, ...optionalParams) {
      if (!this.isLevelEnabled("debug"))
        return;
      this.print("debug", message, ...optionalParams);
    }
    log(message, ...optionalParams) {
      if (!this.isLevelEnabled("log"))
        return;
      this.print("log", message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
      if (!this.isLevelEnabled("warn"))
        return;
      this.print("warn", message, ...optionalParams);
    }
    error(message, ...optionalParams) {
      if (!this.isLevelEnabled("error"))
        return;
      this.print("error", message, ...optionalParams);
    }
    fatal(message, ...optionalParams) {
      if (!this.isLevelEnabled("fatal"))
        return;
      this.print("fatal", message, ...optionalParams);
    }
  };

  // ../../node_modules/@near-js/utils/lib/esm/logger/logger.js
  var DEFAULT_LOG_LEVELS2 = [
    "verbose",
    "debug",
    "log",
    "warn",
    "error",
    "fatal"
  ];
  var DEFAULT_LOGGER2 = new ConsoleLogger2(DEFAULT_LOG_LEVELS2);

  // ../../node_modules/@near-js/utils/lib/esm/validators.js
  var import_depd2 = __toESM(require_browser(), 1);

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/esm/_assert.js
  function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/esm/crypto.js
  var crypto3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/esm/utils.js
  var u8a = (a) => a instanceof Uint8Array;
  var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  function utf8ToBytes3(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes3(data) {
    if (typeof data === "string")
      data = utf8ToBytes3(data);
    if (!u8a(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  function concatBytes3(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  }
  var Hash3 = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  var toStr = {}.toString;
  function wrapConstructor3(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes2(bytesLength = 32) {
    if (crypto3 && typeof crypto3.getRandomValues === "function") {
      return crypto3.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint643(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n3 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n3 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  var SHA2 = class extends Hash3 {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView3(this.buffer);
    }
    update(data) {
      exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes3(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView3(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists(this);
      output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint643(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView3(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n2 = /* @__PURE__ */ BigInt(32);
  function fromBig2(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
    return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
  }
  function split2(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig2(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var toBig2 = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
  var shrSH2 = (h, _l, s) => h >>> s;
  var shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
  var rotr32H2 = (_h, l) => l;
  var rotr32L2 = (h, _l) => h;
  var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
  function add2(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u642 = {
    fromBig: fromBig2,
    split: split2,
    toBig: toBig2,
    shrSH: shrSH2,
    shrSL: shrSL2,
    rotrSH: rotrSH2,
    rotrSL: rotrSL2,
    rotrBH: rotrBH2,
    rotrBL: rotrBL2,
    rotr32H: rotr32H2,
    rotr32L: rotr32L2,
    rotlSH: rotlSH2,
    rotlSL: rotlSL2,
    rotlBH: rotlBH2,
    rotlBL: rotlBL2,
    add: add2,
    add3L: add3L2,
    add3H: add3H2,
    add4L: add4L2,
    add4H: add4H2,
    add5H: add5H2,
    add5L: add5L2
  };
  var u64_default2 = u642;

  // ../../node_modules/@near-js/crypto/node_modules/@noble/hashes/esm/sha512.js
  var [SHA512_Kh2, SHA512_Kl2] = /* @__PURE__ */ (() => u64_default2.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  var SHA512_W_H2 = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L2 = /* @__PURE__ */ new Uint32Array(80);
  var SHA5122 = class extends SHA2 {
    constructor() {
      super(128, 64, 16, false);
      this.Ah = 1779033703 | 0;
      this.Al = 4089235720 | 0;
      this.Bh = 3144134277 | 0;
      this.Bl = 2227873595 | 0;
      this.Ch = 1013904242 | 0;
      this.Cl = 4271175723 | 0;
      this.Dh = 2773480762 | 0;
      this.Dl = 1595750129 | 0;
      this.Eh = 1359893119 | 0;
      this.El = 2917565137 | 0;
      this.Fh = 2600822924 | 0;
      this.Fl = 725511199 | 0;
      this.Gh = 528734635 | 0;
      this.Gl = 4215389547 | 0;
      this.Hh = 1541459225 | 0;
      this.Hl = 327033209 | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H2[i] = view.getUint32(offset);
        SHA512_W_L2[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H2[i - 15] | 0;
        const W15l = SHA512_W_L2[i - 15] | 0;
        const s0h = u64_default2.rotrSH(W15h, W15l, 1) ^ u64_default2.rotrSH(W15h, W15l, 8) ^ u64_default2.shrSH(W15h, W15l, 7);
        const s0l = u64_default2.rotrSL(W15h, W15l, 1) ^ u64_default2.rotrSL(W15h, W15l, 8) ^ u64_default2.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H2[i - 2] | 0;
        const W2l = SHA512_W_L2[i - 2] | 0;
        const s1h = u64_default2.rotrSH(W2h, W2l, 19) ^ u64_default2.rotrBH(W2h, W2l, 61) ^ u64_default2.shrSH(W2h, W2l, 6);
        const s1l = u64_default2.rotrSL(W2h, W2l, 19) ^ u64_default2.rotrBL(W2h, W2l, 61) ^ u64_default2.shrSL(W2h, W2l, 6);
        const SUMl = u64_default2.add4L(s0l, s1l, SHA512_W_L2[i - 7], SHA512_W_L2[i - 16]);
        const SUMh = u64_default2.add4H(SUMl, s0h, s1h, SHA512_W_H2[i - 7], SHA512_W_H2[i - 16]);
        SHA512_W_H2[i] = SUMh | 0;
        SHA512_W_L2[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = u64_default2.rotrSH(Eh, El, 14) ^ u64_default2.rotrSH(Eh, El, 18) ^ u64_default2.rotrBH(Eh, El, 41);
        const sigma1l = u64_default2.rotrSL(Eh, El, 14) ^ u64_default2.rotrSL(Eh, El, 18) ^ u64_default2.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64_default2.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i], SHA512_W_L2[i]);
        const T1h = u64_default2.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i], SHA512_W_H2[i]);
        const T1l = T1ll | 0;
        const sigma0h = u64_default2.rotrSH(Ah, Al, 28) ^ u64_default2.rotrBH(Ah, Al, 34) ^ u64_default2.rotrBH(Ah, Al, 39);
        const sigma0l = u64_default2.rotrSL(Ah, Al, 28) ^ u64_default2.rotrBL(Ah, Al, 34) ^ u64_default2.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64_default2.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64_default2.add3L(T1l, sigma0l, MAJl);
        Ah = u64_default2.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64_default2.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64_default2.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64_default2.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64_default2.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64_default2.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64_default2.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64_default2.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64_default2.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      SHA512_W_H2.fill(0);
      SHA512_W_L2.fill(0);
    }
    destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var sha5122 = /* @__PURE__ */ wrapConstructor3(() => new SHA5122());

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/esm/abstract/utils.js
  var _0n6 = BigInt(0);
  var _1n6 = BigInt(1);
  var _2n5 = BigInt(2);
  var u8a2 = (a) => a instanceof Uint8Array;
  var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex2(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes2[bytes2[i]];
    }
    return hex;
  }
  function hexToNumber2(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  }
  function hexToBytes2(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  }
  function bytesToNumberBE2(bytes2) {
    return hexToNumber2(bytesToHex2(bytes2));
  }
  function bytesToNumberLE2(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    return hexToNumber2(bytesToHex2(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE2(n, len) {
    return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE2(n, len) {
    return numberToBytesBE2(n, len).reverse();
  }
  function ensureBytes2(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes2(hex);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (u8a2(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes4(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a2(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  }
  var bitMask2 = (n) => (_2n5 << BigInt(n - 1)) - _1n6;
  var validatorFns2 = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject2(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns2[type];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type}", expected function`);
      const val = object[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object;
  }

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/esm/abstract/modular.js
  var _0n7 = BigInt(0);
  var _1n7 = BigInt(1);
  var _2n6 = BigInt(2);
  var _3n3 = BigInt(3);
  var _4n2 = BigInt(4);
  var _5n3 = BigInt(5);
  var _8n4 = BigInt(8);
  var _9n2 = BigInt(9);
  var _16n2 = BigInt(16);
  function mod2(a, b) {
    const result = a % b;
    return result >= _0n7 ? result : b + result;
  }
  function pow3(num, power, modulo) {
    if (modulo <= _0n7 || power < _0n7)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n7)
      return _0n7;
    let res = _1n7;
    while (power > _0n7) {
      if (power & _1n7)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n7;
    }
    return res;
  }
  function pow22(x, power, modulo) {
    let res = x;
    while (power-- > _0n7) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert2(number, modulo) {
    if (number === _0n7 || modulo <= _0n7) {
      throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod2(number, modulo);
    let b = modulo;
    let x = _0n7, y = _1n7, u = _1n7, v = _0n7;
    while (a !== _0n7) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n7)
      throw new Error("invert: does not exist");
    return mod2(x, modulo);
  }
  function tonelliShanks2(P) {
    const legendreC = (P - _1n7) / _2n6;
    let Q, S, Z;
    for (Q = P - _1n7, S = 0; Q % _2n6 === _0n7; Q /= _2n6, S++)
      ;
    for (Z = _2n6; Z < P && pow3(Z, legendreC, P) !== P - _1n7; Z++)
      ;
    if (S === 1) {
      const p1div4 = (P + _1n7) / _4n2;
      return function tonelliFast(Fp3, n) {
        const root = Fp3.pow(n, p1div4);
        if (!Fp3.eql(Fp3.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n7) / _2n6;
    return function tonelliSlow(Fp3, n) {
      if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE))
        throw new Error("Cannot find square root");
      let r = S;
      let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
      let x = Fp3.pow(n, Q1div2);
      let b = Fp3.pow(n, Q);
      while (!Fp3.eql(b, Fp3.ONE)) {
        if (Fp3.eql(b, Fp3.ZERO))
          return Fp3.ZERO;
        let m = 1;
        for (let t2 = Fp3.sqr(b); m < r; m++) {
          if (Fp3.eql(t2, Fp3.ONE))
            break;
          t2 = Fp3.sqr(t2);
        }
        const ge = Fp3.pow(g, _1n7 << BigInt(r - m - 1));
        g = Fp3.sqr(ge);
        x = Fp3.mul(x, ge);
        b = Fp3.mul(b, g);
        r = m;
      }
      return x;
    };
  }
  function FpSqrt2(P) {
    if (P % _4n2 === _3n3) {
      const p1div4 = (P + _1n7) / _4n2;
      return function sqrt3mod4(Fp3, n) {
        const root = Fp3.pow(n, p1div4);
        if (!Fp3.eql(Fp3.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n4 === _5n3) {
      const c1 = (P - _5n3) / _8n4;
      return function sqrt5mod8(Fp3, n) {
        const n2 = Fp3.mul(n, _2n6);
        const v = Fp3.pow(n2, c1);
        const nv = Fp3.mul(n, v);
        const i = Fp3.mul(Fp3.mul(nv, _2n6), v);
        const root = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
        if (!Fp3.eql(Fp3.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _16n2 === _9n2) {
    }
    return tonelliShanks2(P);
  }
  var isNegativeLE2 = (num, modulo) => (mod2(num, modulo) & _1n7) === _1n7;
  var FIELD_FIELDS2 = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField2(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS2.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return validateObject2(field, opts);
  }
  function FpPow2(f, num, power) {
    if (power < _0n7)
      throw new Error("Expected power > 0");
    if (power === _0n7)
      return f.ONE;
    if (power === _1n7)
      return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n7) {
      if (power & _1n7)
        p = f.mul(p, d);
      d = f.sqr(d);
      power >>= _1n7;
    }
    return p;
  }
  function FpInvertBatch2(f, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = acc;
      return f.mul(acc, num);
    }, f.ONE);
    const inverted = f.inv(lastMultiplied);
    nums.reduceRight((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = f.mul(acc, tmp[i]);
      return f.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength2(n, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field2(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n7)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt2(ORDER);
    const f = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask2(BITS),
      ZERO: _0n7,
      ONE: _1n7,
      create: (num) => mod2(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n7 <= num && num < ORDER;
      },
      is0: (num) => num === _0n7,
      isOdd: (num) => (num & _1n7) === _1n7,
      neg: (num) => mod2(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod2(num * num, ORDER),
      add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
      pow: (num, power) => FpPow2(f, num, power),
      div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert2(num, ORDER),
      sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
      invertBatch: (lst) => FpInvertBatch2(f, lst),
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: (a, b, c) => c ? b : a,
      toBytes: (num) => isLE2 ? numberToBytesLE2(num, BYTES) : numberToBytesBE2(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? bytesToNumberLE2(bytes2) : bytesToNumberBE2(bytes2);
      }
    });
    return Object.freeze(f);
  }
  function FpSqrtEven2(Fp3, elm) {
    if (!Fp3.isOdd)
      throw new Error(`Field doesn't have isOdd`);
    const root = Fp3.sqrt(elm);
    return Fp3.isOdd(root) ? Fp3.neg(root) : root;
  }

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/esm/abstract/curve.js
  var _0n8 = BigInt(0);
  var _1n8 = BigInt(1);
  function wNAF2(c, bits) {
    const constTimeNegate2 = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W) => {
      const windows = Math.ceil(bits / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate: constTimeNegate2,
      // non-const time multiplication ladder
      unsafeLadder(elm, n) {
        let p = c.ZERO;
        let d = elm;
        while (n > _0n8) {
          if (n & _1n8)
            p = p.add(d);
          d = d.double();
          n >>= _1n8;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W) {
        const { windows, windowSize } = opts(W);
        const points = [];
        let p = elm;
        let base2 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base2 = p;
          points.push(base2);
          for (let i = 1; i < windowSize; i++) {
            base2 = base2.add(p);
            points.push(base2);
          }
          p = base2.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        const { windows, windowSize } = opts(W);
        let p = c.ZERO;
        let f = c.BASE;
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n8;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f = f.add(constTimeNegate2(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate2(cond2, precomputes[offset2]));
          }
        }
        return { p, f };
      },
      wNAFCached(P, precomputesMap, n, transform) {
        const W = P._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            precomputesMap.set(P, transform(comp));
          }
        }
        return this.wNAF(W, comp, n);
      }
    };
  }
  function validateBasic2(curve) {
    validateField2(curve.Fp);
    validateObject2(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength2(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/esm/abstract/edwards.js
  var _0n9 = BigInt(0);
  var _1n9 = BigInt(1);
  var _2n7 = BigInt(2);
  var _8n5 = BigInt(8);
  var VERIFY_DEFAULT2 = { zip215: true };
  function validateOpts2(curve) {
    const opts = validateBasic2(curve);
    validateObject2(curve, {
      hash: "function",
      a: "bigint",
      d: "bigint",
      randomBytes: "function"
    }, {
      adjustScalarBytes: "function",
      domain: "function",
      uvRatio: "function",
      mapToCurve: "function"
    });
    return Object.freeze({ ...opts });
  }
  function twistedEdwards2(curveDef) {
    const CURVE = validateOpts2(curveDef);
    const { Fp: Fp3, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes3, nByteLength, h: cofactor } = CURVE;
    const MASK = _2n7 << BigInt(nByteLength * 8) - _1n9;
    const modP = Fp3.create;
    const uvRatio3 = CURVE.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp3.sqrt(u * Fp3.inv(v)) };
      } catch (e) {
        return { isValid: false, value: _0n9 };
      }
    });
    const adjustScalarBytes3 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
    const domain = CURVE.domain || ((data, ctx, phflag) => {
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    const inBig = (n) => typeof n === "bigint" && _0n9 < n;
    const inRange2 = (n, max) => inBig(n) && inBig(max) && n < max;
    const in0MaskRange = (n) => n === _0n9 || inRange2(n, MASK);
    function assertInRange(n, max) {
      if (inRange2(n, max))
        return n;
      throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);
    }
    function assertGE0(n) {
      return n === _0n9 ? n : assertInRange(n, CURVE_ORDER);
    }
    const pointPrecomputes2 = /* @__PURE__ */ new Map();
    function isPoint(other) {
      if (!(other instanceof Point))
        throw new Error("ExtendedPoint expected");
    }
    class Point {
      constructor(ex, ey, ez, et) {
        this.ex = ex;
        this.ey = ey;
        this.ez = ez;
        this.et = et;
        if (!in0MaskRange(ex))
          throw new Error("x required");
        if (!in0MaskRange(ey))
          throw new Error("y required");
        if (!in0MaskRange(ez))
          throw new Error("z required");
        if (!in0MaskRange(et))
          throw new Error("t required");
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p) {
        if (p instanceof Point)
          throw new Error("extended point not allowed");
        const { x, y } = p || {};
        if (!in0MaskRange(x) || !in0MaskRange(y))
          throw new Error("invalid affine point");
        return new Point(x, y, _1n9, modP(x * y));
      }
      static normalizeZ(points) {
        const toInv = Fp3.invertBatch(points.map((p) => p.ez));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes2.delete(this);
      }
      // Not required for fromHex(), which always creates valid points.
      // Could be useful for fromAffine().
      assertValidity() {
        const { a, d } = CURVE;
        if (this.is0())
          throw new Error("bad point: ZERO");
        const { ex: X, ey: Y, ez: Z, et: T } = this;
        const X2 = modP(X * X);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X2 * a);
        const left = modP(Z2 * modP(aX2 + Y2));
        const right = modP(Z4 + modP(d * modP(X2 * Y2)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
      }
      // Compare one point to another.
      equals(other) {
        isPoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      negate() {
        return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
      }
      // Fast algo for doubling Extended Point.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
      // Cost: 4M + 4S + 1*a + 6add + 1*2.
      double() {
        const { a } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n7 * modP(Z1 * Z1));
        const D = modP(a * A);
        const x1y1 = X1 + Y1;
        const E = modP(modP(x1y1 * x1y1) - A - B);
        const G2 = D + B;
        const F = G2 - C;
        const H = D - B;
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point(X3, Y3, Z3, T3);
      }
      // Fast algo for adding 2 Extended Points.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
      // Cost: 9M + 1*a + 1*d + 7add.
      add(other) {
        isPoint(other);
        const { a, d } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
        if (a === BigInt(-1)) {
          const A2 = modP((Y1 - X1) * (Y2 + X2));
          const B2 = modP((Y1 + X1) * (Y2 - X2));
          const F2 = modP(B2 - A2);
          if (F2 === _0n9)
            return this.double();
          const C2 = modP(Z1 * _2n7 * T2);
          const D2 = modP(T1 * _2n7 * Z2);
          const E2 = D2 + C2;
          const G3 = B2 + A2;
          const H2 = D2 - C2;
          const X32 = modP(E2 * F2);
          const Y32 = modP(G3 * H2);
          const T32 = modP(E2 * H2);
          const Z32 = modP(F2 * G3);
          return new Point(X32, Y32, Z32, T32);
        }
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T1 * d * T2);
        const D = modP(Z1 * Z2);
        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G2 = D + C;
        const H = modP(B - a * A);
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes2, n, Point.normalizeZ);
      }
      // Constant-time multiplication.
      multiply(scalar) {
        const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
        return Point.normalizeZ([p, f])[0];
      }
      // Non-constant-time multiplication. Uses double-and-add algorithm.
      // It's faster, but should only be used when you don't care about
      // an exposed private key e.g. sig verification.
      // Does NOT allow scalars higher than CURVE.n.
      multiplyUnsafe(scalar) {
        let n = assertGE0(scalar);
        if (n === _0n9)
          return I;
        if (this.equals(I) || n === _1n9)
          return this;
        if (this.equals(G))
          return this.wNAF(n).p;
        return wnaf.unsafeLadder(this, n);
      }
      // Checks if point is of small order.
      // If you add something to small order point, you will have "dirty"
      // point with torsion component.
      // Multiplies point by cofactor and checks if the result is 0.
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      // Multiplies point by curve order and checks if the result is 0.
      // Returns `false` is the point is dirty.
      isTorsionFree() {
        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
      }
      // Converts Extended point to default (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      toAffine(iz) {
        const { ex: x, ey: y, ez: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? _8n5 : Fp3.inv(z);
        const ax = modP(x * iz);
        const ay = modP(y * iz);
        const zz = modP(z * iz);
        if (is0)
          return { x: _0n9, y: _1n9 };
        if (zz !== _1n9)
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      clearCofactor() {
        const { h: cofactor2 } = CURVE;
        if (cofactor2 === _1n9)
          return this;
        return this.multiplyUnsafe(cofactor2);
      }
      // Converts hash string or Uint8Array to Point.
      // Uses algo from RFC8032 5.1.3.
      static fromHex(hex, zip215 = false) {
        const { d, a } = CURVE;
        const len = Fp3.BYTES;
        hex = ensureBytes2("pointHex", hex, len);
        const normed = hex.slice();
        const lastByte = hex[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y = bytesToNumberLE2(normed);
        if (y === _0n9) {
        } else {
          if (zip215)
            assertInRange(y, MASK);
          else
            assertInRange(y, Fp3.ORDER);
        }
        const y2 = modP(y * y);
        const u = modP(y2 - _1n9);
        const v = modP(d * y2 - a);
        let { isValid, value: x } = uvRatio3(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n9) === _1n9;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n9 && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP(-x);
        return Point.fromAffine({ x, y });
      }
      static fromPrivateKey(privKey) {
        return getExtendedPublicKey(privKey).point;
      }
      toRawBytes() {
        const { x, y } = this.toAffine();
        const bytes2 = numberToBytesLE2(y, Fp3.BYTES);
        bytes2[bytes2.length - 1] |= x & _1n9 ? 128 : 0;
        return bytes2;
      }
      toHex() {
        return bytesToHex2(this.toRawBytes());
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n9, modP(CURVE.Gx * CURVE.Gy));
    Point.ZERO = new Point(_0n9, _1n9, _1n9, _0n9);
    const { BASE: G, ZERO: I } = Point;
    const wnaf = wNAF2(Point, nByteLength * 8);
    function modN(a) {
      return mod2(a, CURVE_ORDER);
    }
    function modN_LE(hash) {
      return modN(bytesToNumberLE2(hash));
    }
    function getExtendedPublicKey(key) {
      const len = nByteLength;
      key = ensureBytes2("private key", key, len);
      const hashed = ensureBytes2("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes3(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      const point = G.multiply(scalar);
      const pointBytes = point.toRawBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
      const msg = concatBytes4(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes2("context", context), !!prehash)));
    }
    function sign(msg, privKey, options = {}) {
      msg = ensureBytes2("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R = G.multiply(r).toRawBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s = modN(r + k * scalar);
      assertGE0(s);
      const res = concatBytes4(R, numberToBytesLE2(s, Fp3.BYTES));
      return ensureBytes2("result", res, nByteLength * 2);
    }
    const verifyOpts = VERIFY_DEFAULT2;
    function verify(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = Fp3.BYTES;
      sig = ensureBytes2("signature", sig, 2 * len);
      msg = ensureBytes2("message", msg);
      if (prehash)
        msg = prehash(msg);
      const s = bytesToNumberLE2(sig.slice(len, 2 * len));
      let A, R, SB;
      try {
        A = Point.fromHex(publicKey, zip215);
        R = Point.fromHex(sig.slice(0, len), zip215);
        SB = G.multiplyUnsafe(s);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
    }
    G._setWindowSize(8);
    const utils = {
      getExtendedPublicKey,
      // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
      randomPrivateKey: () => randomBytes3(Fp3.BYTES),
      /**
       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
       * values. This slows down first getPublicKey() by milliseconds (see Speed section),
       * but allows to speed-up subsequent getPublicKey() calls up to 20x.
       * @param windowSize 2, 4, 8, 16
       */
      precompute(windowSize = 8, point = Point.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    return {
      CURVE,
      getPublicKey,
      sign,
      verify,
      ExtendedPoint: Point,
      utils
    };
  }

  // ../../node_modules/@near-js/crypto/node_modules/@noble/curves/esm/ed25519.js
  var ED25519_P2 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
  var ED25519_SQRT_M12 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  var _0n10 = BigInt(0);
  var _1n10 = BigInt(1);
  var _2n8 = BigInt(2);
  var _5n4 = BigInt(5);
  var _10n = BigInt(10);
  var _20n = BigInt(20);
  var _40n = BigInt(40);
  var _80n = BigInt(80);
  function ed25519_pow_2_252_32(x) {
    const P = ED25519_P2;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow22(b2, _2n8, P) * b2 % P;
    const b5 = pow22(b4, _1n10, P) * x % P;
    const b10 = pow22(b5, _5n4, P) * b5 % P;
    const b20 = pow22(b10, _10n, P) * b10 % P;
    const b40 = pow22(b20, _20n, P) * b20 % P;
    const b80 = pow22(b40, _40n, P) * b40 % P;
    const b160 = pow22(b80, _80n, P) * b80 % P;
    const b240 = pow22(b160, _80n, P) * b80 % P;
    const b250 = pow22(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = pow22(b250, _2n8, P) * x % P;
    return { pow_p_5_8, b2 };
  }
  function adjustScalarBytes2(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  }
  function uvRatio2(u, v) {
    const P = ED25519_P2;
    const v3 = mod2(v * v * v, P);
    const v7 = mod2(v3 * v3 * v, P);
    const pow4 = ed25519_pow_2_252_32(u * v7).pow_p_5_8;
    let x = mod2(u * v3 * pow4, P);
    const vx2 = mod2(v * x * x, P);
    const root1 = x;
    const root2 = mod2(x * ED25519_SQRT_M12, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod2(-u, P);
    const noRoot = vx2 === mod2(-u * ED25519_SQRT_M12, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (isNegativeLE2(x, P))
      x = mod2(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  }
  var Fp2 = Field2(ED25519_P2, void 0, true);
  var ed25519Defaults2 = {
    // Param: a
    a: BigInt(-1),
    // d is equal to -121665/121666 over finite field.
    // Negative number is P - number, and division is invert(number, P)
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
    Fp: Fp2,
    // Subgroup order: how many points curve has
    // 2n**252n + 27742317777372353535851937790883648493n;
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    // Cofactor
    h: BigInt(8),
    // Base point (x, y) aka generator point
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: sha5122,
    randomBytes: randomBytes2,
    adjustScalarBytes: adjustScalarBytes2,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/√v
    uvRatio: uvRatio2
  };
  var ed255192 = /* @__PURE__ */ twistedEdwards2(ed25519Defaults2);
  function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255)
      throw new Error("Context is too big");
    return concatBytes3(utf8ToBytes3("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
  }
  var ed25519ctx = /* @__PURE__ */ twistedEdwards2({
    ...ed25519Defaults2,
    domain: ed25519_domain
  });
  var ed25519ph = /* @__PURE__ */ twistedEdwards2({
    ...ed25519Defaults2,
    domain: ed25519_domain,
    prehash: sha5122
  });
  var ELL2_C1 = (Fp2.ORDER + BigInt(3)) / BigInt(8);
  var ELL2_C2 = Fp2.pow(_2n8, ELL2_C1);
  var ELL2_C3 = Fp2.sqrt(Fp2.neg(Fp2.ONE));
  var ELL2_C4 = (Fp2.ORDER - BigInt(5)) / BigInt(8);
  var ELL2_J = BigInt(486662);
  var ELL2_C1_EDWARDS = FpSqrtEven2(Fp2, Fp2.neg(BigInt(486664)));
  var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

  // ../../node_modules/@near-js/crypto/lib/esm/key_pair_ed25519.js
  var import_randombytes3 = __toESM(require_browser2(), 1);

  // ../../node_modules/@near-js/crypto/lib/esm/public_key.js
  var import_secp256k13 = __toESM(require_elliptic3(), 1);
  function key_type_to_str(keyType) {
    switch (keyType) {
      case KeyType2.ED25519:
        return "ed25519";
      case KeyType2.SECP256K1:
        return "secp256k1";
      default:
        throw new Error(`Unknown key type ${keyType}`);
    }
  }
  function str_to_key_type(keyType) {
    switch (keyType.toLowerCase()) {
      case "ed25519":
        return KeyType2.ED25519;
      case "secp256k1":
        return KeyType2.SECP256K1;
      default:
        throw new Error(`Unknown key type ${keyType}`);
    }
  }
  function resolveEnumKeyName2(keyType) {
    switch (keyType) {
      case KeyType2.ED25519: {
        return "ed25519Key";
      }
      case KeyType2.SECP256K1: {
        return "secp256k1Key";
      }
      default: {
        throw Error(`unknown type ${keyType}`);
      }
    }
  }
  var Enum2 = class {
    constructor(properties) {
      if (Object.keys(properties).length !== 1) {
        throw new Error("Enum can only take single value");
      }
      Object.keys(properties).map((key) => {
        this[key] = properties[key];
      });
    }
  };
  var PublicKey2 = class _PublicKey extends Enum2 {
    enum;
    ed25519Key;
    secp256k1Key;
    constructor(publicKey) {
      const keyName = resolveEnumKeyName2(publicKey.keyType);
      super({ [keyName]: publicKey });
      this[keyName] = publicKey;
      this.enum = keyName;
    }
    /**
     * Creates a PublicKey instance from a string or an existing PublicKey instance.
     * @param value The string or PublicKey instance to create a PublicKey from.
     * @returns {PublicKey} The PublicKey instance.
     */
    static from(value) {
      if (typeof value === "string") {
        return _PublicKey.fromString(value);
      }
      return value;
    }
    /**
     * Creates a PublicKey instance from an encoded key string.
     * @param encodedKey The encoded key string.
     * @returns {PublicKey} The PublicKey instance created from the encoded key string.
     */
    static fromString(encodedKey) {
      const parts = encodedKey.split(":");
      let publicKey;
      let keyType;
      if (parts.length === 1) {
        publicKey = parts[0];
      } else if (parts.length === 2) {
        publicKey = parts[1];
        keyType = str_to_key_type(parts[0]);
      } else {
        throw new Error("Invalid encoded key format, must be <curve>:<encoded key>");
      }
      const decodedPublicKey = baseDecode2(publicKey);
      if (!keyType) {
        keyType = decodedPublicKey.length === KeySize2.SECP256k1_PUBLIC_KEY ? KeyType2.SECP256K1 : KeyType2.ED25519;
      }
      const keySize = keyType === KeyType2.ED25519 ? KeySize2.ED25519_PUBLIC_KEY : KeySize2.SECP256k1_PUBLIC_KEY;
      if (decodedPublicKey.length !== keySize) {
        throw new Error(`Invalid public key size (${decodedPublicKey.length}), must be ${keySize}`);
      }
      return new _PublicKey({ keyType, data: decodedPublicKey });
    }
    /**
     * Returns a string representation of the public key.
     * @returns {string} The string representation of the public key.
     */
    toString() {
      const encodedKey = baseEncode2(this.data);
      return `${key_type_to_str(this.keyType)}:${encodedKey}`;
    }
    /**
     * Verifies a message signature using the public key.
     * @param message The message to be verified.
     * @param signature The signature to be verified.
     * @returns {boolean} `true` if the signature is valid, otherwise `false`.
     */
    verify(message, signature) {
      const keyType = this.keyType;
      const data = this.data;
      switch (keyType) {
        case KeyType2.ED25519:
          return ed255192.verify(signature, message, data);
        case KeyType2.SECP256K1:
          return import_secp256k13.default.ecdsaVerify(signature.subarray(0, 64), message, new Uint8Array([4, ...data]));
        default:
          throw new Error(`Unknown key type: ${keyType}`);
      }
    }
    get keyPair() {
      return this.ed25519Key || this.secp256k1Key;
    }
    get keyType() {
      return this.keyPair.keyType;
    }
    get data() {
      return this.keyPair.data;
    }
  };

  // ../../node_modules/@near-js/crypto/lib/esm/key_pair_secp256k1.js
  var import_randombytes4 = __toESM(require_browser2(), 1);
  var import_secp256k14 = __toESM(require_elliptic3(), 1);

  // src/adapters/meteor.ts
  async function createMeteorWalletInstance({ networkId = "mainnet" }) {
    const keyStore = new key_stores_exports.BrowserLocalStorageKeyStore(
      window.localStorage,
      "_meteor_wallet"
    );
    const near = await connect({
      keyStore,
      networkId,
      nodeUrl: networkId === "mainnet" ? "https://rpc.mainnet.near.org" : "https://rpc.testnet.near.org"
    });
    return new import_meteorwallet_sdk.MeteorWallet({ near, appKeyPrefix: "near_app" });
  }
  function createMeteorAdapter() {
    return {
      async signIn({ networkId, contractId, publicKey }) {
        publicKey = PublicKey2.from(publicKey);
        console.log("aloha publicKey", publicKey);
        const keyPair = KeyPair.fromString(publicKey.toString());
        console.log("aloha keyPair", keyPair);
        const wallet = await createMeteorWalletInstance({ networkId });
        const {
          success,
          payload: { accountId }
        } = await wallet.requestSignIn({
          contract_id: contractId,
          type: import_meteorwallet_sdk.EMeteorWalletSignInType.ALL_METHODS,
          keyPair
        });
        if (!success) {
          throw new Error("Meteor Wallet sign in failed");
        }
        return {
          state: {
            accountId,
            publicKey: publicKey.toString(),
            networkId
          }
        };
      },
      async sendTransactions({ state, transactions }) {
        if (!state?.accountId) {
          throw new Error("Not signed in");
        }
        const wallet = await createMeteorWalletInstance({
          networkId: state?.networkId
        });
        try {
          const response = await wallet.requestSignTransactions({
            transactions: transactions.map(
              ({ signerId, receiverId, actions }) => {
                if (signerId && signerId !== state.accountId) {
                  throw new Error("Invalid signer");
                }
                return {
                  signerId: state.accountId,
                  receiverId,
                  actions: actions.map(mapActionForWalletSelector)
                };
              }
            )
          });
          return { outcomes: response };
        } catch (error) {
          if (error.message === "User cancelled the action" || error.message === "User closed the window before completing the action") {
            return { rejected: true };
          }
          console.log(error);
          throw new Error(error);
        }
      }
    };
  }

  // src/wallets.ts
  var wallets = [
    {
      id: "near",
      name: "NEAR Wallet",
      icon: near_default,
      adapter: createNearAdapter()
    },
    {
      id: "here",
      name: "HERE Wallet",
      icon: here_default,
      adapter: createHereAdapter()
    },
    {
      id: "meteor",
      name: "Meteor Wallet",
      icon: meteor_default,
      adapter: createMeteorAdapter()
    }
  ];

  // src/index.ts
  var params = {};
  window.addEventListener("message", (event) => {
    if (event.source !== window.parent) {
      return;
    }
    if (event.data.method === "signIn") {
      params = event.data.params || {};
      handleLogin();
    } else if (event.data.method === "sendTransactions") {
      params = event.data.params || {};
      handleSend();
    }
  });
  async function handleLogin() {
    function setupWalletList() {
      const walletList = document.getElementById("walletList");
      walletList.innerHTML = wallets.map(
        (wallet) => `
      <li class="wallet-item">
        <button class="wallet-button" data-wallet-id="${wallet.id}">
          <img class="wallet-icon" src="${wallet.icon}" alt="${wallet.name} icon">
          ${wallet.name}
        </button>
      </li>
    `
      ).join("");
      walletList.addEventListener("click", handleWalletSelect);
    }
    async function handleWalletSelect(e) {
      const button = e.target.closest(".wallet-button");
      if (!button) return;
      const wallet = wallets.find((w) => w.id === button.dataset.walletId);
      if (!wallet) return;
      try {
        const result = await wallet.adapter.signIn(params);
        window.parent.postMessage(
          {
            type: "wallet-adapter",
            id: params.id,
            payload: {
              ...result,
              state: {
                ...result.state,
                lastWalletId: wallet.id
              }
            }
          },
          "*"
        );
      } catch (error) {
        window.parent.postMessage(
          {
            type: "wallet-adapter",
            id: params.id,
            payload: { error: error.message }
          },
          "*"
        );
      }
    }
    document.getElementById("closeButton")?.addEventListener("click", () => {
      window.parent.postMessage(
        {
          type: "wallet-adapter",
          action: "close"
        },
        "*"
      );
    });
    setupWalletList();
  }
  async function handleSend() {
    const { state = {} } = params;
    const wallet = wallets.find((w) => w.id === state.lastWalletId);
    if (!wallet) {
      window.parent.postMessage(
        {
          type: "wallet-adapter",
          id: params.id,
          payload: { error: "No wallet selected" }
        },
        "*"
      );
      return;
    }
    if (state.lastWalletId === "meteor") {
      const sendButton = document.getElementById("sign-transaction");
      sendButton.addEventListener("click", async () => {
        try {
          const result = await wallet.adapter.sendTransactions(params);
          window.parent.postMessage(
            {
              type: "wallet-adapter",
              id: params.id,
              payload: result
            },
            "*"
          );
        } catch (error) {
          window.parent.postMessage(
            {
              type: "wallet-adapter",
              id: params.id,
              payload: { error: error.message }
            },
            "*"
          );
        }
      });
    } else {
      try {
        const result = await wallet.adapter.sendTransactions(params);
        window.parent.postMessage(
          {
            type: "wallet-adapter",
            id: params.id,
            payload: result
          },
          "*"
        );
      } catch (error) {
        window.parent.postMessage(
          {
            type: "wallet-adapter",
            id: params.id,
            payload: { error: error.message }
          },
          "*"
        );
      }
    }
  }
  return __toCommonJS(src_exports);
})();
/*! Bundled license information:

mustache/mustache.js:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

depd/lib/browser/index.js:
  (*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.11.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2024
   * @license MIT
   *)

mustache/mustache.mjs:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.js.map
