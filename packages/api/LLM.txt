# FastINTEAR - NEAR Protocol JavaScript SDK

## Project Overview
FastINTEAR is an experimental fork of the @fastnear/js-monorepo that provides a simplified JavaScript SDK for interacting with the NEAR Protocol blockchain. The project focuses on browser-first development with Node.js decoupling and exclusively uses the INTEAR Wallet for authentication and transaction signing.

## Key Features
- **Modern State Management**: Session-aware state management with external state manager support
- **Browser-First Design**: No Node.js dependencies, uses modern browser APIs
- **Client Isolation**: Multiple isolated NEAR client instances with independent state
- **External State Integration**: Support for external state managers (e.g., better-near-auth)
- **Reactive State System**: Event-driven state updates with comprehensive callbacks
- **INTEAR Wallet Integration**: Exclusively uses INTEAR Wallet for authentication and signing
- **Safe Mode Support**: Memory-only state for enhanced security
- **Static HTML Support**: Enables web3 projects with pure static HTML files
- **TypeScript Support**: Full TypeScript support with proper type definitions
- **Monorepo Structure**: Organized as a yarn workspace with multiple packages
- **Dual Environment Support**: Works in both browser and Node.js with different signing strategies
- **Real-time Event System**: Comprehensive event handling for account changes and transaction status
- **Transaction History Tracking**: Persistent transaction history with status monitoring
- **WebSocket Logout Detection**: Real-time logout notifications via bridge service

## Project Structure

### Root Level
- `package.json` - Main workspace configuration
- `tsconfig.base.json` - Base TypeScript configuration
- `yarn.lock` / `bun.lock` - Package manager lock files
- `README.md` - Project documentation
- `examples/` - Example implementations (static and dynamic)
- `packages/` - Core packages
- `types/` - TypeScript type definitions

### Core Packages

#### packages/api (Main Package - "fastintear")
The primary package that provides both client-based and global NEAR API access.

**Key Files:**
- `src/index.ts` - Main export file with global type declarations
- `src/client.ts` - Modern client creation with isolated state management
- `src/near.ts` - Core NEAR Protocol functionality and action helpers
- `src/intear.ts` - INTEAR Wallet adapter implementation with WebSocket support
- `src/state.ts` - Modern state management system with multiple implementations
- `dist/` - Compiled output (ESM, CJS, UMD/IIFE)

**Build Targets:**
- ESM: `dist/esm/index.js`
- CommonJS: `dist/cjs/index.cjs`
- Browser Global: `dist/umd/browser.global.js` (IIFE format)

#### packages/utils
Utility functions for cryptography, encoding, transaction serialization, and NEAR Protocol operations.

**Key Files:**
- `src/crypto.ts` - Ed25519 cryptographic operations
- `src/transaction.ts` - Transaction serialization and Borsh schema mapping
- `src/misc.ts` - Unit conversion, encoding utilities, and helper functions
- `src/storage.ts` - Cross-platform storage abstraction

#### packages/repl
REPL environment for testing and development.

#### packages/borsh-schema
Borsh serialization schema utilities for NEAR Protocol data structures.

#### packages/wallet-adapter & packages/wallet-adapter-widget
Wallet adapter components and widgets (legacy components, INTEAR adapter is built-in).

## Modern State Management Architecture

### State Manager Interface
```typescript
interface StateManager {
  getState(): Promise<WalletState | null>;
  setState(state: WalletState): Promise<void>;
  clearState(): Promise<void>;
  subscribe(callback: (state: WalletState) => void): () => void;
}

interface WalletState {
  accountId: string | null;
  publicKey: string | null;
  privateKey: string | null;
  networkId: string;
  lastWalletId?: string | null;
  accessKeyContractId?: string | null;
}
```

### Built-in State Managers

**LocalStorageStateManager (Default):**
- Persists state to browser localStorage
- Automatic publicKey derivation from privateKey
- Network-specific state isolation
- Reactive subscriber notifications

**MemoryStateManager:**
- In-memory state for testing/isolation
- No persistence between sessions
- Useful for unit tests and temporary clients

**ExternalStateManagerWrapper:**
- Wraps external state managers (e.g., better-near-auth)
- Provides StateManager interface compatibility
- Enables session-aware external state control

### External State Manager Support
```typescript
interface ExternalStateManager {
  getState(): Promise<WalletState | null>;
  setState(state: WalletState): Promise<void>;
  clearState(): Promise<void>;
}

// Usage with better-near-auth or similar
const client = createNearClient({
  networkId: "mainnet",
  stateManager: myExternalStateManager,
  callbacks: {
    onStateChange: (state) => console.log("State changed:", state),
    onConnect: (account) => console.log("Connected:", account),
    onDisconnect: () => console.log("Disconnected")
  }
});
```

## Environment-Specific Usage Patterns

### Browser Environment
In browsers, FastINTEAR uses a hybrid signing approach with intelligent decision-making:

**Limited Access Key (LAK) Signing:**
- Used for simple function calls with zero deposit
- Automatically determined by `canSignWithLAK()` function
- Signs transactions locally using stored private key
- No wallet popup required for basic interactions
- Requires `receiverId === contractId` from sign-in

**Wallet Signing:**
- Required for transactions with deposits (`hasNonZeroDeposit()`)
- Required for non-function-call actions (transfers, staking, etc.)
- Required when `receiverId !== contractId`
- Opens INTEAR Wallet popup for user approval
- Handles complex transaction scenarios

**Decision Logic (Actual Implementation):**
```javascript
if (!privKey || receiverId !== _state.accessKeyContractId || !canSignWithLAK(actions) || hasNonZeroDeposit(actions)) {
  // Use wallet signing (popup)
  const result = await _adapter.sendTransactions({ transactions: [jsonTx] });
} else {
  // Use LAK signing (local) - serialize and sign directly
  const signedTxBase64 = bytesToBase64(serializeSignedTransaction(plainTransactionObj, signatureBase58));
  return await sendTxToRpc(signedTxBase64, waitUntil, txId);
}
```

### Node.js Environment
In Node.js, FastINTEAR supports multiple signing strategies:

**Full Access Key (FAK) Signing:**
- Direct transaction signing with full account access
- No wallet dependency required
- Suitable for server-side applications and automation
- Can sign any transaction type including transfers and staking

**Function Call Access Key (FCAK) Signing:**
- Limited to specific contract method calls
- Restricted by allowance and method permissions
- Useful for service accounts with limited scope

**Transaction Relaying:**
- Sign transactions on behalf of users
- Relay signed transactions to the network
- Useful for meta-transaction patterns

## Core API

### Client Creation (Preferred)

**createNearClient Function:**
```typescript
import { createNearClient } from "fastintear";

// Create isolated NEAR client instance
const nearClient = createNearClient({ networkId: "mainnet" });

// Multiple clients with different configurations
const mainnetClient = createNearClient({ networkId: "mainnet" });
const testnetClient = createNearClient({ networkId: "testnet" });

// External state management (e.g., better-near-auth)
const externalClient = createNearClient({
  networkId: "mainnet",
  stateManager: myExternalStateManager,
  callbacks: {
    onStateChange: (state) => updateUI(state),
    onConnect: (account) => showWelcome(account),
    onDisconnect: () => showSignIn()
  }
});

// Isolated state (memory-only)
const testClient = createNearClient({ 
  networkId: "testnet", 
  isolateState: true 
});
```

**Client Configuration:**
```typescript
// Configure network for specific client
nearClient.config({ networkId: "mainnet" });

// Get current configuration
const config = nearClient.config();
console.log(config.nodeUrl, config.networkId);

// Network switching clears state and resets transaction history
nearClient.config({ networkId: "testnet" }); // Triggers state reset for this client only
```

**Client State Management:**
```typescript
// Each client maintains isolated state
const client1 = createNearClient({ networkId: "mainnet" });
const client2 = createNearClient({ networkId: "testnet" });

// Sign in to different accounts on different networks
await client1.requestSignIn({ contractId: "mainnet-contract.near" });
await client2.requestSignIn({ contractId: "testnet-contract.near" });

// Independent authentication status
console.log(client1.accountId()); // "user.near"
console.log(client2.accountId()); // "testuser.testnet"
console.log(client1.authStatus()); // "SignedIn"
console.log(client2.authStatus()); // "SignedIn"

// Independent transaction histories
const mainnetHistory = client1.localTxHistory();
const testnetHistory = client2.localTxHistory();

// State management methods
const state = await client1.getState();
await client1.setState(newState);
await client1.clearState();

// External state restoration
await client1.restoreFromExternalState({
  accountId: "user.near",
  publicKey: "ed25519:...",
  privateKey: "ed25519:...", // optional
  networkId: "mainnet"
});

// Check if externally managed
const isExternal = client1.isExternallyManaged();

// Reactive state subscription
const unsubscribe = client1.subscribe((state) => {
  console.log("State changed:", state);
});

// Cleanup
client1.destroy();
```

### Global Configuration (Alternative)
```typescript
import * as near from "fastintear";

// Configure network globally
near.config({ networkId: "mainnet" });

// Get current configuration
const config = near.config();
console.log(config.nodeUrl, config.networkId);

// Network switching clears state and resets transaction history
near.config({ networkId: "testnet" }); // Triggers global state reset
```

### Browser Console & Static HTML (IIFE)

**Standard Usage:**
```html
<script src="https://cdn.jsdelivr.net/npm/fastintear/dist/umd/browser.global.js"></script>
<script>
  // Global `near` object is now available
  near.config({ networkId: "mainnet" });
  
  // Also available: window.$$ = near.utils.convertUnit
  const amount = $$`1 NEAR`; // "1000000000000000000000000"
</script>
```

**Safe Mode (Memory-Only State):**
```html
<!-- Safe mode with ?memory parameter -->
<script src="https://cdn.jsdelivr.net/npm/fastintear/dist/umd/browser.global.js?memory"></script>

<!-- Or use ?safe parameter -->
<script src="https://cdn.jsdelivr.net/npm/fastintear/dist/umd/browser.global.js?safe"></script>

<script>
  // Global near object initialized in safe mode (no localStorage persistence)
  near.config({ networkId: "mainnet" });
  
  // Perfect for browser console experimentation & static, secure interfaces
  await near.requestSignIn({ contractId: "example.near" });
</script>
```

**Safe Mode Benefits:**
- **No Persistent State**: Authentication state cleared on page refresh
- **Enhanced Security**: No localStorage storage of sensitive data
- **Console Experimentation**: Perfect for testing and development
- **Clean Sessions**: Each page load starts fresh

### Authentication

#### Browser Authentication (Wallet-Based)

**Client-Based Usage (Preferred):**
```typescript
import { createNearClient } from "fastintear";

const nearClient = createNearClient({ networkId: "mainnet" });

// Simple sign in with INTEAR Wallet (opens popup)
await nearClient.requestSignIn({ contractId: "example.near" });

// Check authentication status
const status = nearClient.authStatus(); // "SignedIn" | "SignedOut"

// Get current account (with periodic session verification)
const accountId = nearClient.accountId();

// Get current public key
const publicKey = nearClient.publicKey();

// Get selected network and account details
const selected = nearClient.selected();

// Sign out (clears local state and notifies wallet)
await nearClient.signOut();
```

**Enhanced Usage with Callbacks (Client-Based):**
```typescript
const nearClient = createNearClient({ 
  networkId: "mainnet",
  callbacks: {
    onStateChange: (state) => {
      console.log("State changed:", state);
      updateUI(state);
    },
    onConnect: (account) => {
      console.log("Connected:", account);
      showDashboard(account);
    },
    onDisconnect: () => {
      console.log("Disconnected");
      showSignInPage();
    }
  }
});

// Enhanced sign in with success and error callbacks
await nearClient.requestSignIn(
  { contractId: "example.near" },
  {
    onSuccess: (result) => {
      console.log("Successfully signed in:", result.accountId);
      console.log("Public key:", result.publicKey);
      console.log("Network:", result.networkId);
      console.log("Is reconnection:", result.isReconnection);
    },
    onError: (error) => {
      console.error("Sign-in failed:", error.message);
      console.log("Error occurred at:", new Date(error.timestamp));
      console.log("Original error:", error.originalError);
      alert(`Sign-in error: ${error.message}`);
    },
    timeout: 120000 // 2 minutes timeout (default: 60000ms)
  }
);
```

**Global Usage (Alternative):**
```typescript
import * as near from "fastintear";

// Simple sign in with INTEAR Wallet (opens popup)
await near.requestSignIn({ contractId: "example.near" });

// Check authentication status
const status = near.authStatus(); // "SignedIn" | "SignedOut"

// Get current account (with periodic session verification)
const accountId = near.accountId();

// Get current public key
const publicKey = near.publicKey();

// Get selected network and account details
const selected = near.selected();

// Sign out (clears local state and notifies wallet)
await near.signOut();
```

#### Node.js Authentication (Key-Based)
```typescript
// Set up with existing private key (global approach)
near.update({ 
  accountId: "your-account.near",
  privateKey: "ed25519:your-private-key-here"
});

// Or generate new keypair
import { privateKeyFromRandom } from "fastintear";
const newKey = privateKeyFromRandom();
```

### Transaction Signing Strategies

#### Simple Function Calls (LAK in Browser)
```typescript
// This will use LAK signing if conditions are met:
// - receiverId matches contractId from sign-in
// - Single FunctionCall action with zero deposit
await nearClient.sendTx({
  receiverId: "contract.near", // Must match contractId from requestSignIn
  actions: [
    nearClient.actions.functionCall({
      methodName: "get_data",
      args: { key: "value" },
      gas: "30000000000000",
      deposit: "0" // Zero deposit enables LAK signing
    })
  ]
});
```

#### Complex Transactions (Wallet/FAK Required)
```typescript
// This requires wallet popup in browser or FAK in Node.js
await nearClient.sendTx({
  receiverId: "contract.near",
  actions: [
    nearClient.actions.functionCall({
      methodName: "transfer",
      args: { receiver_id: "alice.near", amount: "1000" },
      gas: "30000000000000",
      deposit: "1000000000000000000000000" // Non-zero deposit
    })
  ]
});
```

### Message Signing
```typescript
// Sign arbitrary messages (requires wallet in browser)
const signature = await nearClient.signMessage({
  message: "Hello, NEAR!",
  recipient: "recipient.near",
  nonce: new Uint8Array(32) // Optional custom nonce (defaults to random)
});

console.log(signature.accountId, signature.publicKey, signature.signature);
```

### Contract Interaction
```typescript
// View method calls (no signing required)
const result = await nearClient.view({
  contractId: "contract.near",
  methodName: "get_data",
  args: { account_id: "user.near" },
  blockId: "final" // Optional block specification
});

// Query account information
const account = await nearClient.queryAccount({
  accountId: "user.near",
  blockId: "optimistic"
});

// Query access key details
const accessKey = await nearClient.queryAccessKey({
  accountId: "user.near",
  publicKey: "ed25519:...",
  blockId: "final"
});

// Query transaction status
const txResult = await nearClient.queryTx({
  txHash: "transaction-hash",
  accountId: "signer.near"
});

// Query block information
const block = await nearClient.queryBlock({ blockId: "final" });
```

### Transaction History and Events
```typescript
// Get local transaction history
const history = nearClient.localTxHistory();

// Listen for transaction updates (client-specific)
const unsubscribeTx = nearClient.onTx((txStatus) => {
  console.log(`Transaction ${txStatus.txId}: ${txStatus.status}`);
  
  switch (txStatus.status) {
    case "Pending":
      console.log("Transaction submitted to network");
      break;
    case "Included": 
      console.log("Transaction included in block");
      break;
    case "Executed":
      console.log("Transaction executed successfully");
      console.log("Result:", txStatus.successValue);
      break;
    case "Error":
    case "ErrorAfterIncluded":
      console.error("Transaction failed:", txStatus.error);
      break;
    case "RejectedByUser":
      console.log("User rejected transaction");
      break;
  }
});

// State subscription (reactive updates)
const unsubscribeState = nearClient.subscribe((state) => {
  console.log("State updated:", state);
  if (state.accountId) {
    console.log("Signed in as:", state.accountId);
  } else {
    console.log("Signed out");
  }
});

// Cleanup subscriptions
unsubscribeTx();
unsubscribeState();
nearClient.destroy(); // Cleanup all subscriptions
```

### Action Helpers
```typescript
// Function call action
nearClient.actions.functionCall({
  methodName: "transfer",
  args: { receiver_id: "alice.near", amount: "1000" },
  gas: "30000000000000", // Optional, defaults to 30 TGas
  deposit: "1" // Optional, defaults to "0"
});

// Function call with base64 args (alternative)
nearClient.actions.functionCall({
  methodName: "method_name",
  argsBase64: "base64-encoded-args",
  gas: "30000000000000"
});

// Transfer action (always requires wallet/FAK)
nearClient.actions.transfer("1000000000000000000000000"); // 1 NEAR in yoctoNEAR

// Stake action
nearClient.actions.stake({
  amount: "1000000000000000000000000",
  publicKey: "ed25519:..."
});

// Key management actions
nearClient.actions.addFullAccessKey({ publicKey: "ed25519:..." });
nearClient.actions.addLimitedAccessKey({
  publicKey: "ed25519:...",
  allowance: "1000000000000000000000000",
  accountId: "contract.near",
  methodNames: ["method1", "method2"]
});
nearClient.actions.deleteKey({ publicKey: "ed25519:..." });

// Account management
nearClient.actions.createAccount();
nearClient.actions.deleteAccount({ beneficiaryId: "beneficiary.near" });

// Contract deployment
nearClient.actions.deployContract({ codeBase64: "base64-encoded-wasm" });
```

## INTEAR Wallet Integration

### Wallet Adapter Features
- **Popup-based Authentication**: Uses popup windows for secure authentication
- **Real-time Logout Detection**: WebSocket connection for instant logout notifications
- **Session Verification**: Automatic session validation with bridge service
- **Signature Verification**: Cryptographic verification of all operations
- **Cross-tab Synchronization**: Logout events propagate across browser tabs
- **Automatic Reconnection**: WebSocket reconnection with exponential backoff

### Authentication Flow
1. User calls `nearClient.requestSignIn({ contractId: "example.near" })`
2. Popup opens to INTEAR Wallet (`https://wallet.intear.tech`)
3. User authenticates in wallet
4. Wallet returns account info and LAK keypair
5. Session established with logout monitoring via WebSocket
6. Bridge service monitors for remote logout events

### Session Management
```typescript
// The adapter automatically handles session verification
const adapter = new WalletAdapter({
  walletUrl: "https://wallet.intear.tech",
  logoutBridgeService: "https://logout-bridge-service.intear.tech",
  onStateUpdate: (state) => {
    // Handle state updates (login/logout)
    console.log("Account changed:", state.accountId);
  }
});

// Check current accounts (triggers session verification)
const accounts = await adapter.getAccounts();
```

### WebSocket Logout Detection
The system maintains a WebSocket connection to detect when users log out from the wallet:

```typescript
// Automatic WebSocket connection established after login
// Authentication message format:
const authMessage = {
  Auth: {
    network: "mainnet",
    account_id: "user.near",
    app_public_key: "ed25519:...",
    nonce: Date.now(),
    signature: "ed25519:signature..."
  }
};

// Server responses:
// { Success: { message: "Connected" } }
// { Error: { message: "Authentication failed" } }
// { LoggedOut: { network, account_id, app_public_key, logout_info } }

// Logout verification process:
// 1. Verify nonce is within 5-minute window
// 2. Reconstruct message: `logout|${nonce}|${account_id}|${app_public_key}`
// 3. Verify signature against user's logout public key
// 4. Clear local storage and reload page if valid
```

## Technical Architecture

### Modern State Management System

**State Priority Logic:**
1. **External state manager** (if provided) - highest priority
2. **Manual restoration** (via `restoreFromExternalState()`) - medium priority  
3. **localStorage** (current behavior) - fallback priority

**State Synchronization:**
```typescript
// Reactive state updates with callbacks
const client = createNearClient({
  networkId: "mainnet",
  stateManager: externalStateManager, // Optional
  callbacks: {
    onStateChange: (newState) => {
      // Called whenever state changes
      updateApplicationState(newState);
    },
    onConnect: (accountData) => {
      // Called when user connects
      showWelcomeMessage(accountData);
    },
    onDisconnect: () => {
      // Called when user disconnects
      redirectToSignIn();
    }
  }
});
```

### Transaction Decision Tree (Actual Implementation)
```
sendTx() Called
├── Check Prerequisites
│   ├── signerId exists? → No: throw "Must sign in"
│   └── Yes: continue
├── Generate Transaction ID (generateTxId())
├── Decision Logic
│   ├── !privKey OR receiverId !== accessKeyContractId OR !canSignWithLAK(actions) OR hasNonZeroDeposit(actions)
│   │   ├── True: Wallet Signing Path
│   │   │   ├── Create JSON transaction
│   │   │   ├── Update transaction history (status: "Pending")
│
