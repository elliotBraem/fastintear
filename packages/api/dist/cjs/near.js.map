{
  "version": 3,
  "sources": ["../../src/near.ts", "../../../wallet-adapter/src/index.ts", "../../src/cryptoUtils.ts", "../../src/utils.ts", "../../src/transaction.ts"],
  "sourcesContent": ["import Big from \"big.js\";\nimport { WalletAdapter } from \"@fastnear/wallet-adapter\";\nimport * as cryptoUtils from \"./cryptoUtils.js\";\nimport {\n  canSignWithLAK,\n  fromBase58,\n  fromBase64,\n  lsGet,\n  lsSet,\n  toBase58,\n  toBase64,\n  tryParseJson,\n} from \"./utils\";\nimport {\n  serializeSignedTransaction,\n  serializeTransaction,\n} from \"./transaction\";\n\nBig.DP = 27;\n\n// Constants\nconst MaxBlockDelayMs = 1000 * 60 * 60 * 6; // 6 hours\n\n// const WIDGET_URL = \"https://wallet-adapter.fastnear.com\";\nconst WIDGET_URL = \"http://localhost:3000/\";\n\nconst DEFAULT_NETWORK_ID = \"mainnet\";\nconst NETWORKS = {\n  testnet: {\n    networkId: \"testnet\",\n    nodeUrl: \"https://rpc.testnet.fastnear.com/\",\n  },\n  mainnet: {\n    networkId: \"mainnet\",\n    nodeUrl: \"https://rpc.mainnet.fastnear.com/\",\n  },\n};\n\n// State\nlet _config = lsGet(\"config\") || { ...NETWORKS[DEFAULT_NETWORK_ID] };\n\nlet _state = lsGet(\"state\") || {};\ntry {\n  _state.publicKey = _state.privateKey\n    ? cryptoUtils.publicKeyFromPrivate(_state.privateKey)\n    : null;\n} catch (e) {\n  console.error(\"Error parsing private key:\", e);\n  _state.privateKey = null;\n  lsSet(\"nonce\", null);\n}\n\n// TODO: Store tx history in local storage more efficiently\nlet _txHistory = lsGet(\"txHistory\") || {};\nconst _eventListeners = {\n  account: new Set(),\n  tx: new Set(),\n};\nconst _unbroadcastedEvents = {\n  account: [],\n  tx: [],\n};\n\nfunction getWalletAdapterState() {\n  return {\n    publicKey: _state.publicKey,\n    accountId: _state.accountId,\n    lastWalletId: _state.lastWalletId,\n    networkId: DEFAULT_NETWORK_ID,\n  };\n}\nlet _adapter;\n\nfunction updateState(newState: Record<string, any>) {\n  const oldState = _state;\n  _state = { ..._state, ...newState };\n  lsSet(\"state\", {\n    accountId: _state.accountId,\n    privateKey: _state.privateKey,\n    lastWalletId: _state.lastWalletId,\n    accessKeyContractId: _state.accessKeyContractId,\n  });\n  if (\n    newState.hasOwnProperty(\"privateKey\") &&\n    newState.privateKey !== oldState.privateKey\n  ) {\n    _state.publicKey = newState.privateKey\n      ? cryptoUtils.publicKeyFromPrivate(newState.privateKey)\n      : null;\n    lsSet(\"nonce\", null);\n  }\n  if (newState.accountId !== oldState.accountId) {\n    notifyAccountListeners(newState.accountId);\n  }\n  if (\n    (newState.hasOwnProperty(\"lastWalletId\") &&\n      newState.lastWalletId !== oldState.lastWalletId) ||\n    (newState.hasOwnProperty(\"accountId\") &&\n      newState.accountId !== oldState.accountId) ||\n    (newState.hasOwnProperty(\"privateKey\") &&\n      newState.privateKey !== oldState.privateKey)\n  ) {\n    _adapter.setState(getWalletAdapterState());\n  }\n}\n\nfunction updateTxHistory(txStatus: Record<string, any>) {\n  const txId = txStatus.txId;\n  _txHistory[txId] = {\n    ...(_txHistory[txId] ?? {}),\n    ...txStatus,\n    updateTimestamp: Date.now(),\n  };\n  lsSet(\"txHistory\", _txHistory);\n  notifyTxListeners(_txHistory[txId]);\n}\n\nfunction onAdapterStateUpdate(state: Record<string, any>) {\n  console.log(\"Adapter state update:\", state);\n  const { accountId, lastWalletId, privateKey } = state;\n  updateState({\n    accountId,\n    lastWalletId,\n    ...(privateKey && { privateKey }),\n  });\n}\n\n// Create adapter instance\n_adapter = new WalletAdapter({\n  onStateUpdate: onAdapterStateUpdate,\n  lastState: getWalletAdapterState(),\n  widgetUrl: WIDGET_URL,\n});\n\n// Utils\nexport function parseJsonFromBytes(bytes: Uint8Array) {\n  try {\n    const decoder = new TextDecoder();\n    return JSON.parse(decoder.decode(bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes)));\n  } catch (e) {\n    try {\n      return bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);\n    } catch (e) {\n      return bytes;\n    }\n  }\n}\n\nfunction withBlockId(params: Record<string, any>, blockId?: string) {\n  return blockId === \"final\" || blockId === \"optimistic\"\n    ? { ...params, finality: blockId }\n    : blockId\n      ? { ...params, block_id: blockId }\n      : { ...params, finality: \"optimistic\" };\n}\n\nasync function queryRpc(method: string, params: Record<string, any> | any[]) {\n  const response = await fetch(_config.nodeUrl, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: `fastnear-${Date.now()}`,\n      method,\n      params,\n    }),\n  });\n\n  const result = await response.json();\n  if (result.error) {\n    throw new Error(JSON.stringify(result.error));\n  }\n  return result.result;\n}\n\nfunction afterTxSent(txId: string) {\n  queryRpc(\"tx\", {\n    tx_hash: _txHistory[txId].txHash,\n    sender_account_id: _txHistory[txId].tx.signerId,\n    wait_until: \"EXECUTED_OPTIMISTIC\",\n  })\n    .then((result) => {\n      const successValue = result?.status?.SuccessValue;\n      updateTxHistory({\n        txId,\n        status: \"Executed\",\n        result,\n        successValue: successValue\n          ? tryParseJson(fromBase64(successValue))\n          : undefined,\n        finalState: true,\n      });\n    })\n    .catch((error) => {\n      updateTxHistory({\n        txId,\n        status: \"ErrorAfterIncluded\",\n        error: tryParseJson(error.message),\n        finalState: true,\n      });\n    });\n}\n\nfunction sendTxToRpc(\n  signedTxBase64: string,\n  waitUntil: string | undefined,\n  txId: string,\n) {\n  queryRpc(\"send_tx\", {\n    signed_tx_base64: signedTxBase64,\n    wait_until: waitUntil ?? \"INCLUDED\",\n  })\n    .then((result) => {\n      console.log(\"Transaction included:\", result);\n      updateTxHistory({\n        txId,\n        status: \"Included\",\n        finalState: false,\n      });\n      afterTxSent(txId);\n    })\n    .catch((error) => {\n      updateTxHistory({\n        txId,\n        status: \"Error\",\n        error: tryParseJson(error.message),\n        finalState: false,\n      });\n    });\n}\n\n// Event Notifiers\nfunction notifyAccountListeners(accountId: string) {\n  if (_eventListeners.account.size === 0) {\n    _unbroadcastedEvents.account.push(accountId);\n    return;\n  }\n  _eventListeners.account.forEach((callback: any) => {\n    try {\n      callback(accountId);\n    } catch (e) {\n      console.error(e);\n    }\n  });\n}\n\nfunction notifyTxListeners(tx: Record<string, any>) {\n  if (_eventListeners.tx.size === 0) {\n    _unbroadcastedEvents.tx.push(tx);\n    return;\n  }\n  _eventListeners.tx.forEach((callback: any) => {\n    try {\n      callback(tx);\n    } catch (e) {\n      console.error(e);\n    }\n  });\n}\n\nfunction convertUnit(s: string | TemplateStringsArray, ...args: any[]): string {\n  // Reconstruct raw string from template literal\n  if (Array.isArray(s)) {\n    s = s.reduce((acc, part, i) => {\n      return acc + (args[i - 1] ?? \"\") + part;\n    });\n  }\n  // Convert from `100 NEAR` into yoctoNear\n  if (typeof s == \"string\") {\n    const match = s.match(/([0-9.,_]+)\\s*([a-zA-Z]+)?/);\n    if (match) {\n      const amount = match[1].replace(/[_,]/g, \"\");\n      const unitPart = match[2];\n      if (unitPart) {\n        switch (unitPart.toLowerCase()) {\n          case \"near\":\n            return Big(amount).mul(Big(10).pow(24)).toFixed(0);\n          case \"tgas\":\n            return Big(amount).mul(Big(10).pow(12)).toFixed(0);\n          case \"ggas\":\n            return Big(amount).mul(Big(10).pow(9)).toFixed(0);\n          case \"gas\":\n          case \"yoctonear\":\n            return Big(amount).toFixed(0);\n          default:\n            throw new Error(`Unknown unit: ${unitPart}`);\n        }\n      } else {\n        return Big(amount).toFixed(0);\n      }\n    }\n  }\n  return Big(s).toFixed(0);\n}\n\ninterface AccessKeyView {\n  nonce: number;\n  permission: any;\n}\n\n// Core API Implementation\nconst api = {\n  // Context\n  get accountId() {\n    return _state.accountId;\n  },\n\n  get publicKey() {\n    return _state.publicKey;\n  },\n\n  config(newConfig?: Record<string, any>) {\n    if (newConfig) {\n      if (newConfig.networkId && _config.networkId !== newConfig.networkId) {\n        _config = { ...NETWORKS[newConfig.networkId] };\n        updateState({\n          accountId: null,\n          privateKey: null,\n          lastWalletId: null,\n        });\n        lsSet(\"block\", null);\n        _txHistory = {};\n        lsSet(\"txHistory\", _txHistory);\n      }\n\n      _config = { ..._config, ...newConfig };\n      lsSet(\"config\", _config);\n    }\n    return _config;\n  },\n\n  get authStatus(): string | Record<string, any> {\n    if (!_state.accountId) {\n      return \"SignedOut\";\n    }\n\n    // Check for limited access key\n    const accessKey = _state.publicKey;\n    const contractId = _state.accessKeyContractId;\n    if (accessKey && contractId && _state.privateKey) {\n      return {\n        type: \"SignedInWithLimitedAccessKey\",\n        accessKey,\n        contractId,\n      };\n    }\n    return \"SignedIn\";\n  },\n\n  // Query Methods\n  async view({\n               contractId,\n               methodName,\n               args,\n               argsBase64,\n               blockId,\n             }: {\n    contractId: string;\n    methodName: string;\n    args?: any;\n    argsBase64?: string;\n    blockId?: string;\n  }) {\n    const encodedArgs =\n      argsBase64 || (args ? toBase64(JSON.stringify(args)) : \"\");\n\n    const result = await queryRpc(\n      \"query\",\n      withBlockId(\n        {\n          request_type: \"call_function\",\n          account_id: contractId,\n          method_name: methodName,\n          args_base64: encodedArgs,\n        },\n        blockId,\n      ),\n    );\n\n    return parseJsonFromBytes(result.result);\n  },\n\n  async account({\n                  accountId,\n                  blockId,\n                }: {\n    accountId: string;\n    blockId?: string;\n  }) {\n    return queryRpc(\n      \"query\",\n      withBlockId(\n        {\n          request_type: \"view_account\",\n          account_id: accountId,\n        },\n        blockId,\n      ),\n    );\n  },\n\n  async block({ blockId }: { blockId?: string }) {\n    return queryRpc(\"block\", withBlockId({}, blockId));\n  },\n\n  async accessKey({\n                    accountId,\n                    publicKey,\n                    blockId,\n                  }: {\n    accountId: string;\n    publicKey: string;\n    blockId?: string;\n  }): Promise<AccessKeyView> {\n    return queryRpc(\n      \"query\",\n      withBlockId(\n        {\n          request_type: \"view_access_key\",\n          account_id: accountId,\n          public_key: publicKey,\n        },\n        blockId,\n      ),\n    );\n  },\n\n  async tx({ txHash, accountId }: { txHash: string; accountId: string }) {\n    return queryRpc(\"tx\", [txHash, accountId]);\n  },\n\n  localTxHistory() {\n    return [..._txHistory];\n  },\n\n  // Transaction Methods\n  async sendTx({\n                 receiverId,\n                 actions,\n                 waitUntil,\n               }: {\n    receiverId: string;\n    actions: any[];\n    waitUntil?: string;\n  }) {\n    const signerId = _state.accountId;\n    if (!signerId) {\n      throw new Error(\"Not signed in\");\n    }\n\n    const publicKey = _state.publicKey;\n    const privateKey = _state.privateKey;\n    const txId = `tx-${Date.now()}-${Math.random()}`;\n\n    if (\n      !privateKey ||\n      receiverId !== _state.accessKeyContractId ||\n      !canSignWithLAK(actions)\n    ) {\n      const jsonTransaction = {\n        signerId,\n        receiverId,\n        actions,\n      };\n\n      updateTxHistory({\n        status: \"Pending\",\n        txId,\n        tx: jsonTransaction,\n        finalState: false,\n      });\n\n      const url = new URL(typeof window !== \"undefined\" ? window.location.href : \"\");\n      url.searchParams.set(\"txIds\", txId);\n\n      _adapter\n        .sendTransactions({\n          transactions: [jsonTransaction],\n          callbackUrl: url.toString(),\n        })\n        .then((result: any) => {\n          console.log(\"Transaction result:\", result);\n          if (result.url) {\n            console.log(\"Redirecting to wallet:\", result.url);\n            if (typeof window !== \"undefined\") {\n              setTimeout(() => {\n                window.location.href = result.url;\n              }, 100);\n            }\n          } else if (result.outcomes) {\n            result.outcomes.forEach((r: any) => {\n              updateTxHistory({\n                txId,\n                status: \"Executed\",\n                result: r,\n                txHash: r.transaction.hash,\n                finalState: true,\n              });\n            });\n          } else if (result.rejected) {\n            updateTxHistory({\n              txId,\n              status: \"RejectedByUser\",\n              finalState: true,\n            });\n          } else if (result.error) {\n            updateTxHistory({\n              txId,\n              status: \"Error\",\n              error: tryParseJson(result.error),\n              finalState: true,\n            });\n          }\n        })\n        .catch((error: any) => {\n          updateTxHistory({\n            txId,\n            status: \"Error\",\n            error: tryParseJson(error.message),\n            finalState: true,\n          });\n        });\n      return txId;\n    }\n\n    let nonce: number | null = lsGet(\"nonce\") as any;\n    let block: any = lsGet(\"block\") as any;\n    const toDoPromises: Record<string, Promise<any>> = {};\n\n    if (nonce === null || nonce === undefined) {\n      toDoPromises.nonce = api.accessKey({\n        accountId: signerId,\n        publicKey,\n      }).then((accessKey) => {\n        if ((accessKey as any).error) {\n          throw new Error(`Access key error: ${(accessKey as any).error}`);\n        }\n        lsSet(\"nonce\", accessKey.nonce);\n        return accessKey.nonce;\n      });\n    }\n\n    if (\n      !block ||\n      !block.header ||\n      parseFloat(block.header.timestamp_nanosec) / 1e6 + MaxBlockDelayMs <\n      Date.now()\n    ) {\n      toDoPromises.block = api.block({ blockId: \"final\" }).then((b: any) => {\n        const newBlock = {\n          header: {\n            prev_hash: b.header.prev_hash,\n            timestamp_nanosec: b.header.timestamp_nanosec,\n          },\n        };\n        lsSet(\"block\", newBlock);\n        return newBlock;\n      });\n    }\n\n    if (Object.keys(toDoPromises).length > 0) {\n      const results = await Promise.all(Object.values(toDoPromises));\n      const keys = Object.keys(toDoPromises);\n      results.forEach((res, i) => {\n        if (keys[i] === \"nonce\") {\n          nonce = res;\n        } else if (keys[i] === \"block\") {\n          block = res;\n        }\n      });\n    }\n\n    const newNonce = (nonce ?? 0) + 1;\n    lsSet(\"nonce\", newNonce);\n    const blockHash = block.header.prev_hash;\n\n    const jsonTransaction = {\n      signerId,\n      publicKey,\n      nonce: newNonce,\n      receiverId,\n      blockHash,\n      actions,\n    };\n\n    console.log(\"Transaction:\", jsonTransaction);\n    const transaction = serializeTransaction(jsonTransaction);\n    const txHash = toBase58(cryptoUtils.sha256(transaction));\n    const signature = cryptoUtils.signHash(txHash, privateKey);\n    const signedTransaction = serializeSignedTransaction(jsonTransaction, signature);\n    const signedTxBase64 = toBase64(signedTransaction);\n\n    updateTxHistory({\n      status: \"Pending\",\n      txId,\n      tx: jsonTransaction,\n      signature,\n      signedTxBase64,\n      txHash,\n      finalState: false,\n    });\n\n    sendTxToRpc(signedTxBase64, waitUntil, txId);\n\n    return txId;\n  },\n\n  // Authentication Methods\n  async requestSignIn({ contractId }: { contractId: string }) {\n    const privateKey = cryptoUtils.privateKeyFromRandom();\n    updateState({\n      accessKeyContractId: contractId,\n      accountId: null,\n      privateKey,\n    });\n    const publicKey = cryptoUtils.publicKeyFromPrivate(privateKey);\n    const result = await _adapter.signIn({\n      networkId: _config.networkId,\n      contractId,\n      publicKey,\n    });\n    console.log(\"Sign in result:\", result);\n    if (result.error) {\n      throw new Error(`Wallet error: ${result.error}`);\n    }\n    if (result.url) {\n      console.log(\"Redirecting to wallet:\", result.url);\n      if (typeof window !== \"undefined\") {\n        setTimeout(() => {\n          window.location.href = result.url;\n        }, 100);\n      }\n    } else if (result.accountId) {\n      updateState({\n        accountId: result.accountId,\n      });\n    }\n  },\n\n  signOut() {\n    updateState({\n      accountId: null,\n      privateKey: null,\n      contractId: null,\n    });\n    // TODO: Implement actual wallet integration\n  },\n\n  // Event Handlers\n  onAccount(callback: (accountId: string) => void) {\n    _eventListeners.account.add(callback);\n    if (_unbroadcastedEvents.account.length > 0) {\n      const events = _unbroadcastedEvents.account;\n      _unbroadcastedEvents.account = [];\n      events.forEach(notifyAccountListeners);\n    }\n  },\n\n  onTx(callback: (tx: Record<string, any>) => void) {\n    _eventListeners.tx.add(callback);\n    if (_unbroadcastedEvents.tx.length > 0) {\n      const events = _unbroadcastedEvents.tx;\n      _unbroadcastedEvents.tx = [];\n      events.forEach(notifyTxListeners);\n    }\n  },\n\n  // Action Helpers\n  actions: {\n    functionCall: ({\n                     methodName,\n                     gas,\n                     deposit,\n                     args,\n                     argsBase64,\n                   }: {\n      methodName: string;\n      gas?: string;\n      deposit?: string;\n      args?: Record<string, any>;\n      argsBase64?: string;\n    }) => ({\n      type: \"FunctionCall\",\n      methodName,\n      args,\n      argsBase64,\n      gas,\n      deposit,\n    }),\n\n    transfer: (yoctoAmount: string) => ({\n      type: \"Transfer\",\n      deposit: yoctoAmount,\n    }),\n\n    stakeNEAR: ({ amount, publicKey }: { amount: string; publicKey: string }) => ({\n      type: \"Stake\",\n      stake: amount,\n      publicKey,\n    }),\n\n    addFullAccessKey: ({ publicKey }: { publicKey: string }) => ({\n      type: \"AddKey\",\n      publicKey: publicKey,\n      accessKey: { permission: \"FullAccess\" },\n    }),\n\n    addLimitedAccessKey: ({\n                            publicKey,\n                            allowance,\n                            accountId,\n                            methodNames,\n                          }: {\n      publicKey: string;\n      allowance: string;\n      accountId: string;\n      methodNames: string[];\n    }) => ({\n      type: \"AddKey\",\n      publicKey: publicKey,\n      accessKey: {\n        permission: \"FunctionCall\",\n        allowance,\n        receiverId: accountId,\n        methodNames,\n      },\n    }),\n\n    deleteKey: ({ publicKey }: { publicKey: string }) => ({\n      type: \"DeleteKey\",\n      publicKey,\n    }),\n\n    deleteAccount: ({ beneficiaryId }: { beneficiaryId: string }) => ({\n      type: \"DeleteAccount\",\n      beneficiaryId,\n    }),\n\n    createAccount: () => ({\n      type: \"CreateAccount\",\n    }),\n\n    deployContract: ({ codeBase64 }: { codeBase64: string }) => ({\n      type: \"DeployContract\",\n      codeBase64,\n    }),\n  },\n\n  utils: {\n    toBase64,\n    fromBase64,\n    toBase58,\n    fromBase58,\n  },\n};\n\n// Handle wallet redirect if applicable\ntry {\n  if (typeof window !== \"undefined\") {\n    const url = new URL(window.location.href);\n    const accountId = url.searchParams.get(\"account_id\");\n    const publicKey = url.searchParams.get(\"public_key\");\n    const errorCode = url.searchParams.get(\"errorCode\");\n    const errorMessage = url.searchParams.get(\"errorMessage\");\n    const transactionHashes = url.searchParams.get(\"transactionHashes\");\n    const txIds = url.searchParams.get(\"txIds\");\n\n    if (errorCode || errorMessage) {\n      console.warn(new Error(`Wallet error: ${errorCode} ${errorMessage}`));\n    }\n\n    if (accountId && publicKey) {\n      if (publicKey === _state.publicKey) {\n        updateState({\n          accountId,\n        });\n      } else {\n        console.error(\n          new Error(\"Public key mismatch from wallet redirect\"),\n          publicKey,\n          _state.publicKey,\n        );\n      }\n    }\n\n    if (transactionHashes || txIds) {\n      const txHashes = transactionHashes ? transactionHashes.split(\",\") : [];\n      const txIdsArray = txIds ? txIds.split(\",\") : [];\n      if (txIdsArray.length > txHashes.length) {\n        txIdsArray.forEach((txId, i) => {\n          updateTxHistory({\n            txId,\n            status: \"RejectedByUser\",\n            finalState: true,\n          });\n        });\n      } else if (txIdsArray.length === txHashes.length) {\n        txIdsArray.forEach((txId, i) => {\n          updateTxHistory({\n            txId,\n            status: \"PendingGotTxHash\",\n            txHash: txHashes[i],\n            finalState: false,\n          });\n          afterTxSent(txId);\n        });\n      } else {\n        console.error(\n          new Error(\"Transaction hash mismatch from wallet redirect\"),\n          txIdsArray,\n          txHashes,\n        );\n      }\n    }\n\n    // Remove wallet parameters from the URL\n    url.searchParams.delete(\"account_id\");\n    url.searchParams.delete(\"public_key\");\n    url.searchParams.delete(\"errorCode\");\n    url.searchParams.delete(\"errorMessage\");\n    url.searchParams.delete(\"all_keys\");\n    url.searchParams.delete(\"transactionHashes\");\n    url.searchParams.delete(\"txIds\");\n    window.history.replaceState({}, \"\", url.toString());\n  }\n} catch (e) {\n  console.error(\"Error handling wallet redirect:\", e);\n}\n\nexport { api, convertUnit };\n\n// import Big from \"big.js\";\n// import { WalletAdapter } from \"@fastnear/wallet-adapter\";\n// import * as cryptoUtils from \"./cryptoUtils.js\";\n// import {\n//   canSignWithLAK,\n//   fromBase58,\n//   fromBase64,\n//   lsGet,\n//   lsSet,\n//   toBase58,\n//   toBase64,\n//   tryParseJson,\n// } from \"./utils\";\n// import {\n//   serializeSignedTransaction,\n//   serializeTransaction,\n// } from \"./transaction\";\n//\n// Big.DP = 27;\n//\n// // Constants\n// const MaxBlockDelayMs = 1000 * 60 * 60 * 6; // 6 hours\n//\n// // const WIDGET_URL = \"https://wallet-adapter.fastnear.com\";\n// const WIDGET_URL = \"http://localhost:3000/\";\n//\n// const DEFAULT_NETWORK_ID = \"mainnet\";\n// const NETWORKS = {\n//   testnet: {\n//     networkId: \"testnet\",\n//     nodeUrl: \"https://rpc.testnet.fastnear.com/\",\n//   },\n//   mainnet: {\n//     networkId: \"mainnet\",\n//     nodeUrl: \"https://rpc.mainnet.fastnear.com/\",\n//   },\n// };\n//\n// // State\n// let _config = lsGet(\"config\") || { ...NETWORKS[DEFAULT_NETWORK_ID] };\n//\n// let _state = lsGet(\"state\") || {};\n// try {\n//   _state.publicKey = _state.privateKey\n//     ? cryptoUtils.publicKeyFromPrivate(_state.privateKey)\n//     : null;\n// } catch (e) {\n//   console.error(\"Error parsing private key:\", e);\n//   _state.privateKey = null;\n//   lsSet(\"nonce\", null);\n// }\n//\n// // TODO: Store tx history in local storage more efficiently\n// let _txHistory = lsGet(\"txHistory\") || {};\n// const _eventListeners = {\n//   account: new Set(),\n//   tx: new Set(),\n// };\n// const _unbroadcastedEvents = {\n//   account: [],\n//   tx: [],\n// };\n//\n// function getWalletAdapterState() {\n//   return {\n//     publicKey: _state.publicKey,\n//     accountId: _state.accountId,\n//     lastWalletId: _state.lastWalletId,\n//     networkId: DEFAULT_NETWORK_ID,\n//   };\n// }\n// let _adapter;\n//\n// function updateState(newState) {\n//   const oldState = _state;\n//   _state = { ..._state, ...newState };\n//   lsSet(\"state\", {\n//     accountId: _state.accountId,\n//     privateKey: _state.privateKey,\n//     lastWalletId: _state.lastWalletId,\n//     accessKeyContractId: _state.accessKeyContractId,\n//   });\n//   if (\n//     newState.hasOwnProperty(\"privateKey\") &&\n//     newState.privateKey !== oldState.privateKey\n//   ) {\n//     _state.publicKey = newState.privateKey\n//       ? cryptoUtils.publicKeyFromPrivate(newState.privateKey)\n//       : null;\n//     lsSet(\"nonce\", null);\n//   }\n//   if (newState.accountId !== oldState.accountId) {\n//     notifyAccountListeners(newState.accountId);\n//   }\n//   if (\n//     (newState.hasOwnProperty(\"lastWalletId\") &&\n//       newState.lastWalletId !== oldState.lastWalletId) ||\n//     (newState.hasOwnProperty(\"accountId\") &&\n//       newState.accountId !== oldState.accountId) ||\n//     (newState.hasOwnProperty(\"privateKey\") &&\n//       newState.privateKey !== oldState.privateKey)\n//   ) {\n//     _adapter.setState(getWalletAdapterState());\n//   }\n// }\n//\n// function updateTxHistory(txStatus) {\n//   const txId = txStatus.txId;\n//   _txHistory[txId] = {\n//     ...(_txHistory[txId] ?? {}),\n//     ...txStatus,\n//     updateTimestamp: Date.now(),\n//   };\n//   lsSet(\"txHistory\", _txHistory);\n//   notifyTxListeners(_txHistory[txId]);\n// }\n//\n// function onAdapterStateUpdate(state) {\n//   console.log(\"Adapter state update:\", state);\n//   const { accountId, lastWalletId, privateKey } = state;\n//   updateState({\n//     accountId,\n//     lastWalletId,\n//     ...(privateKey && { privateKey }),\n//   });\n// }\n//\n// // Create adapter instance\n// _adapter = new WalletAdapter({\n//   onStateUpdate: onAdapterStateUpdate,\n//   lastState: getWalletAdapterState(),\n//   widgetUrl: WIDGET_URL,\n// });\n//\n// // Utils\n// export function parseJsonFromBytes(bytes: Uint8Array) {\n//   try {\n//     const decoder = new TextDecoder();\n//     return JSON.parse(decoder.decode(bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes)));\n//   } catch (e) {\n//     try {\n//       return bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);\n//     } catch (e) {\n//       return bytes;\n//     }\n//   }\n// }\n//\n// function withBlockId(params, blockId) {\n//   return blockId === \"final\" || blockId === \"optimistic\"\n//     ? { ...params, finality: blockId }\n//     : !!blockId\n//       ? { ...params, block_id: blockId }\n//       : { ...params, finality: \"optimistic\" };\n// }\n//\n// async function queryRpc(method, params) {\n//   const response = await fetch(_config.nodeUrl, {\n//     method: \"POST\",\n//     headers: { \"Content-Type\": \"application/json\" },\n//     body: JSON.stringify({\n//       jsonrpc: \"2.0\",\n//       id: `fastnear-${Date.now()}`,\n//       method,\n//       params,\n//     }),\n//   });\n//\n//   const result = await response.json();\n//   if (result.error) {\n//     throw new Error(JSON.stringify(result.error));\n//   }\n//   return result.result;\n// }\n//\n// function afterTxSent(txId) {\n//   queryRpc(\"tx\", {\n//     tx_hash: _txHistory[txId].txHash,\n//     sender_account_id: _txHistory[txId].tx.signerId,\n//     wait_until: \"EXECUTED_OPTIMISTIC\",\n//   })\n//     .then((result) => {\n//       const successValue = result?.status?.SuccessValue;\n//       updateTxHistory({\n//         txId,\n//         status: \"Executed\",\n//         result,\n//         successValue: successValue\n//           ? tryParseJson(fromBase64(successValue))\n//           : undefined,\n//         finalState: true,\n//       });\n//     })\n//     .catch((error) => {\n//       updateTxHistory({\n//         txId,\n//         status: \"ErrorAfterIncluded\",\n//         error: tryParseJson(error.message),\n//         finalState: true,\n//       });\n//     });\n// }\n//\n// function sendTxToRpc(signedTxBase64, waitUntil, txId) {\n//   queryRpc(\"send_tx\", {\n//     signed_tx_base64: signedTxBase64,\n//     wait_until: waitUntil ?? \"INCLUDED\",\n//   })\n//     .then((result) => {\n//       console.log(\"Transaction included:\", result);\n//       updateTxHistory({\n//         txId,\n//         status: \"Included\",\n//         finalState: false,\n//       });\n//       afterTxSent(txId);\n//     })\n//     .catch((error) => {\n//       // TODO: Catch nonce errors and update nonce\n//       // TODO: Handle timeouts (non-final status)\n//       // TODO: Handle shard congestions\n//       updateTxHistory({\n//         txId,\n//         status: \"Error\",\n//         error: tryParseJson(error.message),\n//         finalState: false,\n//       });\n//     });\n// }\n//\n// // Event Notifiers\n// function notifyAccountListeners(accountId) {\n//   if (_eventListeners.account.size === 0) {\n//     _unbroadcastedEvents.account.push(accountId);\n//     return;\n//   }\n//   _eventListeners.account.forEach((callback) => {\n//     try {\n//       callback(accountId);\n//     } catch (e) {\n//       console.error(e);\n//     }\n//   });\n// }\n//\n// function notifyTxListeners(tx) {\n//   if (_eventListeners.tx.size === 0) {\n//     _unbroadcastedEvents.tx.push(tx);\n//     return;\n//   }\n//   _eventListeners.tx.forEach((callback) => {\n//     try {\n//       callback(tx);\n//     } catch (e) {\n//       console.error(e);\n//     }\n//   });\n// }\n//\n// function convertUnit(s, ...args) {\n//   // Reconstruct raw string from template literal\n//   if (Array.isArray(s)) {\n//     s = s.reduce((acc, part, i) => {\n//       return acc + (args[i - 1] ?? \"\") + part;\n//     });\n//   }\n//   // Convert from `100 NEAR` into yoctoNear\n//   if (typeof s == \"string\") {\n//     let match = s.match(/([0-9.,_]+)\\s*([a-zA-Z]+)?/);\n//     if (match) {\n//       let amount = match[1].replace(/[_,]/g, \"\");\n//       let unitPart = match[2];\n//       if (unitPart) {\n//         switch (unitPart.toLowerCase()) {\n//           case \"near\":\n//             return Big(amount).mul(Big(10).pow(24)).toFixed(0);\n//           case \"tgas\":\n//             return Big(amount).mul(Big(10).pow(12)).toFixed(0);\n//           case \"ggas\":\n//             return Big(amount).mul(Big(10).pow(9)).toFixed(0);\n//           case \"gas\" || \"yoctonear\":\n//             return Big(amount).toFixed(0);\n//           default:\n//             throw new Error(`Unknown unit: ${unit}`);\n//         }\n//       } else {\n//         return Big(amount).toFixed(0);\n//       }\n//     }\n//   }\n//   return Big(s).toFixed(0);\n// }\n//\n// // Core API Implementation\n// const api = {\n//   // Context\n//   get accountId() {\n//     return _state.accountId;\n//   },\n//\n//   get publicKey() {\n//     return _state.publicKey;\n//   },\n//\n//   config(newConfig) {\n//     if (newConfig) {\n//       if (newConfig.networkId && _config.networkId !== newConfig.networkId) {\n//         _config = { ...NETWORKS[newConfig.networkId] };\n//         updateState({\n//           accountId: null,\n//           privateKey: null,\n//           lastWalletId: null,\n//         });\n//         lsSet(\"block\", null);\n//         _txHistory = {};\n//         lsSet(\"txHistory\", _txHistory);\n//       }\n//\n//       _config = { ..._config, ...newConfig };\n//       lsSet(\"config\", _config);\n//     }\n//     return _config;\n//   },\n//\n//   get authStatus() {\n//     if (!_state.accountId) {\n//       return \"SignedOut\";\n//     }\n//\n//     // Check for limited access key\n//     const accessKey = _state.publicKey;\n//     const contractId = _state.accessKeyContractId;\n//     if (accessKey && contractId && _state.privateKey) {\n//       return {\n//         type: \"SignedInWithLimitedAccessKey\",\n//         accessKey,\n//         contractId,\n//       };\n//     }\n//     return \"SignedIn\";\n//   },\n//\n//   // Query Methods\n//   async view({ contractId, methodName, args, argsBase64, blockId }) {\n//     const encodedArgs =\n//       argsBase64 || (args ? toBase64(JSON.stringify(args)) : \"\");\n//\n//     const result = await queryRpc(\n//       \"query\",\n//       withBlockId(\n//         {\n//           request_type: \"call_function\",\n//           account_id: contractId,\n//           method_name: methodName,\n//           args_base64: encodedArgs,\n//         },\n//         blockId,\n//       ),\n//     );\n//\n//     return parseJsonFromBytes(result.result);\n//   },\n//\n//   async account({ accountId, blockId }) {\n//     return queryRpc(\n//       \"query\",\n//       withBlockId(\n//         {\n//           request_type: \"view_account\",\n//           account_id: accountId,\n//         },\n//         blockId,\n//       ),\n//     );\n//   },\n//\n//   async block({ blockId }) {\n//     return queryRpc(\"block\", withBlockId({}, blockId));\n//   },\n//\n//   async accessKey({ accountId, publicKey, blockId }) {\n//     return queryRpc(\n//       \"query\",\n//       withBlockId(\n//         {\n//           request_type: \"view_access_key\",\n//           account_id: accountId,\n//           public_key: publicKey,\n//         },\n//         blockId,\n//       ),\n//     );\n//   },\n//\n//   async tx({ txHash, accountId }) {\n//     return queryRpc(\"tx\", [txHash, accountId]);\n//   },\n//\n//   localTxHistory() {\n//     return [..._txHistory];\n//   },\n//\n//   // Transaction Methods\n//   async sendTx({ receiverId, actions, waitUntil }) {\n//     const signerId = _state.accountId;\n//     if (!signerId) {\n//       throw new Error(\"Not signed in\");\n//     }\n//\n//     const publicKey = _state.publicKey;\n//     const privateKey = _state.privateKey;\n//     const txId = `tx-${Date.now()}-${Math.random()}`;\n//\n//     if (\n//       !privateKey ||\n//       receiverId !== _state.accessKeyContractId ||\n//       !canSignWithLAK(actions)\n//     ) {\n//       const jsonTransaction = {\n//         signerId,\n//         receiverId,\n//         actions,\n//       };\n//\n//       updateTxHistory({\n//         status: \"Pending\",\n//         txId,\n//         tx: jsonTransaction,\n//         finalState: false,\n//       });\n//\n//       const url = new URL(window.location.href);\n//       url.searchParams.set(\"txIds\", txId);\n//\n//       _adapter\n//         .sendTransactions({\n//           transactions: [jsonTransaction],\n//           callbackUrl: url.toString(),\n//         })\n//         .then((result) => {\n//           console.log(\"Transaction result:\", result);\n//           if (result.url) {\n//             console.log(\"Redirecting to wallet:\", result.url);\n//             setTimeout(() => {\n//               window.location.href = result.url;\n//             }, 100);\n//           } else if (result.outcomes) {\n//             result.outcomes.forEach((result) => {\n//               updateTxHistory({\n//                 txId,\n//                 status: \"Executed\",\n//                 result,\n//                 txHash: result.transaction.hash,\n//                 finalState: true,\n//               });\n//             });\n//           } else if (result.rejected) {\n//             updateTxHistory({\n//               txId,\n//               status: \"RejectedByUser\",\n//               finalState: true,\n//             });\n//           } else if (result.error) {\n//             updateTxHistory({\n//               txId,\n//               status: \"Error\",\n//               error: tryParseJson(result.error),\n//               finalState: true,\n//             });\n//           }\n//         })\n//         .catch((error) => {\n//           updateTxHistory({\n//             txId,\n//             status: \"Error\",\n//             error: tryParseJson(error.message),\n//             finalState: true,\n//           });\n//         });\n//       return txId;\n//     }\n//\n//     const toDoPromises = {};\n//     let nonce = lsGet(\"nonce\");\n//     if (nonce === null || nonce === undefined) {\n//       toDoPromises.nonce = this.accessKey({\n//         accountId: signerId,\n//         publicKey,\n//       }).then((accessKey) => {\n//         if (accessKey.error) {\n//           throw new Error(`Access key error: ${accessKey.error}`);\n//         }\n//         lsSet(\"nonce\", accessKey.nonce);\n//         return accessKey.nonce;\n//       });\n//     }\n//     let block = lsGet(\"block\");\n//     if (\n//       !block ||\n//       parseFloat(block.header.timestamp_nanosec) / 1e6 + MaxBlockDelayMs <\n//         Date.now()\n//     ) {\n//       toDoPromises.block = this.block({ blockId: \"final\" }).then((block) => {\n//         block = {\n//           header: {\n//             prev_hash: block.header.prev_hash,\n//             timestamp_nanosec: block.header.timestamp_nanosec,\n//           },\n//         };\n//         lsSet(\"block\", block);\n//         return block;\n//       });\n//     }\n//\n//     if (Object.keys(toDoPromises).length > 0) {\n//       let results = await Promise.all(Object.values(toDoPromises));\n//       for (let i = 0; i < results.length; i++) {\n//         if (Object.keys(toDoPromises)[i] === \"nonce\") {\n//           nonce = results[i];\n//         } else if (Object.keys(toDoPromises)[i] === \"block\") {\n//           block = results[i];\n//         }\n//       }\n//     }\n//\n//     const newNonce = nonce + 1;\n//     lsSet(\"nonce\", newNonce);\n//     const blockHash = block.header.prev_hash;\n//\n//     const jsonTransaction = {\n//       signerId,\n//       publicKey,\n//       nonce: newNonce,\n//       receiverId,\n//       blockHash,\n//       actions,\n//     };\n//\n//     console.log(\"Transaction:\", jsonTransaction);\n//     const transaction = serializeTransaction(jsonTransaction);\n//     const txHash = toBase58(cryptoUtils.sha256(transaction));\n//     const signature = cryptoUtils.signHash(txHash, privateKey);\n//     const singedTransaction = serializeSignedTransaction(\n//       jsonTransaction,\n//       signature,\n//     );\n//     const signedTxBase64 = toBase64(singedTransaction);\n//\n//     updateTxHistory({\n//       status: \"Pending\",\n//       txId,\n//       tx: jsonTransaction,\n//       signature,\n//       signedTxBase64,\n//       txHash,\n//       finalState: false,\n//     });\n//\n//     sendTxToRpc(signedTxBase64, waitUntil, txId);\n//\n//     return txId;\n//   },\n//\n//   // Authentication Methods\n//   async requestSignIn({ contractId }) {\n//     const privateKey = cryptoUtils.privateKeyFromRandom();\n//     updateState({\n//       accessKeyContractId: contractId,\n//       accountId: null,\n//       privateKey,\n//     });\n//     const publicKey = cryptoUtils.publicKeyFromPrivate(privateKey);\n//     const result = await _adapter.signIn({\n//       networkId: _config.networkId,\n//       contractId,\n//       publicKey,\n//     });\n//     console.log(\"Sign in result:\", result);\n//     if (result.error) {\n//       throw new Error(`Wallet error: ${result.error}`);\n//     }\n//     if (result.url) {\n//       console.log(\"Redirecting to wallet:\", result.url);\n//       setTimeout(() => {\n//         window.location.href = result.url;\n//       }, 100);\n//     } else if (result.accountId) {\n//       updateState({\n//         accountId: result.accountId,\n//       });\n//     }\n//   },\n//\n//   signOut() {\n//     updateState({\n//       accountId: null,\n//       privateKey: null,\n//       contractId: null,\n//     });\n//\n//     // TODO: Implement actual wallet integration\n//   },\n//\n//   // Event Handlers\n//   onAccount(callback) {\n//     _eventListeners.account.add(callback);\n//     if (_unbroadcastedEvents.account.length > 0) {\n//       const events = _unbroadcastedEvents.account;\n//       _unbroadcastedEvents.account = [];\n//       events.forEach(notifyAccountListeners);\n//     }\n//   },\n//\n//   onTx(callback) {\n//     _eventListeners.tx.add(callback);\n//     if (_unbroadcastedEvents.tx.length > 0) {\n//       const events = _unbroadcastedEvents.tx;\n//       _unbroadcastedEvents.tx = [];\n//       events.forEach(notifyTxListeners);\n//     }\n//   },\n//\n//   // Action Helpers\n//   actions: {\n//     functionCall: ({ methodName, gas, deposit, args, argsBase64 }) => ({\n//       type: \"FunctionCall\",\n//       methodName,\n//       args,\n//       argsBase64,\n//       gas,\n//       deposit,\n//     }),\n//\n//     transfer: (yoctoAmount) => ({\n//       type: \"Transfer\",\n//       deposit: yoctoAmount,\n//     }),\n//\n//     stakeNEAR: ({ amount, publicKey }) => ({\n//       type: \"Stake\",\n//       stake: amount,\n//       publicKey,\n//     }),\n//\n//     addFullAccessKey: ({ publicKey }) => ({\n//       type: \"AddKey\",\n//       publicKey: publicKey,\n//       accessKey: { permission: \"FullAccess\" },\n//     }),\n//\n//     addLimitedAccessKey: ({\n//       publicKey,\n//       allowance,\n//       accountId,\n//       methodNames,\n//     }) => ({\n//       type: \"AddKey\",\n//       publicKey: publicKey,\n//       accessKey: {\n//         permission: \"FunctionCall\",\n//         allowance,\n//         receiverId: accountId,\n//         methodNames,\n//       },\n//     }),\n//\n//     deleteKey: ({ publicKey }) => ({\n//       type: \"DeleteKey\",\n//       publicKey,\n//     }),\n//\n//     deleteAccount: ({ beneficiaryId }) => ({\n//       type: \"DeleteAccount\",\n//       beneficiaryId,\n//     }),\n//\n//     createAccount: () => ({\n//       type: \"CreateAccount\",\n//     }),\n//\n//     deployContract: ({ codeBase64 }) => ({\n//       type: \"DeployContract\",\n//       codeBase64,\n//     }),\n//   },\n//\n//   utils: {\n//     toBase64,\n//     fromBase64,\n//     toBase58,\n//     fromBase58,\n//   },\n// };\n//\n// // _adapter.handleWalletRedirect();\n//\n// // Handle wallet redirect if applicable\n// // TODO: Implement actual wallet integration\n// try {\n//   const url = new URL(window.location.href);\n//   const accountId = url.searchParams.get(\"account_id\");\n//   const publicKey = url.searchParams.get(\"public_key\");\n//   const errorCode = url.searchParams.get(\"errorCode\");\n//   const errorMessage = url.searchParams.get(\"errorMessage\");\n//   const transactionHashes = url.searchParams.get(\"transactionHashes\");\n//   const txIds = url.searchParams.get(\"txIds\");\n//\n//   if (errorCode || errorMessage) {\n//     console.warn(new Error(`Wallet error: ${errorCode} ${errorMessage}`));\n//   }\n//\n//   if (accountId && publicKey) {\n//     if (publicKey === _state.publicKey) {\n//       updateState({\n//         accountId,\n//       });\n//     } else {\n//       console.error(\n//         new Error(\"Public key mismatch from wallet redirect\"),\n//         publicKey,\n//         _state.publicKey,\n//       );\n//     }\n//   }\n//\n//   if (transactionHashes || txIds) {\n//     const txHashes = transactionHashes ? transactionHashes.split(\",\") : [];\n//     const txIdsArray = txIds ? txIds.split(\",\") : [];\n//     if (txIdsArray.length > txHashes.length) {\n//       txIdsArray.forEach((txId, i) => {\n//         updateTxHistory({\n//           txId,\n//           status: \"RejectedByUser\",\n//           finalState: true,\n//         });\n//       });\n//     } else if (txIdsArray.length === txHashes.length) {\n//       txIdsArray.forEach((txId, i) => {\n//         updateTxHistory({\n//           txId,\n//           status: \"PendingGotTxHash\",\n//           txHash: txHashes[i],\n//           finalState: false,\n//         });\n//         afterTxSent(txId);\n//       });\n//     } else {\n//       console.error(\n//         new Error(\"Transaction hash mismatch from wallet redirect\"),\n//         txIdsArray,\n//         txHashes,\n//       );\n//     }\n//   }\n//\n//   // Remove wallet parameters from the URL\n//   url.searchParams.delete(\"account_id\");\n//   url.searchParams.delete(\"public_key\");\n//   url.searchParams.delete(\"errorCode\");\n//   url.searchParams.delete(\"errorMessage\");\n//   url.searchParams.delete(\"all_keys\");\n//   url.searchParams.delete(\"transactionHashes\");\n//   url.searchParams.delete(\"txIds\");\n//   window.history.replaceState({}, \"\", url.toString());\n// } catch (e) {\n//   console.error(\"Error handling wallet redirect:\", e);\n// }\n//\n// export { api, convertUnit };\n", "/**\n * @typedef {Object} WalletState\n * @property {string} [accountId] - NEAR account ID if signed in\n * @property {string} [publicKey] - Public key if available\n * @property {string} [privateKey] - Private key if available\n * @property {string} [lastWalletId] - ID of last used wallet\n * @property {string} [networkId] - ID of last used network\n */\n\n/**\n * @typedef {Object} SignInConfig\n * @property {string} networkId - NEAR network ID ('mainnet' or 'testnet')\n * @property {string} contractId - Contract ID to request access for\n * @property {string} [walletId] - Preferred wallet to use. E.g. 'near', 'here', 'meteor'\n * @property {string} [callbackUrl] - URL to redirect back to after wallet interaction\n */\n\n/**\n * @typedef {Object} SignInResult\n * @property {string} [url] - URL to redirect to if needed\n * @property {string} [accountId] - Account ID if immediately available\n * @property {string} [error] - Error message if sign in failed\n */\n\n/**\n * @typedef {Object} Transaction\n * @property {string} [signerId] - Transaction signer account ID\n * @property {string} receiverId - Transaction receiver account ID\n * @property {Object[]} actions - Transaction actions to perform\n */\n\n/**\n * @typedef {Object} TransactionConfig\n * @property {Transaction} transactions - Transaction actions to perform\n * @property {string} [callbackUrl] - URL to redirect back to after wallet interaction\n */\n\n/**\n * @typedef {Object} TransactionResult\n * @property {string} [url] - URL to redirect to if needed\n * @property {string} [hash] - Transaction hash if immediately available\n * @property {string} [error] - Error message if transaction failed\n */\n\nexport interface WalletAdapterConstructor {\n  widgetUrl?: string;\n  targetOrigin?: string;\n  onStateUpdate?: (state: any) => void;\n  lastState?: any;\n  callbackUrl?: string;\n}\n\n/**\n * @typedef {Object} WalletAdapterConfig\n * @property {string} [widgetUrl] - URL of the wallet widget (defaults to official hosted version)\n * @property {string} [targetOrigin] - Target origin for postMessage (defaults to '*')\n * @property {string} [lastState] - The last state that was given by WalletAdapter before the redirect or reload.\n * @property {(state: WalletState) => void} [onStateUpdate] - Called when wallet state changes\n * @property {string} [callbackUrl] - Default callback URL for wallet interactions (defaults to current page URL)\n */\n\n/**\n * Interface for interacting with NEAR wallets\n */\nexport class WalletAdapter {\n  /** @type {HTMLIFrameElement} */\n  #iframe = null;\n\n  /** @type {string} */\n  #targetOrigin;\n\n  /** @type {string} */\n  #widgetUrl;\n\n  /** @type {Map<string, Function>} */\n  #pending = new Map();\n\n  /** @type {WalletState} */\n  #state;\n\n  /** @type {Function} */\n  #onStateUpdate;\n\n  /** @type {string} */\n  #callbackUrl;\n\n  /** @type {string} */\n  static defaultWidgetUrl = \"https://wallet-adapter.fastnear.com\";\n\n\n\n/**\n   * @param {WalletAdapterConfig} [config]\n   */\n  constructor({\n    widgetUrl = WalletAdapter.defaultWidgetUrl,\n    targetOrigin = \"*\",\n    onStateUpdate,\n    lastState,\n    callbackUrl = window.location.href,\n  }: WalletAdapterConstructor = {}) {\n    this.#targetOrigin = targetOrigin;\n    this.#widgetUrl = widgetUrl;\n    this.#onStateUpdate = onStateUpdate;\n    this.#callbackUrl = callbackUrl;\n    this.#state = lastState || {};\n    window.addEventListener(\"message\", this.#handleMessage.bind(this));\n  }\n\n  /**\n   * Creates an iframe for wallet interaction\n   * @param {string} path - Path to load in iframe\n   * @returns {HTMLIFrameElement}\n   */\n  #createIframe(path) {\n    // Remove existing iframe if any\n    if (this.#iframe) {\n      this.#iframe.remove();\n    }\n\n    // Create URL\n    const url = new URL(path, this.#widgetUrl);\n\n    // Create and configure iframe\n    const iframe = document.createElement(\"iframe\");\n    iframe.src = url.toString();\n    iframe.allow = \"usb\";\n    iframe.style.border = \"none\";\n    iframe.style.zIndex = \"10000\";\n    iframe.style.position = \"fixed\";\n    iframe.style.display = \"block\";\n    iframe.style.top = \"0\";\n    iframe.style.left = \"0\";\n    iframe.style.width = \"100%\";\n    iframe.style.height = \"100%\";\n    document.body.appendChild(iframe);\n\n    this.#iframe = iframe;\n    return iframe;\n  }\n\n  /**\n   * Handles messages from the wallet widget\n   * @param {MessageEvent} event\n   */\n  #handleMessage(event) {\n    // Check origin if specified\n    if (this.#targetOrigin !== \"*\" && event.origin !== this.#targetOrigin) {\n      return;\n    }\n\n    const { id, type, action, payload } = event.data;\n    if (type !== \"wallet-adapter\") return;\n\n    // Handle close action\n    if (action === \"close\") {\n      this.#iframe?.remove();\n      this.#iframe = null;\n      return;\n    }\n\n    // Update state if provided\n    if (payload?.state) {\n      this.#state = { ...this.#state, ...payload.state };\n      this.#onStateUpdate?.(this.#state);\n    }\n\n    // Resolve pending promise if any\n    const resolve = this.#pending.get(id);\n    if (resolve) {\n      this.#pending.delete(id);\n      this.#iframe?.remove();\n      this.#iframe = null;\n      resolve(payload);\n    }\n  }\n\n  /**\n   * Sends a message to the wallet widget\n   * @param {string} path - Path to load in iframe\n   * @param {string} method - Method to call\n   * @param {Object} params - Parameters to pass\n   * @returns {Promise<any>}\n   */\n  async #sendMessage(path, method, params) {\n    return new Promise((resolve) => {\n      const id = Math.random().toString(36).slice(2);\n      this.#pending.set(id, resolve);\n\n      const iframe = this.#createIframe(path);\n\n      iframe.onload = () => {\n        iframe.contentWindow?.postMessage(\n          {\n            type: \"wallet-adapter\",\n            method,\n            params: {\n              id,\n              ...params,\n              state: this.#state,\n              callbackUrl: params.callbackUrl || this.#callbackUrl,\n            },\n          },\n          this.#targetOrigin\n        );\n      };\n    });\n  }\n\n  /**\n   * Get current wallet state\n   * @returns {WalletState}\n   */\n  getState() {\n    return { ...this.#state };\n  }\n\n  /**\n   * Set current wallet state\n   * @param state\n   */\n  setState(state) {\n    this.#state = state;\n  }\n\n  /**\n   * Sign in with a NEAR wallet\n   * @param {SignInConfig} config\n   * @returns {Promise<SignInResult>}\n   */\n  async signIn(config) {\n    return this.#sendMessage(\"/login.html\", \"signIn\", config);\n  }\n\n  /**\n   * Send a transaction using connected wallet\n   * @param {TransactionConfig} config\n   * @returns {Promise<TransactionResult>}\n   */\n  async sendTransactions(config) {\n    return this.#sendMessage(\"/send.html\", \"sendTransactions\", config);\n  }\n\n  /**\n   * Clean up adapter resources\n   */\n  destroy() {\n    window.removeEventListener(\"message\", this.#handleMessage);\n    this.#iframe?.remove();\n    this.#iframe = null;\n  }\n}\n", "import { ed25519 } from \"@noble/curves/ed25519\";\nimport { sha256 } from \"@noble/hashes/sha2\";\nimport { fromBase58, toBase58 } from \"./utils.js\";\n\nexport { sha256 };\n\nexport const keyFromString = (key) =>\n  fromBase58(\n    key.includes(\":\")\n      ? (() => {\n          const [curve, keyPart] = key.split(\":\");\n          if (curve !== \"ed25519\") {\n            throw new Error(`Unsupported curve: ${curve}`);\n          }\n          return keyPart;\n        })()\n      : key,\n  );\n\nexport const keyToString = (key) => `ed25519:${toBase58(key)}`;\n\nexport function publicKeyFromPrivate(privateKey) {\n  privateKey = keyFromString(privateKey).slice(0, 32);\n  const publicKey = ed25519.getPublicKey(privateKey);\n  return keyToString(publicKey);\n}\n\nexport function privateKeyFromRandom() {\n  const privateKey = crypto.getRandomValues(new Uint8Array(64));\n  return keyToString(privateKey);\n}\n\nexport function signHash(hash, privateKey) {\n  privateKey = keyFromString(privateKey).slice(0, 32);\n  const signature = ed25519.sign(fromBase58(hash), privateKey);\n  return toBase58(signature);\n}\n\nexport function signBytes(bytes, privateKey) {\n  const hash = sha256(bytes);\n  return signHash(toBase58(hash), privateKey);\n}\n", "import {\n  binary_to_base58 as toBase58,\n  base58_to_binary as fromBase58,\n} from \"base58-js\";\nimport Big from \"big.js\";\nimport { encode, decode } from 'js-base64';\n\nexport { toBase58, fromBase58 };\n\nconst LsPrefix = \"__fastnear_\";\n\nexport function toBase64(data) {\n  if (typeof data === 'string') {\n    return encode(data);\n  } else {\n    const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);\n    const str = String.fromCharCode(...bytes);\n    return encode(str);\n  }\n}\n\nexport function fromBase64(str) {\n  const binaryString = decode(str);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}\n\nexport function lsSet(key, value) {\n  if (value === null || value === undefined) {\n    localStorage.removeItem(LsPrefix + key);\n  } else {\n    localStorage.setItem(LsPrefix + key, JSON.stringify(value));\n  }\n}\n\nexport function lsGet(key) {\n  const value = localStorage.getItem(LsPrefix + key);\n  return tryParseJson(value, null);\n}\n\nexport function deepCopy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function tryParseJson(...args) {\n  try {\n    return JSON.parse(args[0]);\n  } catch {\n    if (args.length > 1) {\n      return args[1];\n    }\n    return args[0];\n  }\n}\n\nexport function canSignWithLAK(actions) {\n  return (\n    actions.length === 1 &&\n    actions[0].type === \"FunctionCall\" &&\n    Big(actions[0]?.deposit ?? \"0\").eq(0)\n  );\n}\n", "import { serialize as borshSerialize } from \"borsh\";\nimport { keyFromString } from \"./cryptoUtils.js\";\nimport { fromBase58, fromBase64 } from \"./utils.js\";\n\nfunction mapTransaction(jsonTransaction) {\n  return {\n    signerId: jsonTransaction.signerId,\n    publicKey: {\n      ed25519Key: {\n        data: keyFromString(jsonTransaction.publicKey),\n      },\n    },\n    nonce: BigInt(jsonTransaction.nonce),\n    receiverId: jsonTransaction.receiverId,\n    blockHash: fromBase58(jsonTransaction.blockHash),\n    actions: jsonTransaction.actions.map(mapAction),\n  };\n}\n\nexport function serializeTransaction(jsonTransaction) {\n  const transaction = mapTransaction(jsonTransaction);\n  return borshSerialize(SCHEMA.Transaction, transaction);\n}\n\nexport function serializeSignedTransaction(jsonTransaction, signature) {\n  const signedTransaction = {\n    transaction: mapTransaction(jsonTransaction),\n    signature: {\n      ed25519Signature: {\n        data: fromBase58(signature),\n      },\n    },\n  };\n  return borshSerialize(SCHEMA.SignedTransaction, signedTransaction);\n}\n\nexport function mapAction(action) {\n  switch (action.type) {\n    case \"CreateAccount\": {\n      return {\n        createAccount: {},\n      };\n    }\n    case \"DeployContract\": {\n      return {\n        deployContract: {\n          code: fromBase64(action.codeBase64),\n        },\n      };\n    }\n    case \"FunctionCall\": {\n      return {\n        functionCall: {\n          methodName: action.methodName,\n          args: action.argsBase64\n            ? fromBase64(action.argsBase64)\n            : new TextEncoder().encode(JSON.stringify(action.args)),\n          gas: BigInt(action.gas),\n          deposit: BigInt(action.deposit),\n        },\n      };\n    }\n    case \"Transfer\": {\n      return {\n        transfer: {\n          deposit: BigInt(action.deposit),\n        },\n      };\n    }\n    case \"Stake\": {\n      return {\n        stake: {\n          stake: BigInt(action.stake),\n          publicKey: {\n            ed25519Key: {\n              data: keyFromString(action.publicKey),\n            },\n          },\n        },\n      };\n    }\n    case \"AddKey\": {\n      return {\n        addKey: {\n          publicKey: {\n            ed25519Key: {\n              data: keyFromString(action.publicKey),\n            },\n          },\n          accessKey: {\n            nonce: BigInt(action.accessKey.nonce),\n            permission:\n              action.accessKey.permission === \"FullAccess\"\n                ? { fullAccess: {} }\n                : {\n                    functionCall: {\n                      allowance: action.accessKey.allowance\n                        ? BigInt(action.accessKey.allowance)\n                        : null,\n                      receiverId: action.accessKey.receiverId,\n                      methodNames: action.accessKey.methodNames,\n                    },\n                  },\n          },\n        },\n      };\n    }\n    case \"DeleteKey\": {\n      return {\n        deleteKey: {\n          publicKey: {\n            ed25519Key: {\n              data: keyFromString(action.publicKey),\n            },\n          },\n        },\n      };\n    }\n    case \"DeleteAccount\": {\n      return {\n        deleteAccount: {\n          beneficiaryId: action.beneficiaryId,\n        },\n      };\n    }\n    case \"SignedDelegate\": {\n      return {\n        signedDelegate: {\n          delegateAction: mapAction(action.delegateAction),\n          signature: {\n            ed25519Signature: fromBase58(action.signature),\n          },\n        },\n      };\n    }\n    default: {\n      throw new Error(\"Not implemented action: \" + action.type);\n    }\n  }\n}\n\n// LEFTOFF: use the borsh-schema package\nexport const SCHEMA = new (class BorshSchema {\n  Ed25519Signature = {\n    struct: {\n      data: { array: { type: \"u8\", len: 64 } },\n    },\n  };\n  Secp256k1Signature = {\n    struct: {\n      data: { array: { type: \"u8\", len: 65 } },\n    },\n  };\n  Signature = {\n    enum: [\n      { struct: { ed25519Signature: this.Ed25519Signature } },\n      { struct: { secp256k1Signature: this.Secp256k1Signature } },\n    ],\n  };\n  Ed25519Data = {\n    struct: {\n      data: { array: { type: \"u8\", len: 32 } },\n    },\n  };\n  Secp256k1Data = {\n    struct: {\n      data: { array: { type: \"u8\", len: 64 } },\n    },\n  };\n  PublicKey = {\n    enum: [\n      { struct: { ed25519Key: this.Ed25519Data } },\n      { struct: { secp256k1Key: this.Secp256k1Data } },\n    ],\n  };\n  FunctionCallPermission = {\n    struct: {\n      allowance: { option: \"u128\" },\n      receiverId: \"string\",\n      methodNames: { array: { type: \"string\" } },\n    },\n  };\n  FullAccessPermission = {\n    struct: {},\n  };\n  AccessKeyPermission = {\n    enum: [\n      { struct: { functionCall: this.FunctionCallPermission } },\n      { struct: { fullAccess: this.FullAccessPermission } },\n    ],\n  };\n  AccessKey = {\n    struct: {\n      nonce: \"u64\",\n      permission: this.AccessKeyPermission,\n    },\n  };\n  CreateAccount = {\n    struct: {},\n  };\n  DeployContract = {\n    struct: {\n      code: { array: { type: \"u8\" } },\n    },\n  };\n  FunctionCall = {\n    struct: {\n      methodName: \"string\",\n      args: { array: { type: \"u8\" } },\n      gas: \"u64\",\n      deposit: \"u128\",\n    },\n  };\n  Transfer = {\n    struct: {\n      deposit: \"u128\",\n    },\n  };\n  Stake = {\n    struct: {\n      stake: \"u128\",\n      publicKey: this.PublicKey,\n    },\n  };\n  AddKey = {\n    struct: {\n      publicKey: this.PublicKey,\n      accessKey: this.AccessKey,\n    },\n  };\n  DeleteKey = {\n    struct: {\n      publicKey: this.PublicKey,\n    },\n  };\n  DeleteAccount = {\n    struct: {\n      beneficiaryId: \"string\",\n    },\n  };\n  ClassicAction = {\n    enum: [\n      { struct: { createAccount: this.CreateAccount } },\n      { struct: { deployContract: this.DeployContract } },\n      { struct: { functionCall: this.FunctionCall } },\n      { struct: { transfer: this.Transfer } },\n      { struct: { stake: this.Stake } },\n      { struct: { addKey: this.AddKey } },\n      { struct: { deleteKey: this.DeleteKey } },\n      { struct: { deleteAccount: this.DeleteAccount } },\n    ],\n  };\n  DelegateAction = {\n    struct: {\n      senderId: \"string\",\n      receiverId: \"string\",\n      actions: { array: { type: this.ClassicAction } },\n      nonce: \"u64\",\n      maxBlockHeight: \"u64\",\n      publicKey: this.PublicKey,\n    },\n  };\n  SignedDelegate = {\n    struct: {\n      delegateAction: this.DelegateAction,\n      signature: this.Signature,\n    },\n  };\n  Action = {\n    enum: [\n      { struct: { createAccount: this.CreateAccount } },\n      { struct: { deployContract: this.DeployContract } },\n      { struct: { functionCall: this.FunctionCall } },\n      { struct: { transfer: this.Transfer } },\n      { struct: { stake: this.Stake } },\n      { struct: { addKey: this.AddKey } },\n      { struct: { deleteKey: this.DeleteKey } },\n      { struct: { deleteAccount: this.DeleteAccount } },\n      { struct: { signedDelegate: this.SignedDelegate } },\n    ],\n  };\n  Transaction = {\n    struct: {\n      signerId: \"string\",\n      publicKey: this.PublicKey,\n      nonce: \"u64\",\n      receiverId: \"string\",\n      blockHash: { array: { type: \"u8\", len: 32 } },\n      actions: { array: { type: this.Action } },\n    },\n  };\n  SignedTransaction = {\n    struct: {\n      transaction: this.Transaction,\n      signature: this.Signature,\n    },\n  };\n})();\n"],
  "mappings": "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",
  "names": ["import_big", "Big", "fromBase58", "toBase58", "fromBase58", "borshSerialize", "Big", "e", "jsonTransaction", "toBase58", "fromBase58"]
}
