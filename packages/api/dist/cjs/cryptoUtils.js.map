{
  "version": 3,
  "sources": ["../../src/cryptoUtils.ts", "../../src/utils.ts"],
  "sourcesContent": ["import { ed25519 } from \"@noble/curves/ed25519\";\nimport { sha256 } from \"@noble/hashes/sha2\";\nimport { fromBase58, toBase58 } from \"./utils.js\";\n\nexport { sha256 };\n\nexport const keyFromString = (key) =>\n  fromBase58(\n    key.includes(\":\")\n      ? (() => {\n          const [curve, keyPart] = key.split(\":\");\n          if (curve !== \"ed25519\") {\n            throw new Error(`Unsupported curve: ${curve}`);\n          }\n          return keyPart;\n        })()\n      : key,\n  );\n\nexport const keyToString = (key) => `ed25519:${toBase58(key)}`;\n\nexport function publicKeyFromPrivate(privateKey) {\n  privateKey = keyFromString(privateKey).slice(0, 32);\n  const publicKey = ed25519.getPublicKey(privateKey);\n  return keyToString(publicKey);\n}\n\nexport function privateKeyFromRandom() {\n  const privateKey = crypto.getRandomValues(new Uint8Array(64));\n  return keyToString(privateKey);\n}\n\nexport function signHash(hash, privateKey) {\n  privateKey = keyFromString(privateKey).slice(0, 32);\n  const signature = ed25519.sign(fromBase58(hash), privateKey);\n  return toBase58(signature);\n}\n\nexport function signBytes(bytes, privateKey) {\n  const hash = sha256(bytes);\n  return signHash(toBase58(hash), privateKey);\n}\n", "import {\n  binary_to_base58 as toBase58,\n  base58_to_binary as fromBase58,\n} from \"base58-js\";\nimport Big from \"big.js\";\nimport { encode, decode } from 'js-base64';\n\nexport { toBase58, fromBase58 };\n\nconst LsPrefix = \"__fastnear_\";\n\nexport function toBase64(data) {\n  if (typeof data === 'string') {\n    return encode(data);\n  } else {\n    const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);\n    const str = String.fromCharCode(...bytes);\n    return encode(str);\n  }\n}\n\nexport function fromBase64(str) {\n  const binaryString = decode(str);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}\n\nexport function lsSet(key, value) {\n  if (value === null || value === undefined) {\n    localStorage.removeItem(LsPrefix + key);\n  } else {\n    localStorage.setItem(LsPrefix + key, JSON.stringify(value));\n  }\n}\n\nexport function lsGet(key) {\n  const value = localStorage.getItem(LsPrefix + key);\n  return tryParseJson(value, null);\n}\n\nexport function deepCopy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function tryParseJson(...args) {\n  try {\n    return JSON.parse(args[0]);\n  } catch {\n    if (args.length > 1) {\n      return args[1];\n    }\n    return args[0];\n  }\n}\n\nexport function canSignWithLAK(actions) {\n  return (\n    actions.length === 1 &&\n    actions[0].type === \"FunctionCall\" &&\n    Big(actions[0]?.deposit ?? \"0\").eq(0)\n  );\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAwB;AACxB,kBAAuB;;;ACDvB,uBAGO;AACP,iBAAgB;AAChB,uBAA+B;;;ADCxB,IAAM,gBAAgB,CAAC,YAC5B,iBAAAA;AAAA,EACE,IAAI,SAAS,GAAG,KACX,MAAM;AACL,UAAM,CAAC,OAAO,OAAO,IAAI,IAAI,MAAM,GAAG;AACtC,QAAI,UAAU,WAAW;AACvB,YAAM,IAAI,MAAM,sBAAsB,KAAK,EAAE;AAAA,IAC/C;AACA,WAAO;AAAA,EACT,GAAG,IACH;AACN;AAEK,IAAM,cAAc,CAAC,QAAQ,eAAW,iBAAAC,kBAAS,GAAG,CAAC;AAErD,SAAS,qBAAqB,YAAY;AAC/C,eAAa,cAAc,UAAU,EAAE,MAAM,GAAG,EAAE;AAClD,QAAM,YAAY,uBAAQ,aAAa,UAAU;AACjD,SAAO,YAAY,SAAS;AAC9B;AAEO,SAAS,uBAAuB;AACrC,QAAM,aAAa,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC;AAC5D,SAAO,YAAY,UAAU;AAC/B;AAEO,SAAS,SAAS,MAAM,YAAY;AACzC,eAAa,cAAc,UAAU,EAAE,MAAM,GAAG,EAAE;AAClD,QAAM,YAAY,uBAAQ,SAAK,iBAAAD,kBAAW,IAAI,GAAG,UAAU;AAC3D,aAAO,iBAAAC,kBAAS,SAAS;AAC3B;AAEO,SAAS,UAAU,OAAO,YAAY;AAC3C,QAAM,WAAO,oBAAO,KAAK;AACzB,SAAO,aAAS,iBAAAA,kBAAS,IAAI,GAAG,UAAU;AAC5C;",
  "names": ["fromBase58", "toBase58"]
}
